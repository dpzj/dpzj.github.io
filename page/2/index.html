<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="杜鹏之家">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="杜鹏之家">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="mr.杜">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 6.2.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="https://img1.baidu.com/it/u=412709218,617594518&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=504&amp;h=500" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">mr.杜</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">Home</a></li>
				        
							<li><a href="/archives">Archives</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
						<!-- music -->
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Event-Loop/" style="font-size: 10px;">Event Loop</a> <a href="/tags/Graphviz/" style="font-size: 10px;">Graphviz</a> <a href="/tags/Mock/" style="font-size: 10px;">Mock</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/React/" style="font-size: 19.29px;">React</a> <a href="/tags/Redux/" style="font-size: 11.43px;">Redux</a> <a href="/tags/async-await/" style="font-size: 10px;">async/await</a> <a href="/tags/css/" style="font-size: 13.57px;">css</a> <a href="/tags/echart/" style="font-size: 10px;">echart</a> <a href="/tags/es6/" style="font-size: 16.43px;">es6</a> <a href="/tags/eslint/" style="font-size: 10px;">eslint</a> <a href="/tags/git/" style="font-size: 15.71px;">git</a> <a href="/tags/glup/" style="font-size: 10.71px;">glup</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/html/" style="font-size: 14.29px;">html</a> <a href="/tags/http/" style="font-size: 17.14px;">http</a> <a href="/tags/javascript/" style="font-size: 18.57px;">javascript</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/nginx/" style="font-size: 10.71px;">nginx</a> <a href="/tags/nodejs/" style="font-size: 12.86px;">nodejs</a> <a href="/tags/python/" style="font-size: 10.71px;">python</a> <a href="/tags/qiankun/" style="font-size: 10px;">qiankun</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/serveless/" style="font-size: 10px;">serveless</a> <a href="/tags/typescript/" style="font-size: 12.14px;">typescript</a> <a href="/tags/vs-code/" style="font-size: 11.43px;">vs code</a> <a href="/tags/vue/" style="font-size: 20px;">vue</a> <a href="/tags/vue3/" style="font-size: 10px;">vue3</a> <a href="/tags/webpack/" style="font-size: 17.86px;">webpack</a> <a href="/tags/xml/" style="font-size: 10px;">xml</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 13.57px;">优化</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10.71px;">前端</a> <a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 15px;">小程序</a> <a href="/tags/%E6%8A%93%E5%8C%85/" style="font-size: 10px;">抓包</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正则表达式</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 12.86px;">浏览器</a> <a href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/" style="font-size: 10.71px;">移动端</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.57px;">设计模式</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/">github</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">I&#39;m a developer.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://img1.baidu.com/it/u=412709218,617594518&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=504&amp;h=500" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">Home</a></li>
		        
					<li><a href="/archives">Archives</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-html+css+js+ts/5-Typescript基础" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/08/03/html+css+js+ts/5-Typescript%E5%9F%BA%E7%A1%80/" class="article-date">
  	<time datetime="2021-08-03T13:18:43.000Z" itemprop="datePublished">2021-08-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/08/03/html+css+js+ts/5-Typescript%E5%9F%BA%E7%A1%80/">
        Typescript基础总结
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、typescript-安装"><a href="#一、typescript-安装" class="headerlink" title="一、typescript 安装"></a>一、typescript 安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i typescript -g</span><br></pre></td></tr></table></figure>

<blockquote>
<p>全局安装完成后，我们新建一个<code>hello.ts</code>的<code>ts</code>文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// hello.ts内容</span><br><span class="line">let a = &quot;poet&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接下来我们在命令行输入<code>tsc hello.ts</code>来编译这个<code>ts</code>文件，然后会在同级目录生成一个编译好了的<code>hello.js</code>文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// hello.js内容</span><br><span class="line">var = &quot;poet&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那么我们每次都要输<code>tsc hello.ts</code>命令来编译，这样很麻烦，能否让它自动编译？答案是可以的，使用<code>vscode</code>来开发，需要配置一下<code>vscode</code>就可以。</p>
</blockquote>
<blockquote>
<p>首先我们在命令行执行<code>tsc --init</code>来生成配置文件，然后我们在目录下看到生成了一个<code>tsconfig.json</code>文件</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/545.png" alt="img"></p>
<blockquote>
<p>这个<code>json</code>文件里有很多选项</p>
</blockquote>
<ul>
<li><code>target</code>是选择编译到什么语法</li>
<li><code>module</code>则是模块类型</li>
<li><code>outDir</code>则是输出目录，可以指定这个参数到指定目录</li>
</ul>
<blockquote>
<p>更多细节 <a target="_blank" rel="noopener" href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html</a></p>
</blockquote>
<blockquote>
<p>接下来我们需要开启监控了，在<code>vscode</code>任务栏中</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/546.png" alt="img"></p>
<p><strong>Typescript在线编辑器</strong></p>
<blockquote>
<p>建议使用在线编辑器练习 <a target="_blank" rel="noopener" href="http://www.typescriptlang.org/play/index.html">http://www.typescriptlang.org/play/index.html</a></p>
</blockquote>
<h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><blockquote>
<p><code>js</code>是弱类型语言，强弱类语言有什么区别呢？<code>typescript</code>最大的优点就是类型检查，可以帮你检查你定义的类型和赋值的类型。</p>
</blockquote>
<h3 id="2-1-布尔类型boolean"><a href="#2-1-布尔类型boolean" class="headerlink" title="2.1 布尔类型boolean"></a>2.1 布尔类型boolean</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 在js中，定义isFlag为true，为布尔类型boolean</span><br><span class="line">let isFlag = true;</span><br><span class="line">// 但是我们也可以重新给它赋值为字符串</span><br><span class="line">isFlag = &quot;hello swr&quot;;</span><br><span class="line"></span><br><span class="line">// 在ts中，定义isFlag为true，为布尔类型boolean</span><br><span class="line">// 在变量名后加冒号和类型，如  :boolean</span><br><span class="line">let isFlag:boolean = true</span><br><span class="line">// 重新赋值到字符串类型会报错</span><br><span class="line">isFlag = &quot;hello swr&quot; </span><br><span class="line"></span><br><span class="line">// 在java中，一般是这样定义，要写变量名也要写类型名</span><br><span class="line">// int a = 10; </span><br><span class="line">// string name = &quot;poetries&quot;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-数字类型number"><a href="#2-2-数字类型number" class="headerlink" title="2.2 数字类型number"></a>2.2 数字类型number</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let age:number = 28;</span><br><span class="line">age = 29;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-字符串类型string"><a href="#2-3-字符串类型string" class="headerlink" title="2.3 字符串类型string"></a>2.3 字符串类型string</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let name:string = &quot;poetries&quot;</span><br><span class="line">name = &quot;iamswr&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上<code>boolean</code>、<code>number</code>、<code>string</code>类型有个共性，就是可以通过<code>typeof</code>来获取到是什么类型，是基本数据类型</p>
</blockquote>
<p>那么复杂的数据类型是怎么处理的呢？</p>
<h3 id="2-4-数组-Array"><a href="#2-4-数组-Array" class="headerlink" title="2.4 数组 Array"></a>2.4 数组 Array</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 数组</span><br><span class="line">// 这是一个字符串数组，只能往里面放字符串，写别的类型会报错</span><br><span class="line">let persion:string[] = [&#x27;poetries&#x27;, &#x27;jing&#x27;]</span><br><span class="line">// 另一个写法 </span><br><span class="line">let persions:Array&lt;string&gt; = [&#x27;poetries&#x27;, &#x27;jing&#x27;]</span><br><span class="line"></span><br><span class="line">// 如果数组里放对象呢</span><br><span class="line">let persionObject:Array&lt;object&gt; = [&#123;name:&#x27;poetries&#x27;,age:22&#125;]</span><br><span class="line">let persionObjects:object[] = [&#123;name:&#x27;poetries&#x27;,age:22&#125;]</span><br><span class="line"></span><br><span class="line">// 在数组中放string、number、boolean、object</span><br><span class="line">let arr:Array&lt;number|object|string|boolean&gt; = [22, &#x27;test&#x27;, true, &#123;name:&#x27;poetries&#x27;&#125;]</span><br><span class="line"></span><br><span class="line">// 数组中放什么都可以</span><br><span class="line">let arrAny:Array&lt;any&gt; = [&#x27;test&#x27;,12,false]</span><br></pre></td></tr></table></figure>

<h3 id="2-5-元组类型tuple"><a href="#2-5-元组类型tuple" class="headerlink" title="2.5 元组类型tuple"></a>2.5 元组类型tuple</h3><ul>
<li>什么是元组类型？其实元组是数组的一种。</li>
<li>有点类似解构赋值，但是又不完全是解构赋值，比如元组类型必须一一对应上</li>
<li>元组类型是一个不可变的数组，长度、类型是不可变的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 元组类型tuple</span><br><span class="line">// 什么是元组类型？其实元组是数组的一种</span><br><span class="line">let per :[string,number,object] = [&#x27;poetries&#x27;,22,&#123;love: &#x27;coding&#x27;&#125;]</span><br></pre></td></tr></table></figure>

<h3 id="2-6-枚举类型enum"><a href="#2-6-枚举类型enum" class="headerlink" title="2.6 枚举类型enum"></a>2.6 枚举类型enum</h3><blockquote>
<p>什么是枚举？枚举有点类似一一列举，一个一个数出来。一般用于值是某几个固定的值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 枚举类型enum</span><br><span class="line"></span><br><span class="line">enum sex &#123;</span><br><span class="line">    BOY=&#x27;男孩&#x27;,</span><br><span class="line">    GIRL=&#x27;女孩&#x27;</span><br><span class="line">&#125;</span><br><span class="line">console.log(sex)</span><br><span class="line">// 转化为es5语法</span><br><span class="line">// 我们顺便看看实现的原理</span><br><span class="line"></span><br><span class="line">var sex;</span><br><span class="line">(function (sex) &#123;</span><br><span class="line">// 首先这里是一个自执行函数</span><br><span class="line">// 并且把sex定义为对象，传参进给自执行函数</span><br><span class="line">// 然后给sex对象添加属性并且赋值</span><br><span class="line">    sex[&quot;BOY&quot;] = &quot;\u7537\u5B69&quot;;</span><br><span class="line">    sex[&quot;GIRL&quot;] = &quot;\u5973\u5B69&quot;;</span><br><span class="line">&#125;)(sex || (sex = &#123;&#125;));</span><br><span class="line">console.log(sex);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>比如我们实际项目中，特别是商城类，订单会存在很多状态流转，那么非常适合用枚举</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum orderStatus &#123;</span><br><span class="line">    WAIT_FOR_PAY = &quot;待支付&quot;,</span><br><span class="line">    UNDELIVERED = &quot;完成支付，待发货&quot;,</span><br><span class="line">    DELIVERED = &quot;已发货&quot;,</span><br><span class="line">    COMPLETED = &quot;已确认收货&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>到这里，我们会有一个疑虑，为什么我们不这样写呢？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let orderStatus2 = &#123;</span><br><span class="line">    WAIT_FOR_PAY : &quot;待支付&quot;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果我们直接写对象的键值对方式，是可以在外部修改这个值的，而我们通过<code>enum</code>则不能修改定义好的值了</p>
</blockquote>
<h3 id="2-7-任意类型-any"><a href="#2-7-任意类型-any" class="headerlink" title="2.7 任意类型 any"></a>2.7 任意类型 any</h3><blockquote>
<p><code>any</code>有好处也有坏处，特别是前端，很多时候写类型的时候，几乎分不清楚类型，任意去写，写起来很爽，但是对于后续的重构、迭代等是非常不友好的，会暴露出很多问题，某种程度来说，<code>any</code>类型就是放弃了类型检查了</p>
</blockquote>
<p>比如我们有这样一个场景，就是需要获取某一个dom节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let btn = document.getElementById(&#x27;btn&#x27;);</span><br><span class="line">btn.style.color = &quot;blue&quot;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此时我们发现在<code>ts</code>中会报错</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/547.png" alt="img"></p>
<ul>
<li>因为我们取这个<code>dom</code>节点，有可能取到，也有可能没取到，当没取到的时候，相当于是<code>null</code>，是没有<code>style</code>这个属性的。</li>
<li>那么我们可以给它添加一个类型为<code>any</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 添加一个any类型，此时就不会报错了，但是也相当于放弃了类型检查了</span><br><span class="line">let btn:any = document.getElementById(&#x27;btn&#x27;);</span><br><span class="line">btn.style.color = &quot;blue&quot;;</span><br><span class="line">// 可以赋值任何类型的值</span><br><span class="line">// 跟以前我们var let声明的一模一样的</span><br><span class="line">let person:any = &quot;poetries&quot;</span><br><span class="line">person = 22</span><br></pre></td></tr></table></figure>

<h3 id="2-8-null-undefined类型"><a href="#2-8-null-undefined类型" class="headerlink" title="2.8 null undefined类型"></a>2.8 null undefined类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// (string | number | null | undefined) 相当于这几种类型</span><br><span class="line">// 是 string 或 number 或 null 或 undefined</span><br><span class="line"></span><br><span class="line">let str:(string | number | null | undefined)</span><br><span class="line"></span><br><span class="line">str = &#x27;poetries&#x27;</span><br><span class="line">str = 28</span><br><span class="line">str = null </span><br><span class="line">str = undefined</span><br></pre></td></tr></table></figure>

<h3 id="2-9-void类型"><a href="#2-9-void类型" class="headerlink" title="2.9 void类型"></a>2.9 void类型</h3><blockquote>
<p><code>void</code>表示没有任何类型，一般是定义函数没有返回值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// void 不能再函数里写return</span><br><span class="line">// 怎么理解叫没有返回值呢？此时我们给函数return一个值</span><br><span class="line">function say(name:string):void&#123;</span><br><span class="line">    console.log(&#x27;hello:&#x27;, name)</span><br><span class="line">    // return &quot;ok&quot; 会报错</span><br><span class="line">    return undefined;</span><br><span class="line">    return //不会报错</span><br><span class="line">&#125;</span><br><span class="line">say(&#x27;poetries&#x27;)</span><br><span class="line"></span><br><span class="line">// 返回一个字符串类型</span><br><span class="line">function say1(name:string):string &#123;</span><br><span class="line">    return &#x27;ok&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-10-never类型"><a href="#2-10-never类型" class="headerlink" title="2.10 never类型"></a>2.10 never类型</h3><blockquote>
<p>这个用得很少，一般是用于抛出异常</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function error(message:string):never &#123;</span><br><span class="line">    throw new Error(message)</span><br><span class="line">&#125;</span><br><span class="line">error(&#x27;errorMsg&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="2-11-我们要搞明白any、never、void"><a href="#2-11-我们要搞明白any、never、void" class="headerlink" title="2.11 我们要搞明白any、never、void"></a>2.11 我们要搞明白any、never、void</h3><ul>
<li><code>any</code>是任意的值</li>
<li><code>void</code>是不能有任何值</li>
<li><code>never</code>永远不会有返回值</li>
</ul>
<blockquote>
<p><code>any</code>比较好理解，就是任何值都可以</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let str:any = &quot;hello poetries&quot;</span><br><span class="line">str = 28</span><br><span class="line">str = true</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>void</code>不能有任何值(返回值)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function say():void &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>never</code>则不好理解，什么叫永远不会有返回值？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 除了上面举例的抛出异常以外，我们看一下这个例子</span><br><span class="line">// 这个loop函数，一旦开始执行，就永远不会结束</span><br><span class="line">// 可以看出在while中，是死循环，永远都不会有返回值，包括undefined</span><br><span class="line"></span><br><span class="line">function loop():never &#123;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        console.log(&quot;陷入死循环啦&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loop()</span><br><span class="line"></span><br><span class="line">// 包括比如JSON.parse也是使用这种 never | any</span><br><span class="line">function parse(str:string):(never | any)&#123;</span><br><span class="line">    return JSON.parse(str)</span><br><span class="line">&#125;</span><br><span class="line">// 首先在正常情况下，我们传一个JSON格式的字符串，是可以正常得到一个JSON对象的</span><br><span class="line">let json = parse(&#x27;&#123;&quot;name&quot;:&quot;poetries&quot;&#125;&#x27;)</span><br><span class="line">// 但是有时候，传进去的不一定是JSON格式的字符串，那么就会抛出异常</span><br><span class="line">// 此时就需要never了</span><br><span class="line">let json = parse(&quot;iamswr&quot;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也就是说，当一个函数执行的时候，被抛出异常打断了，导致没有返回值或者该函数是一个死循环，永远没有返回值，这样叫做永远不会有返回值。</p>
</blockquote>
<p>实际开发中，是<code>never</code>和联合类型来一起用，比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function say():(never | string) &#123;</span><br><span class="line">  return &quot;ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h2><h3 id="3-1-函数定义"><a href="#3-1-函数定义" class="headerlink" title="3.1 函数定义"></a>3.1 函数定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sayHello(name:string):void &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-函数参数处理"><a href="#3-2-函数参数处理" class="headerlink" title="3.2 函数参数处理"></a>3.2 函数参数处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 函数是这样定义的</span><br><span class="line">// 形参和实参一一对应，完全一样</span><br><span class="line">function sayHello(name:string,age:number):void &#123;</span><br><span class="line">    console.log(&#x27;hello&#x27;, name, age)</span><br><span class="line">&#125;</span><br><span class="line">sayHello(&#x27;poetries&#x27;,22)</span><br><span class="line"></span><br><span class="line">// 形参和实参要完全一样，如想不一样，则需要配置可选参数，可选参数放在后面</span><br><span class="line">// 可选参数，用 ？ 处理，只能放在后面</span><br><span class="line">function sayHelloToYou(name:string,age?:number):void &#123;</span><br><span class="line">    console.log(&#x27;hello&#x27;, name, age)</span><br><span class="line">&#125;</span><br><span class="line">sayHelloToYou(&#x27;poetries&#x27;)</span><br><span class="line"></span><br><span class="line">// 那么如何设置默认参数呢？</span><br><span class="line"></span><br><span class="line">function ajax(url:string,method:string = &#x27;GET&#x27;) &#123;</span><br><span class="line">    console.log(url, method)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 那么如何设置剩余参数呢？可以利用扩展运算符</span><br><span class="line"></span><br><span class="line">function sum(...args:Array&lt;number&gt;):number &#123;</span><br><span class="line">    return eval(args.join(&quot;+&quot;))</span><br><span class="line">&#125;</span><br><span class="line">let total:number = sum(1,2,3,4,5)</span><br><span class="line">console.log(total)</span><br></pre></td></tr></table></figure>

<h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 那么如何实现函数重载呢？函数重载是java中非常有名的，在java中函数的重载，是指两个或者两个以上的同名函数，参数的个数和类型不一样</span><br><span class="line"></span><br><span class="line">// 比如我们现在有两个同名函数</span><br><span class="line">// function eating(name:string) &#123;</span><br><span class="line">    </span><br><span class="line">// &#125;</span><br><span class="line">// function eating(name:string,age:number) &#123;</span><br><span class="line">    </span><br><span class="line">// &#125;</span><br><span class="line">// 那么我想达到一个效果</span><br><span class="line">// 当我传参数name时，执行name:string这个函数</span><br><span class="line">// 当我传参数name和age时，执行name:string,age:number这个函数</span><br><span class="line">// 此时该怎么办？</span><br><span class="line"></span><br><span class="line">// 接下来看一下typescript中的函数重载</span><br><span class="line"></span><br><span class="line">// 首先声明两个函数名一样的函数</span><br><span class="line">function eating(name: string):void;</span><br><span class="line">function eating(name: number):void;</span><br><span class="line"></span><br><span class="line">function eating(name:any): void &#123;</span><br><span class="line">    console.log(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eating(&quot;hello poetries&quot;)</span><br><span class="line">eating(22)</span><br><span class="line"></span><br><span class="line">// 在typescript中主要体现是同一个同名函数提供多个函数类型定义，函数实际上就只有一个，就是拥有函数体那个，如果想根据传入值类型的不一样执行不同逻辑，则需要在这个函数里面进行一个类型判断。</span><br><span class="line"></span><br><span class="line">// 那么这个函数重载有什么作用呢？其实在ts中，函数重载只是用来限制参数的个数和类型，用来检查类型的，而且重载不能拆开几个函数，这一点和java的处理是不一样的，需要注意。</span><br></pre></td></tr></table></figure>

<h2 id="四、类"><a href="#四、类" class="headerlink" title="四、类"></a>四、类</h2><h3 id="4-1-定义一个类"><a href="#4-1-定义一个类" class="headerlink" title="4.1 定义一个类"></a>4.1 定义一个类</h3><blockquote>
<p>如何定义一个类？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// ts 写法</span><br><span class="line">// 跟es6非常像 没有太大区别</span><br><span class="line">class Persion &#123;</span><br><span class="line">    // 这里声明的变量 是实例上的属性</span><br><span class="line">    name: string;</span><br><span class="line">    age:number;</span><br><span class="line"></span><br><span class="line">    constructor(name: string, age: number)&#123;</span><br><span class="line">        // this.name和this.age 必须先在前面声明好类型</span><br><span class="line">        // name: string</span><br><span class="line">        // age: number</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    // 原型方法</span><br><span class="line">    say():string &#123;</span><br><span class="line">        return &#x27;hello poetries&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = new Persion(&#x27;poetries&#x27;, 22)</span><br><span class="line">// 那么转为es5呢？</span><br><span class="line"></span><br><span class="line">var Persion = /** @class */ (function () &#123;</span><br><span class="line">    function Persion(name, age) &#123;</span><br><span class="line">        // this.name和this.age 必须先在前面声明好类型</span><br><span class="line">        // name: string</span><br><span class="line">        // age: number</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    // 原型方法</span><br><span class="line">    Persion.prototype.say = function () &#123;</span><br><span class="line">        return &#x27;hello poetries&#x27;;</span><br><span class="line">    &#125;;</span><br><span class="line">    return Persion;</span><br><span class="line">&#125;());</span><br><span class="line">var p = new Persion(&#x27;poetries&#x27;, 22);</span><br></pre></td></tr></table></figure>

<h3 id="4-2-类的继承"><a href="#4-2-类的继承" class="headerlink" title="4.2 类的继承"></a>4.2 类的继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 和es6也是差不多</span><br><span class="line">class Parent &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">    constructor(name:string, age: number)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    say():string&#123;</span><br><span class="line">        return &#x27;hello poetries&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">    childName: string;</span><br><span class="line">    constructor(name: string,age:number,childName:string) &#123;</span><br><span class="line">        super(name,age)</span><br><span class="line">        this.childName = childName</span><br><span class="line">    &#125;</span><br><span class="line">    childSay():string &#123;</span><br><span class="line">        return this.childName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let child = new Child(&#x27;poetries&#x27;, 22, &#x27;静观流叶&#x27;)</span><br><span class="line">console.log(child)</span><br></pre></td></tr></table></figure>

<h3 id="4-3-类的修饰符"><a href="#4-3-类的修饰符" class="headerlink" title="4.3 类的修饰符"></a>4.3 类的修饰符</h3><ul>
<li><code>public</code>公开的，可以供自己、子类以及其它类访问</li>
<li><code>protected</code>受保护的，可以供自己、子类访问，但是其他就访问不了</li>
<li><code>private</code>私有的，只有自己访问，而子类、其他都访问不了</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Parents &#123;</span><br><span class="line">    public name:string;</span><br><span class="line">    protected age:number;</span><br><span class="line">    private money:number;</span><br><span class="line"></span><br><span class="line">   // 简写</span><br><span class="line">   // constructor(public name:string,protected age:number,private money:number)</span><br><span class="line"></span><br><span class="line">   constructor(name: string, age:number,money:number) &#123;</span><br><span class="line">       this.name = name;</span><br><span class="line">       this.age = age;</span><br><span class="line">       this.money = money;</span><br><span class="line">   &#125;</span><br><span class="line">   getName():string &#123;</span><br><span class="line">       return this.name</span><br><span class="line">   &#125;</span><br><span class="line">   getAge():number&#123;</span><br><span class="line">       return this.age</span><br><span class="line">   &#125;</span><br><span class="line">   getMoney():number&#123;</span><br><span class="line">       return this.money</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">let pare = new Parents(&#x27;poetries&#x27;, 22, 3000)</span><br><span class="line">console.log(pare.name)</span><br><span class="line">// console.log(pare.age)  报错</span><br><span class="line">// console.log(pare.money) 报错</span><br></pre></td></tr></table></figure>

<h3 id="4-4-静态属性、静态方法"><a href="#4-4-静态属性、静态方法" class="headerlink" title="4.4 静态属性、静态方法"></a>4.4 静态属性、静态方法</h3><p>跟<code>es6</code>差不多</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person2 &#123;</span><br><span class="line">    // 类的静态属性</span><br><span class="line">    static name1 = &#x27;poetries&#x27;</span><br><span class="line"></span><br><span class="line">    // 类的静态方法</span><br><span class="line">    static say() &#123;</span><br><span class="line">        console.log(&#x27;hello poetries&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let per2 = new Person2()</span><br><span class="line">Person2.say() // hello poetries</span><br><span class="line">// per2.say() 报错</span><br></pre></td></tr></table></figure>

<h3 id="4-5-抽象类"><a href="#4-5-抽象类" class="headerlink" title="4.5 抽象类"></a>4.5 抽象类</h3><ul>
<li>抽象类和方法，有点类似抽取共性出来，但是又不是具体化，比如说，世界上的动物都需要吃东西，那么会把吃东西这个行为，抽象出来</li>
<li>如果子类继承的是一个抽象类，子类必须实现父类里的抽象方法，不然的话不能实例化，会报错</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/ 关键字 abstract抽象</span><br><span class="line">// 定义抽象类</span><br><span class="line"></span><br><span class="line">abstract class Animal &#123;</span><br><span class="line">    // 实际上是使用了public修饰符</span><br><span class="line">    // 如果添加private修饰符会报错</span><br><span class="line">    abstract eat():void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 需要注意的是这个Animal是不能实例化的</span><br><span class="line">// let animal = new Animal() // 报错</span><br><span class="line"></span><br><span class="line">// // 抽象类的抽象方法，意思就是，需要在继承这个抽象类的子类中</span><br><span class="line">// 实现这个抽象方法，不然会报错</span><br><span class="line">// 报错，因为在子类中没有实现eat抽象方法</span><br><span class="line">// class Person4 extends Animal&#123;</span><br><span class="line">//     test()&#123;</span><br><span class="line">//         console.log(&quot;吃米饭&quot;)</span><br><span class="line">//     &#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// Dog类继承Animal类后并且实现了抽象方法eat，所以不会报错</span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">    eat()&#123;</span><br><span class="line">        console.log(&quot;吃骨头&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、接口"><a href="#五、接口" class="headerlink" title="五、接口"></a>五、接口</h2><blockquote>
<p>这里的接口，主要是一种规范，规范某些类必须遵守规范，和抽象类有点类似，但是不局限于类，还有属性、函数等</p>
</blockquote>
<h3 id="5-1-接口规范对象"><a href="#5-1-接口规范对象" class="headerlink" title="5.1 接口规范对象"></a>5.1 接口规范对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//假设我们需要获取用户信息</span><br><span class="line">// 我们通过这样的方式 规范必须传name和age的值</span><br><span class="line">function getUserInfo(user:&#123;name:string,age:number&#125;) &#123;</span><br><span class="line">    console.log(user.name,user.age)</span><br><span class="line">&#125;</span><br><span class="line">getUserInfo(&#123;name: &#x27;poetries&#x27;, age: 22&#125;)</span><br><span class="line"></span><br><span class="line">// 这样看挺完美的， 那么问题就出现了，如果我另外还有一个方法，也是需要这个规范呢？</span><br><span class="line"></span><br><span class="line">function getUserInfo1(user:&#123;name:string,age:number&#125;)&#123;</span><br><span class="line">    console.log(`$&#123;user.name&#125; $&#123;user.age&#125;`)</span><br><span class="line">&#125;</span><br><span class="line">function getInfo(user:&#123;name:string,age:number&#125;)&#123;</span><br><span class="line">    console.log(`$&#123;user.name&#125; $&#123;user.age&#125;`)</span><br><span class="line">&#125;</span><br><span class="line">getUserInfo1(&#123;name:&quot;poetries&quot;,age:22&#125;)</span><br><span class="line">getInfo(&#123;name:&quot;poetries&quot;,age:22&#125;)</span><br><span class="line"></span><br><span class="line">// 可以看出，函数getUserInfo和getInfo都遵循同一个规范，那么我们有办法对这个规范复用吗？</span><br><span class="line"></span><br><span class="line">// 首先把需要复用的规范，写到接口 关键字interface</span><br><span class="line">interface infoInterface &#123;</span><br><span class="line">    name: string,</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line">// 然后把这个接口 替换到我们需要复用的地方</span><br><span class="line">function getUserInfo2(user:infoInterface) &#123;</span><br><span class="line">    console.log(user.name,user.age)</span><br><span class="line">&#125;</span><br><span class="line">function getInfo2(user:infoInterface) &#123;</span><br><span class="line">    console.log(user.name,user.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserInfo2(&#123;name:&quot;poetries&quot;,age:22&#125;)</span><br><span class="line">getInfo2(&#123;name:&quot;poetries&quot;,age:22&#125;)</span><br><span class="line"></span><br><span class="line">// 那么有些参数可传可不传，该怎么处理呢？</span><br><span class="line"></span><br><span class="line">interface infoInterface2&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">    city?:string;</span><br><span class="line">&#125;</span><br><span class="line">function getUserInfo3(user:infoInterface2)&#123;</span><br><span class="line">    console.log(`$&#123;user.name&#125; $&#123;user.age&#125; $&#123;user.city&#125;`)</span><br><span class="line">&#125;</span><br><span class="line">function getInfo3(user:infoInterface)&#123;</span><br><span class="line">    console.log(`$&#123;user.name&#125; $&#123;user.age&#125;`)</span><br><span class="line">&#125;</span><br><span class="line">getUserInfo3(&#123;name:&quot;poetries&quot;,age:22,city:&quot;深圳&quot;&#125;)</span><br><span class="line">getInfo3(&#123;name:&quot;iamswr&quot;,age:22&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="5-2-接口规范函数"><a href="#5-2-接口规范函数" class="headerlink" title="5.2 接口规范函数"></a>5.2 接口规范函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 对一个函数的参数和返回值进行规范</span><br><span class="line">interface mytotal &#123;</span><br><span class="line">    // 左侧是函数的参数，右侧是函数的返回类型</span><br><span class="line">    (a:number,b:number):number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let totalSum:mytotal = function(a:number,b:number):number &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(totalSum(10, 20))</span><br></pre></td></tr></table></figure>

<h3 id="5-3-接口规范数组"><a href="#5-3-接口规范数组" class="headerlink" title="5.3 接口规范数组"></a>5.3 接口规范数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface userInterface &#123;</span><br><span class="line">    // index为数组索引 类型是number</span><br><span class="line">    // 右边是数组里为字符串的数组成员</span><br><span class="line">    [index: number]: string;</span><br><span class="line">&#125;</span><br><span class="line">let arrTest: userInterface = [&#x27;poetries&#x27;, &#x27;静观流叶&#x27;]</span><br><span class="line"></span><br><span class="line">console.log(arrTest)</span><br></pre></td></tr></table></figure>

<h3 id="5-4-接口规范类"><a href="#5-4-接口规范类" class="headerlink" title="5.4 接口规范类"></a>5.4 接口规范类</h3><blockquote>
<p>这个比较重要，因为写<code>react</code>的时候会经常使用到类</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 首先实现一个接口</span><br><span class="line">interface Animal2 &#123;</span><br><span class="line">    // 这个类必须有name</span><br><span class="line">    name:string;</span><br><span class="line"></span><br><span class="line">    // 这个类必须有eat方法</span><br><span class="line">    eat(any:string):void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 关键字implements实现</span><br><span class="line">// 因为接口是抽象的，需要通过子类是实现它</span><br><span class="line"></span><br><span class="line">class Person6 implements Animal2 &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    eat(any:string):void &#123;</span><br><span class="line">        console.log(`吃`+any)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果想遵循多个接口</span><br><span class="line"></span><br><span class="line">interface Animal3 &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    eat(any: string):void;</span><br><span class="line">&#125;</span><br><span class="line">// 新增一个接口</span><br><span class="line">interface Animal4 &#123;</span><br><span class="line">    sleep():void;</span><br><span class="line">&#125;</span><br><span class="line">// 可以在implements后面通过逗号添加和java一样</span><br><span class="line">class Person7 implements Animal3,Animal4 &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name:string)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    eat(any:string) &#123;</span><br><span class="line">        console.log(`吃`+any)</span><br><span class="line">    &#125;</span><br><span class="line">    sleep() &#123;</span><br><span class="line">        console.log(&#x27;睡觉&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-接口继承接口"><a href="#5-5-接口继承接口" class="headerlink" title="5.5 接口继承接口"></a>5.5 接口继承接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">interface Animal5&#123;</span><br><span class="line">    name:string;</span><br><span class="line">    eat(any:string):void;</span><br><span class="line">&#125;</span><br><span class="line">// 像类一样 通过extends继承</span><br><span class="line">interface Animal6 extends Animal5 &#123;</span><br><span class="line">    sleep():void;</span><br><span class="line">&#125;</span><br><span class="line">// 因为Animal6类继承了Animal5</span><br><span class="line">// 所以这里遵循Animal6就相当于把Animal5也继承了</span><br><span class="line"></span><br><span class="line">class Person8 implements Animal2 &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name:string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    eat(any:string):void&#123;</span><br><span class="line">        console.log(`吃$&#123;any&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">    sleep()&#123;</span><br><span class="line">        console.log(&#x27;睡觉&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、泛型"><a href="#六、泛型" class="headerlink" title="六、泛型"></a>六、泛型</h2><h3 id="6-1-函数的泛型"><a href="#6-1-函数的泛型" class="headerlink" title="6.1 函数的泛型"></a>6.1 函数的泛型</h3><blockquote>
<p>泛型可以支持不特定的数据类型，什么叫不特定呢？比如我们有一个方法，里面接收参数，但是参数类型我们是不知道，但是这个类型在方法里面很多地方会用到，参数和返回值要保持一致性</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 假设我们有一个需求，我们不知道函数接收什么类型的参数，也不知道返回值的类型</span><br><span class="line">// 而我们又需要传进去的参数类型和返回值的类型保持一致，那么我们就需要用到泛型</span><br><span class="line"></span><br><span class="line">// &lt;T&gt;的意思是泛型，即generic type</span><br><span class="line">// 可以看出value的类型也为T，返回值的类型也为T</span><br><span class="line">function deal&lt;T&gt;(value:T):T&#123;</span><br><span class="line">    return value</span><br><span class="line">&#125;</span><br><span class="line">// 下面的&lt;string&gt;、&lt;number&gt;实际上用的时候再传给上面的&lt;T&gt;</span><br><span class="line">console.log(deal&lt;string&gt;(&quot;poetries&quot;))</span><br><span class="line">console.log(deal&lt;number&gt;(22))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上，泛型用得还是比较少，主要是看类的泛型是如何使用的</p>
</blockquote>
<h3 id="6-2-类的泛型"><a href="#6-2-类的泛型" class="headerlink" title="6.2 类的泛型"></a>6.2 类的泛型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyMath&lt;T&gt; &#123;</span><br><span class="line">    // 定义一个私有属性</span><br><span class="line"></span><br><span class="line">    private arr: T[] = []</span><br><span class="line"></span><br><span class="line">    // 规定传参类型</span><br><span class="line">    add(value: T) &#123;</span><br><span class="line">        this.arr.push(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 这里规定了类型为number</span><br><span class="line">// 相当于把T替换为number</span><br><span class="line"></span><br><span class="line">let mymath = new MyMath&lt;number&gt;()</span><br><span class="line">mymath.add(1)</span><br><span class="line">mymath.add(2)</span><br><span class="line">mymath.add(3)</span><br></pre></td></tr></table></figure>

<p><strong>有了接口为什么还需要抽象类？</strong></p>
<blockquote>
<p>接口里面只能放定义，抽象类里面可以放普通类、普通类的方法、定义抽象的东西。</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/typescript/" rel="tag">typescript</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-html+css+js+ts/5-Ts-interface与type区别" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/07/25/html+css+js+ts/5-Ts-interface%E4%B8%8Etype%E5%8C%BA%E5%88%AB/" class="article-date">
  	<time datetime="2021-07-25T08:20:43.000Z" itemprop="datePublished">2021-07-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/25/html+css+js+ts/5-Ts-interface%E4%B8%8Etype%E5%8C%BA%E5%88%AB/">
        TS-interface与type区别
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="相同之处"><a href="#相同之处" class="headerlink" title="相同之处"></a>相同之处</h2><h3 id="都可以描述一个对象或者函数"><a href="#都可以描述一个对象或者函数" class="headerlink" title="都可以描述一个对象或者函数"></a>都可以描述一个对象或者函数</h3><p><strong>interface</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface User &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface SetUser &#123;</span><br><span class="line">  (name: string, age: number): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>type</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type User = &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type SetUser = (name: string, age: number)=&gt; void;</span><br></pre></td></tr></table></figure>

<h3 id="都允许拓展（extends）"><a href="#都允许拓展（extends）" class="headerlink" title="都允许拓展（extends）"></a>都允许拓展（extends）</h3><blockquote>
<p><code>interface</code> 和 <code>type</code> 都可以拓展，并且两者并不是相互独立的，也就是说 <code>interface</code> 可以 <code>extends type</code>, <code>type</code> 也可以 <code>extends interface</code> 。 虽然效果差不多，但是两者语法不同</p>
</blockquote>
<p><strong>interface extends interface</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Name &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">interface User extends Name &#123; </span><br><span class="line">  age: number; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>type extends type</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Name = &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">type User = Name &amp; &#123; age: number  &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>interface extends type</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Name = &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">interface User extends Name &#123; </span><br><span class="line">  age: number; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>type extends interface</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Name &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">type User = Name &amp; &#123; </span><br><span class="line">  age: number; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h2><h3 id="type-可以而-interface-不行"><a href="#type-可以而-interface-不行" class="headerlink" title="type 可以而 interface 不行"></a>type 可以而 interface 不行</h3><blockquote>
<p>type 可以声明基本类型别名，联合类型，元组等类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 基本类型别名</span><br><span class="line">type Name = string</span><br><span class="line"></span><br><span class="line">// 联合类型</span><br><span class="line">interface Dog &#123;</span><br><span class="line">    wong();</span><br><span class="line">&#125;</span><br><span class="line">interface Cat &#123;</span><br><span class="line">    miao();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Pet = Dog | Cat</span><br><span class="line"></span><br><span class="line">// 具体定义数组每个位置的类型</span><br><span class="line">type PetList = [Dog, Pet]</span><br></pre></td></tr></table></figure>

<p><strong>type 语句中还可以使用 typeof 获取实例的 类型进行赋值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 当你想获取一个变量的类型时，使用 typeof</span><br><span class="line">let div = document.createElement(&#x27;div&#x27;);</span><br><span class="line">type B = typeof div</span><br></pre></td></tr></table></figure>

<p><strong>其他骚操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type StringOrNumber = string | number;  </span><br><span class="line">type Text = string | &#123; text: string &#125;;  </span><br><span class="line">type NameLookup = Dictionary&lt;string, Person&gt;;  </span><br><span class="line">type Callback&lt;T&gt; = (data: T) =&gt; void;  </span><br><span class="line">type Pair&lt;T&gt; = [T, T];  </span><br><span class="line">type Coordinates = Pair&lt;number&gt;;  </span><br><span class="line">type Tree&lt;T&gt; = T | &#123; left: Tree&lt;T&gt;, right: Tree&lt;T&gt; &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="interface-可以而-type-不行"><a href="#interface-可以而-type-不行" class="headerlink" title="interface 可以而 type 不行"></a>interface 可以而 type 不行</h3><blockquote>
<p><code>interface</code> 能够声明合并</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface User &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface User &#123;</span><br><span class="line">  sex: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">User 接口为 &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">  sex: string </span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果不清楚什么时候用<code>interface/type</code>，能用 <code>interface</code> 实现，就用 <code>interface</code> , 如果不能就用 <code>type</code></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/typescript/" rel="tag">typescript</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-数据可视化/Graphviz绘制流程图" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/07/16/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/Graphviz%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE/" class="article-date">
  	<time datetime="2021-07-16T15:08:47.000Z" itemprop="datePublished">2021-07-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/16/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/Graphviz%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE/">
        Graphviz绘制流程图
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、初识Graphviz"><a href="#一、初识Graphviz" class="headerlink" title="一、初识Graphviz"></a>一、初识Graphviz</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><blockquote>
<p><code>GraphViz</code>是一个开源的图像可视化的软件，是贝尔实验室开发的一个开源的工具包，它使用一个特定的<code>DSL</code>(领域特定语言): <code>dot</code>作为脚本语言，然后使用布局引擎来解析此脚本，并完成自动布局。<code>graphviz</code>提供丰富的导出格式，如常用的图片格式，<code>SVG</code>，<code>PDF</code>格式等</p>
</blockquote>
<h3 id="1-2-环境搭建"><a href="#1-2-环境搭建" class="headerlink" title="1.2 环境搭建"></a>1.2 环境搭建</h3><p><strong>结合sublime Text插件实时编译预览</strong></p>
<blockquote>
<p>使用<code>shift+command+p</code>，输入搜索选中<code>Package Control: Install Package</code>,然后输入<code>GraphViz</code>,然后安装<code>GraphVizPreview</code>即可，安装完成后，只要全选中代码，然后按<code>shift+command+g</code>就可以预览了。</p>
</blockquote>
<ul>
<li>其实也可以直接用<code>brew</code>安装<code>GraphViz</code>,但是每次要敲命令行，太麻烦了</li>
</ul>
<p><strong><code>mac</code>下执行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install graphviz</span><br></pre></td></tr></table></figure>

<blockquote>
<p>终端编译代码 <code>dot test.dot -T png -o test.png</code></p>
</blockquote>
<h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><blockquote>
<p><code>Graphviz</code> 支持两类图：无向图（<code>graph</code>,用“ <code>- -</code> ”表示节点之间）和 有向图（<code>digraph</code>,用“ <code>-&gt;</code>” 表示节点之间）。graphviz包含3中元素，图，顶点和边。<strong>每个元素都可以具有各自的属性，用来定义字体，样式，颜色，形状等</strong></p>
</blockquote>
<p><strong><code>GraphViz</code>中包含多种布局</strong></p>
<ul>
<li><code>dot</code> 默认布局，用于有向图</li>
<li><code>neato</code> 基于<code>spring-model</code>算法(<code>force-based</code>)</li>
<li><code>twopo</code> 径向布局</li>
<li><code>circo</code> 圆形布局</li>
<li><code>fdp</code> 用于无向图</li>
</ul>
<h3 id="2-1-第一个graphviz图"><a href="#2-1-第一个graphviz图" class="headerlink" title="2.1 第一个graphviz图"></a>2.1 第一个graphviz图</h3><blockquote>
<p>语法介绍 <a target="_blank" rel="noopener" href="http://graphs.grevian.org/reference">http://graphs.grevian.org/reference</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">digraph abc&#123;</span><br><span class="line">  a;</span><br><span class="line">  b;</span><br><span class="line">  c;</span><br><span class="line">  d;</span><br><span class="line"> </span><br><span class="line">  a -&gt; b;</span><br><span class="line">  b -&gt; d;</span><br><span class="line">  c -&gt; d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://poetries1.gitee.io/img-repo/2019/10/208.png" alt="img"></p>
<p><strong>定义顶点和边的样式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">digraph abc&#123;</span><br><span class="line">  node [shape=&quot;record&quot;];</span><br><span class="line">  edge [style=&quot;dashed&quot;];</span><br><span class="line">  a;</span><br><span class="line">  b;</span><br><span class="line">  c;</span><br><span class="line">  d;</span><br><span class="line"> </span><br><span class="line">  a -&gt; b;</span><br><span class="line">  b -&gt; d;</span><br><span class="line">  c -&gt; d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1124873-67688cd634d43522.png" alt="img"></p>
<blockquote>
<p>进一步修改顶点和边样式,将顶点<code>a</code>的颜色改为淡绿色，并将<code>c</code>到<code>d</code>的边改为红色</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">digraph abc&#123;</span><br><span class="line">  node [shape=&quot;record&quot;];</span><br><span class="line">  edge [style=&quot;dashed&quot;];</span><br><span class="line"> </span><br><span class="line">  a [style=&quot;filled&quot;, color=&quot;black&quot;, fillcolor=&quot;chartreuse&quot;];</span><br><span class="line">  b;</span><br><span class="line">  c;</span><br><span class="line">  d;</span><br><span class="line"> </span><br><span class="line">  a -&gt; b;</span><br><span class="line">  b -&gt; d;</span><br><span class="line">  c -&gt; d [color=&quot;red&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://poetries1.gitee.io/img-repo/2019/10/209.png" alt="img"></p>
<p>其他例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">digraph demo&#123;</span><br><span class="line">  label=&quot;儿茶酚胺合成代谢路径&quot;;</span><br><span class="line"></span><br><span class="line">  酪氨酸 -&gt; L多巴 -&gt; 多巴胺 -&gt; 去甲肾上腺素 -&gt; 肾上腺素;</span><br><span class="line"></span><br><span class="line">  下丘脑 -&gt; 多巴胺;</span><br><span class="line">  交感神经元 -&gt; 去甲肾上腺素;</span><br><span class="line">  肾上腺髓质 -&gt; 去甲肾上腺素,肾上腺素;</span><br><span class="line"></span><br><span class="line">  酪氨酸 [label=&quot;酪氨酸&quot;,color=green];</span><br><span class="line">  多巴胺 [label=&quot;多巴胺&quot;, color=red];</span><br><span class="line">  肾上腺素 [label=&quot;肾上腺素&quot;, color=red];</span><br><span class="line"></span><br><span class="line">  下丘脑 [shape=box];</span><br><span class="line">  交感神经元 [shape=box];</span><br><span class="line">  肾上腺髓质 [shape=box];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://poetries1.gitee.io/img-repo/2019/10/210.png" alt="img"></p>
<h3 id="2-2-带标签"><a href="#2-2-带标签" class="headerlink" title="2.2 带标签"></a>2.2 带标签</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">digraph &#123;</span><br><span class="line"></span><br><span class="line">    player[label = &quot;player&quot;, color = Blue, fontcolor = Red, fontsize = 24, shape = box];</span><br><span class="line">    game[label = &quot;game&quot;, color = Red, fontcolor = Blue, fontsize = 24, shape = ellipse];</span><br><span class="line"></span><br><span class="line">    player -&gt; game[label = &quot;play&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://poetries1.gitee.io/img-repo/2019/10/211.jpg" alt="img"></p>
<h3 id="2-3-子视图"><a href="#2-3-子视图" class="headerlink" title="2.3 子视图"></a>2.3 子视图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">digraph &#123;</span><br><span class="line"></span><br><span class="line">    label = visitNet</span><br><span class="line"></span><br><span class="line">    rankdir = LR</span><br><span class="line"></span><br><span class="line">    node[color = Red, fontsize = 24, shape = box]</span><br><span class="line">    edge[color = Blue, style = &quot;dashed&quot;]</span><br><span class="line"></span><br><span class="line">    user[style = &quot;filled&quot;, color = &quot;yellow&quot;, fillcolor = &quot;chartreuse&quot;]</span><br><span class="line">    subgraph cluster_cd&#123;</span><br><span class="line">        label = &quot;server and browser&quot;</span><br><span class="line">        bgcolor = green;</span><br><span class="line"></span><br><span class="line">        browser -&gt; server</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    user -&gt; computer;</span><br><span class="line">    computer -&gt; browser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://poetries1.gitee.io/img-repo/2019/10/212.jpg" alt="img"></p>
<h3 id="2-4-结构视图"><a href="#2-4-结构视图" class="headerlink" title="2.4 结构视图"></a>2.4 结构视图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">digraph &#123;</span><br><span class="line"></span><br><span class="line">    node[shape = record];</span><br><span class="line">    struct1[label = &quot;&lt;f0&gt; left|&lt;f1&gt; mid&amp;#92; dle|&lt;f2&gt; right&quot;];</span><br><span class="line">    struct2[label = &quot;&lt;f0&gt; one|&lt;f1&gt; two&quot;];</span><br><span class="line">    struct3[label = &quot;hello&amp;#92;nworld | &#123;b|&#123;c|&lt;here&gt; d|e&#125;|f&#125;|g|h&quot;];</span><br><span class="line">    struct1:f1 -&gt; struct2:f0;</span><br><span class="line">    struct1:f2 -&gt; struct3:here;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://poetries1.gitee.io/img-repo/2019/10/213.jpg" alt="img"></p>
<h3 id="2-5-树形结构"><a href="#2-5-树形结构" class="headerlink" title="2.5 树形结构"></a>2.5 树形结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">digraph tree &#123;</span><br><span class="line">  </span><br><span class="line">  fontname = &quot;PingFang-SC-Light&quot;</span><br><span class="line">  fontsize = 24</span><br><span class="line"></span><br><span class="line">  node[shape = &quot;plaintext&quot;]</span><br><span class="line"></span><br><span class="line">  1 -&gt; 2;</span><br><span class="line">  1 -&gt; 3;</span><br><span class="line">  2 -&gt; 4;</span><br><span class="line">  2 -&gt; 5;</span><br><span class="line">  3 -&gt; 6;</span><br><span class="line">  3 -&gt; 7;</span><br><span class="line">  4 -&gt; 8;</span><br><span class="line">  4 -&gt; 9;</span><br><span class="line">  5 -&gt; 10;</span><br><span class="line">  5 -&gt; 11;</span><br><span class="line">  6 -&gt; 12;</span><br><span class="line">  6 -&gt; 13;</span><br><span class="line">  7 -&gt; 14;</span><br><span class="line">  7 -&gt; 15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://poetries1.gitee.io/img-repo/2019/10/214.jpg" alt="img"></p>
<h3 id="2-6-时序图"><a href="#2-6-时序图" class="headerlink" title="2.6 时序图"></a>2.6 时序图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">digraph time &#123;</span><br><span class="line"></span><br><span class="line">    rankdir = &quot;LR&quot;;</span><br><span class="line">    node[shape = &quot;point&quot;, width = 0, height = 0];</span><br><span class="line">    edge[arrowhead = &quot;none&quot;, style = &quot;dashed&quot;];</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        rank = &quot;same&quot;</span><br><span class="line">        edge[style = &quot;solided&quot;];</span><br><span class="line">        APP[shape = &quot;plaintext&quot;];</span><br><span class="line">        APP -&gt; step00 -&gt; step01 -&gt; step02 -&gt; step03 -&gt; step04 -&gt; step05;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        rank=&quot;same&quot;;</span><br><span class="line">        edge[style=&quot;solided&quot;];</span><br><span class="line">        SDK[shape=&quot;plaintext&quot;];</span><br><span class="line">        SDK -&gt; step10 -&gt; step11 -&gt; step12 -&gt; step13 -&gt; step14 -&gt; step15;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        rank=&quot;same&quot;;</span><br><span class="line">        edge[style=&quot;solided&quot;];</span><br><span class="line">        AliPay[shape=&quot;plaintext&quot;];</span><br><span class="line">        AliPay -&gt; step20 -&gt; step21 -&gt; step22 -&gt; step23 -&gt; step24 -&gt; step25;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        rank=&quot;same&quot;;</span><br><span class="line">        edge[style=&quot;solided&quot;];</span><br><span class="line">        Server[shape=&quot;plaintext&quot;];</span><br><span class="line">        Server -&gt; step30 -&gt; step31 -&gt; step32 -&gt; step33 -&gt; step34 -&gt; step35;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    step00 -&gt; step10 [label=&quot;sends order info&quot;, arrowhead=&quot;normal&quot;];</span><br><span class="line">    step11 -&gt; step21 [label=&quot;open AliPay&quot;, arrowhead=&quot;normal&quot;];</span><br><span class="line">    step22 -&gt; step12 [label=&quot;pay success&quot;, arrowhead=&quot;normal&quot;];</span><br><span class="line">    step13 -&gt; step03 [label=&quot;pay success&quot;, arrowhead=&quot;normal&quot;];</span><br><span class="line">    step24 -&gt; step34 [label=&quot;pay success&quot;, arrowhead=&quot;normal&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://poetries1.gitee.io/img-repo/2019/10/215.jpg" alt="img"></p>
<h3 id="2-7-一个hash表的数据结构"><a href="#2-7-一个hash表的数据结构" class="headerlink" title="2.7 一个hash表的数据结构"></a>2.7 一个hash表的数据结构</h3><blockquote>
<p><code>hash</code>表内容</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct st_hash_type &#123;</span><br><span class="line">    int (*compare) ();</span><br><span class="line">    int (*hash) ();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct st_table_entry &#123;</span><br><span class="line">    unsigned int hash;</span><br><span class="line">    char *key;</span><br><span class="line">    char *record;</span><br><span class="line">    st_table_entry *next;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct st_table &#123;</span><br><span class="line">    struct st_hash_type *type;</span><br><span class="line">    int num_bins;</span><br><span class="line">/* slot count */</span><br><span class="line">    int num_entries;</span><br><span class="line">/* total number of entries */</span><br><span class="line">    struct st_table_entry **bins;</span><br><span class="line">/* slot */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>脚本如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">digraph st2&#123;</span><br><span class="line">  fontname = &quot;Verdana&quot;;</span><br><span class="line">  fontsize = 10;</span><br><span class="line">  rankdir=TB;</span><br><span class="line"> </span><br><span class="line">  node [fontname = &quot;Verdana&quot;, fontsize = 10, color=&quot;skyblue&quot;, shape=&quot;record&quot;];</span><br><span class="line"> </span><br><span class="line">  edge [fontname = &quot;Verdana&quot;, fontsize = 10, color=&quot;crimson&quot;, style=&quot;solid&quot;];</span><br><span class="line"> </span><br><span class="line">  st_hash_type [label=&quot;&#123;&lt;head&gt;st_hash_type|(*compare)|(*hash)&#125;&quot;];</span><br><span class="line">  st_table_entry [label=&quot;&#123;&lt;head&gt;st_table_entry|hash|key|record|&lt;next&gt;next&#125;&quot;];</span><br><span class="line">  st_table [label=&quot;&#123;st_table|&lt;type&gt;type|num_bins|num_entries|&lt;bins&gt;bins&#125;&quot;];</span><br><span class="line"> </span><br><span class="line">  st_table:bins -&gt; st_table_entry:head;</span><br><span class="line">  st_table:type -&gt; st_hash_type:head;</span><br><span class="line">  st_table_entry:next -&gt; st_table_entry:head [style=&quot;dashed&quot;, color=&quot;forestgreen&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://poetries1.gitee.io/img-repo/2019/10/216.jpg" alt="img"></p>
<h3 id="2-8-模块的生命周期图"><a href="#2-8-模块的生命周期图" class="headerlink" title="2.8 模块的生命周期图"></a>2.8 模块的生命周期图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">digraph module_lc&#123;</span><br><span class="line">  rankdir=TB;</span><br><span class="line">  fontname = &quot;Microsoft YaHei&quot;;</span><br><span class="line">  fontsize = 12;</span><br><span class="line"> </span><br><span class="line">  node [fontname = &quot;Microsoft YaHei&quot;, fontsize = 12, shape = &quot;Mrecord&quot;, color=&quot;skyblue&quot;, style=&quot;filled&quot;];</span><br><span class="line">  edge [fontname = &quot;Microsoft YaHei&quot;, fontsize = 12, color=&quot;darkgreen&quot; ];</span><br><span class="line"> </span><br><span class="line">  installed [label=&quot;已安装状态&quot;];</span><br><span class="line">  resolved [label=&quot;已就绪状态&quot;];</span><br><span class="line">  uninstalled [label=&quot;已卸载状态&quot;];</span><br><span class="line">  starting [label=&quot;正在启动&quot;];</span><br><span class="line">  active [label=&quot;已激活(运行)状态&quot;];</span><br><span class="line">  stopping [label=&quot;正在停止&quot;];</span><br><span class="line">  start [label=&quot;&quot;, shape=&quot;circle&quot;, width=0.5, fixedsize=true, style=&quot;filled&quot;, color=&quot;black&quot;];</span><br><span class="line"> </span><br><span class="line">  start -&gt; installed [label=&quot;安装&quot;];</span><br><span class="line">  installed -&gt; uninstalled [label=&quot;卸载&quot;];</span><br><span class="line">  installed -&gt; resolved [label=&quot;准备&quot;];</span><br><span class="line">  installed -&gt; installed [label=&quot;更新&quot;];</span><br><span class="line">  resolved -&gt; installed [label=&quot;更新&quot;];</span><br><span class="line">  resolved -&gt; uninstalled [label=&quot;卸载&quot;];</span><br><span class="line">  resolved -&gt; starting [label=&quot;启动&quot;];</span><br><span class="line">  starting -&gt; active [label=&quot;&quot;];</span><br><span class="line">  active -&gt; stopping [label=&quot;停止&quot;];</span><br><span class="line">  stopping -&gt; resolved [label=&quot;&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://poetries1.gitee.io/img-repo/2019/10/217.jpg" alt="img"></p>
<h3 id="2-9-简单的UML类图"><a href="#2-9-简单的UML类图" class="headerlink" title="2.9 简单的UML类图"></a>2.9 简单的UML类图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">digraph G&#123;</span><br><span class="line"> </span><br><span class="line">  fontname = &quot;Courier New&quot;</span><br><span class="line">  fontsize = 10</span><br><span class="line"> </span><br><span class="line">  node [ fontname = &quot;Courier New&quot;, fontsize = 10, shape = &quot;record&quot; ];</span><br><span class="line">  edge [ fontname = &quot;Courier New&quot;, fontsize = 10 ];</span><br><span class="line"> </span><br><span class="line">  Animal [ label = &quot;&#123;Animal |+ name : String\\l+ age : int\\l|+ die() : void\\l&#125;&quot; ];</span><br><span class="line"> </span><br><span class="line">      subgraph clusterAnimalImpl&#123;</span><br><span class="line">          bgcolor=&quot;yellow&quot;</span><br><span class="line">          Dog [ label = &quot;&#123;Dog||+ bark() : void\\l&#125;&quot; ];</span><br><span class="line">          Cat [ label = &quot;&#123;Cat||+ meow() : void\\l&#125;&quot; ];</span><br><span class="line">      &#125;;</span><br><span class="line"> </span><br><span class="line">  edge [ arrowhead = &quot;empty&quot; ];</span><br><span class="line"> </span><br><span class="line">  Dog-&gt;Animal;</span><br><span class="line">  Cat-&gt;Animal;</span><br><span class="line">  Dog-&gt;Cat [arrowhead=&quot;none&quot;, label=&quot;0..*&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://poetries1.gitee.io/img-repo/2019/10/218.jpg" alt="img"></p>
<h3 id="2-10-有限状态机"><a href="#2-10-有限状态机" class="headerlink" title="2.10 有限状态机"></a>2.10 有限状态机</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">digraph finite_state_machine &#123;</span><br><span class="line">    rankdir=LR;</span><br><span class="line">    size=&quot;8,5&quot;</span><br><span class="line">    node [shape = circle];</span><br><span class="line">    S0 -&gt; S1 [ label = &quot;Lift Nozzle&quot; ]</span><br><span class="line">    S1 -&gt; S0 [ label = &quot;Replace Nozzle&quot; ]</span><br><span class="line">    S1 -&gt; S2 [ label = &quot;Authorize Pump&quot; ]</span><br><span class="line">    S2 -&gt; S0 [ label = &quot;Replace Nozzle&quot; ]</span><br><span class="line">    S2 -&gt; S3 [ label = &quot;Pull Trigger&quot; ]</span><br><span class="line">    S3 -&gt; S2 [ label = &quot;Release Trigger&quot; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://img2.tuicool.com/yEze6z.png%21web" alt="img"></p>
<h2 id="三、语法"><a href="#三、语法" class="headerlink" title="三、语法"></a>三、语法</h2><blockquote>
<p>完整列表 <a target="_blank" rel="noopener" href="http://graphviz.org/doc/info/attrs.html">http://graphviz.org/doc/info/attrs.html</a></p>
</blockquote>
<h3 id="3-1-图像属性"><a href="#3-1-图像属性" class="headerlink" title="3.1 图像属性"></a>3.1 图像属性</h3><ul>
<li><code>label=&quot;My Graph&quot;;</code> 给图像设置标签</li>
<li><code>rankdir=LR</code>; 将图片由原来的从上到下布局变成从左到右布局</li>
<li><code>&#123;rank=same; a, b, c &#125;</code> 将一组元素放到同一个<code>level</code></li>
<li><code>splines=&quot;line&quot;</code>; 让边框变为直线，没有曲线和锐角</li>
<li><code>K=0.6</code>; 用来在布局中影响<code>spring</code>属性，<code>spring</code>属性可以用于将节点往外推，这个在<code>twopi</code>和<code>sfdp</code>布局中很有用。</li>
</ul>
<h3 id="3-2-交点属性"><a href="#3-2-交点属性" class="headerlink" title="3.2 交点属性"></a>3.2 交点属性</h3><ul>
<li><code>[label=&quot;Some Label&quot;]</code> 给交点打标签</li>
<li><code>[color=&quot;red&quot;]</code> 给交点上色</li>
<li><code>[fillcolor=&quot;blue&quot;]</code> 设置交点的填充色</li>
</ul>
<h3 id="3-3-边的属性"><a href="#3-3-边的属性" class="headerlink" title="3.3 边的属性"></a>3.3 边的属性</h3><ul>
<li><code>[label=&quot;Some Label&quot;]</code> 给边设置标签 (设置路径权重的时候很有用)</li>
<li><code>[color=&quot;red&quot;]</code> # 给交点上色 (标示路径的时候很有用)</li>
<li><code>[penwidth=2.0]</code> # 给边适配厚度，标示路径的时候很有用。</li>
</ul>
<h3 id="3-4-尺寸-背景颜色"><a href="#3-4-尺寸-背景颜色" class="headerlink" title="3.4 尺寸, 背景颜色"></a>3.4 尺寸, 背景颜色</h3><ul>
<li><code>fixedsize=true</code>;</li>
<li><code>size=&quot;1,1&quot;</code>;</li>
<li><code>resolution=72</code>;</li>
<li><code>bgcolor=&quot;#C6CFD532&quot;</code>;</li>
</ul>
<h2 id="四、一些技巧"><a href="#四、一些技巧" class="headerlink" title="四、一些技巧"></a>四、一些技巧</h2><h3 id="4-1-插入图片"><a href="#4-1-插入图片" class="headerlink" title="4.1 插入图片"></a>4.1 插入图片</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">digraph &#123;</span><br><span class="line"></span><br><span class="line">    c[shape = none, image = &quot;./pic.png&quot;]</span><br><span class="line">    a -&gt; b -&gt; c;</span><br><span class="line">    c -&gt; d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://poetries1.gitee.io/img-repo/2019/10/219.jpg" alt="img"></p>
<blockquote>
<p>注：需要用命令行<code>dot test.dot -T png -o test.png</code>生成，前提是用<code>brew</code>安装了<code>GraphViz</code></p>
</blockquote>
<h3 id="4-2-统一节点和连线"><a href="#4-2-统一节点和连线" class="headerlink" title="4.2 统一节点和连线"></a>4.2 统一节点和连线</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">digraph &#123;</span><br><span class="line"></span><br><span class="line">    node[color = Red, fontsize = 24, shape = box]</span><br><span class="line">    edge[color = Blue, style = &quot;dashed&quot;]</span><br><span class="line"></span><br><span class="line">    c[shape = none, image = &quot;./pic.png&quot;]</span><br><span class="line">    a -&gt; b -&gt; c;</span><br><span class="line">    c -&gt; d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://poetries1.gitee.io/img-repo/2019/10/220.jpg" alt="img"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Graphviz/" rel="tag">Graphviz</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/">数据可视化</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-数据可视化/echart使用技巧" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/06/23/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/echart%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" class="article-date">
  	<time datetime="2021-06-23T11:34:07.000Z" itemprop="datePublished">2021-06-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/06/23/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/echart%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">
        echart使用小结
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>十一个组件选项主要用来进行交互</p>
</blockquote>
<h2 id="一、Timeline选项"><a href="#一、Timeline选项" class="headerlink" title="一、Timeline选项"></a>一、Timeline选项</h2><ul>
<li>时间轴，每个图表最多仅有一个时间轴控件</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/45.png" alt="img"></p>
<h2 id="二、Title选项"><a href="#二、Title选项" class="headerlink" title="二、Title选项"></a>二、Title选项</h2><ul>
<li>每个图表最多仅有一个标题控件，每个标题控件可设主副标题</li>
</ul>
<blockquote>
<p>可以对标题文字的大小样式进行设置</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/46.png" alt="img"></p>
<h2 id="三、toolbox"><a href="#三、toolbox" class="headerlink" title="三、toolbox"></a>三、toolbox</h2><ul>
<li>工具箱，每个图表最多仅有一个工具箱。工具箱里面可以实现图表类型的切换，保存图片，刷新，查看数据等功能。可以对其像素进行设置</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/47.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    mark : &#123;</span><br><span class="line"></span><br><span class="line">        show : false,</span><br><span class="line"></span><br><span class="line">        title : &#123;</span><br><span class="line"></span><br><span class="line">            mark : &#x27;辅助线开关&#x27;,</span><br><span class="line"></span><br><span class="line">            markUndo : &#x27;删除辅助线&#x27;,</span><br><span class="line"></span><br><span class="line">            markClear : &#x27;清空辅助线&#x27;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        lineStyle : &#123;</span><br><span class="line"></span><br><span class="line">            width : 2,</span><br><span class="line"></span><br><span class="line">            color : &#x27;#1e90ff&#x27;,</span><br><span class="line"></span><br><span class="line">            type : &#x27;dashed&#x27;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    dataZoom : &#123;</span><br><span class="line"></span><br><span class="line">        show : false,</span><br><span class="line"></span><br><span class="line">        title : &#123;</span><br><span class="line"></span><br><span class="line">            dataZoom : &#x27;区域缩放&#x27;,</span><br><span class="line"></span><br><span class="line">            dataZoomReset : &#x27;区域缩放后退&#x27;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    dataView : &#123;</span><br><span class="line"></span><br><span class="line">        show : false,</span><br><span class="line"></span><br><span class="line">        title : &#x27;数据视图&#x27;,</span><br><span class="line"></span><br><span class="line">        readOnly: false,</span><br><span class="line"></span><br><span class="line">        lang: [&#x27;数据视图&#x27;, &#x27;关闭&#x27;, &#x27;刷新&#x27;]</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    magicType: &#123;</span><br><span class="line"></span><br><span class="line">        show : false,</span><br><span class="line"></span><br><span class="line">        title : &#123;</span><br><span class="line"></span><br><span class="line">            line : &#x27;折线图切换&#x27;,</span><br><span class="line"></span><br><span class="line">            bar : &#x27;柱形图切换&#x27;,</span><br><span class="line"></span><br><span class="line">            stack : &#x27;堆积&#x27;,</span><br><span class="line"></span><br><span class="line">            tiled : &#x27;平铺&#x27;,</span><br><span class="line"></span><br><span class="line">            force: &#x27;力导向布局图切换&#x27;,</span><br><span class="line"></span><br><span class="line">            chord: &#x27;和弦图切换&#x27;,</span><br><span class="line"></span><br><span class="line">            pie: &#x27;饼图切换&#x27;,</span><br><span class="line"></span><br><span class="line">            funnel: &#x27;漏斗图切换&#x27;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        option: &#123;</span><br><span class="line"></span><br><span class="line">            // line: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // bar: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // stack: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // tiled: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // force: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // chord: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // pie: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // funnel: &#123;...&#125;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        type : []</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    restore : &#123;</span><br><span class="line"></span><br><span class="line">        show : false,</span><br><span class="line"></span><br><span class="line">        title : &#x27;还原&#x27;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    saveAsImage : &#123;</span><br><span class="line"></span><br><span class="line">        show : false,</span><br><span class="line"></span><br><span class="line">        title : &#x27;保存为图片&#x27;,</span><br><span class="line"></span><br><span class="line">        type : &#x27;png&#x27;,</span><br><span class="line"></span><br><span class="line">        lang : [&#x27;点击保存&#x27;]</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、tooltip"><a href="#四、tooltip" class="headerlink" title="四、tooltip"></a>四、tooltip</h2><ul>
<li>提示框，鼠标悬浮交互时的信息提示</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/48.png" alt="img"></p>
<h2 id="五、legend"><a href="#五、legend" class="headerlink" title="五、legend"></a>五、legend</h2><ul>
<li>图例，每个图表最多仅有一个图例，混搭图表共享</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/49.png" alt="img"></p>
<h2 id="六、dataRange"><a href="#六、dataRange" class="headerlink" title="六、dataRange"></a>六、dataRange</h2><ul>
<li>值域选择，每个图表最多仅有一个值域控件</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/50.png" alt="img"></p>
<h2 id="七、dataZoom"><a href="#七、dataZoom" class="headerlink" title="七、dataZoom"></a>七、dataZoom</h2><ul>
<li><a target="_blank" rel="noopener" href="http://echarts.baidu.com/echarts2/doc/example/dataZoom.html">数据区域缩放</a>。与toolbox.feature.dataZoom同步，仅对直角坐标系图表有效</li>
</ul>
<h2 id="roamController"><a href="#roamController" class="headerlink" title="roamController"></a>roamController</h2><ul>
<li><a target="_blank" rel="noopener" href="http://echarts.baidu.com/echarts2/doc/example/map1.html">缩放漫游组件</a>，仅对地图有效</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/51.png" alt="img"></p>
<h2 id="八、grid"><a href="#八、grid" class="headerlink" title="八、grid"></a>八、grid</h2><blockquote>
<p>直角坐标系内绘图网格</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/52.png" alt="img"></p>
<h2 id="九、xAxis"><a href="#九、xAxis" class="headerlink" title="九、xAxis"></a>九、xAxis</h2><blockquote>
<p>直角坐标系中横轴数组，数组中每一项代表一条横轴坐标轴，仅有一条时可省略数组。最多同时存在2条横轴，单条横轴时可指定安放于grid的底部（默认）或顶部，2条同时存在时位置互斥，默认第一条安放于底部，第二条安放于顶部</p>
</blockquote>
<h2 id="十、yAxis"><a href="#十、yAxis" class="headerlink" title="十、yAxis"></a>十、yAxis</h2><blockquote>
<p>直角坐标系中纵轴数组，数组中每一项代表一条纵轴坐标轴，仅有一条时可省略数组。最多同时存在2条纵轴，单条纵轴时可指定安放于grid的左侧（默认）或右侧，2条同时存在时位置互斥，默认第一条安放于左侧，第二条安放于右侧</p>
</blockquote>
<ul>
<li>坐标轴有三种类型，类目型、数值型和时间型，纵轴通常为数值型，但条形图时则纵轴为类目型</li>
</ul>
<h2 id="十一、series（通用）"><a href="#十一、series（通用）" class="headerlink" title="十一、series（通用）"></a>十一、series（通用）</h2><blockquote>
<p>驱动图表生成的数据内容数组，数组中每一项为一个系列的选项及数据，其中个别选项仅在部分图表类型中有效，请注意适用类型</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/echart/" rel="tag">echart</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/">数据可视化</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-浏览器/浅谈PWA(Progressive Web App)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/06/12/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%85%E8%B0%88PWA(Progressive%20Web%20App)/" class="article-date">
  	<time datetime="2021-06-12T08:27:05.000Z" itemprop="datePublished">2021-06-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/06/12/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%85%E8%B0%88PWA(Progressive%20Web%20App)/">
        浅谈PWA(Progressive Web App)
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、初识PWA"><a href="#一、初识PWA" class="headerlink" title="一、初识PWA"></a>一、初识PWA</h1><blockquote>
<ul>
<li><code>PWA</code>，即<code>Progressive Web App</code>, 是提升 <code>Web App</code> 的体验的一种新方法，能给用户原生应用的体验。</li>
<li>一个 <code>PWA</code> 应用首先是一个网页, 可以通过 <code>Web</code> 技术编写出一个网页应用. 随后添加上 <code>App Manifest</code> 和 <code>Service Worker</code> 来实现<code>PWA</code> 的安装和离线等功能</li>
</ul>
</blockquote>
<h2 id="1-1-PWA中的一些技术"><a href="#1-1-PWA中的一些技术" class="headerlink" title="1.1 PWA中的一些技术"></a>1.1 PWA中的一些技术</h2><blockquote>
<p><code>PWA</code>本身其实是一个概念集合，它不是指某一项技术，而是通过一系列的<code>Web</code>技术与<code>Web</code>标准来优化<code>Web App</code>的安全、性能和体验。其中涉及到的一些技术概念包括了</p>
</blockquote>
<ul>
<li><code>Web App Manifest</code></li>
<li><code>Service Worker</code></li>
<li><code>Cache API</code> 缓存</li>
<li><code>Push、Notification</code> 推送与通知</li>
<li><code>Background Sync</code>后台同步</li>
<li>响应式设计</li>
</ul>
<h2 id="1-2-解决了哪些问题"><a href="#1-2-解决了哪些问题" class="headerlink" title="1.2 解决了哪些问题"></a>1.2 解决了哪些问题</h2><ul>
<li>可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏</li>
<li>实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能</li>
<li>实现了消息推送</li>
</ul>
<h2 id="1-3-PWA存在的问题"><a href="#1-3-PWA存在的问题" class="headerlink" title="1.3 PWA存在的问题"></a>1.3 PWA存在的问题</h2><ul>
<li>支持率不高:现在<code>ios</code>手机端不支持<code>pwa</code>，<code>IE</code>也暂时不支持<br><code>Chrome</code>在中国桌面版占有率还是不错的，安卓移动端上的占有率却很低</li>
<li>各大厂商还未明确支持<code>pwa</code></li>
<li>依赖的<code>GCM</code>服务在国内无法使用</li>
<li>微信小程序的竞争</li>
</ul>
<blockquote>
<p>尽管有上述的一些缺点，PWA技术仍然有很多可以使用的点。</p>
</blockquote>
<ul>
<li><code>service worker</code>技术实现离线缓存，可以将一些不经常更改的静态文件放到缓存中，提升用户体验。</li>
<li><code>service worker</code>实现消息推送，使用浏览器推送功能，吸引用户<br>渐进式开发，尽管一些浏览器暂时不支持，可以利用上述技术给使用支持浏览器的用户带来更好的体验</li>
</ul>
<h1 id="二、PWA的实现"><a href="#二、PWA的实现" class="headerlink" title="二、PWA的实现"></a>二、PWA的实现</h1><h2 id="2-1-Manifest实现添加至主屏幕"><a href="#2-1-Manifest实现添加至主屏幕" class="headerlink" title="2.1 Manifest实现添加至主屏幕"></a>2.1 Manifest实现添加至主屏幕</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--index.html--&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;Minimal PWA&lt;/title&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no&quot; /&gt;</span><br><span class="line">  &lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot; /&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;main.css&quot;&gt;</span><br><span class="line">  &lt;link rel=&quot;icon&quot; href=&quot;/e.png&quot; type=&quot;image/png&quot; /&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">// manifest.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Minimal PWA&quot;, // 必填 显示的插件名称</span><br><span class="line">  &quot;short_name&quot;: &quot;PWA Demo&quot;, // 可选  在APP launcher和新的tab页显示，如果没有设置，则使用name</span><br><span class="line">  &quot;description&quot;: &quot;The app that helps you understand PWA&quot;, //用于描述应用</span><br><span class="line">  &quot;display&quot;: &quot;standalone&quot;, // 定义开发人员对Web应用程序的首选显示模式。standalone模式会有单独的</span><br><span class="line">  &quot;start_url&quot;: &quot;/&quot;, // 应用启动时的url</span><br><span class="line">  &quot;theme_color&quot;: &quot;#313131&quot;, // 桌面图标的背景色</span><br><span class="line">  &quot;background_color&quot;: &quot;#313131&quot;, // 为web应用程序预定义的背景颜色。在启动web应用程序和加载应用程序的内容之间创建了一个平滑的过渡。</span><br><span class="line">  &quot;icons&quot;: [ // 桌面图标，是一个数组</span><br><span class="line">    &#123;</span><br><span class="line">    &quot;src&quot;: &quot;icon/lowres.webp&quot;,</span><br><span class="line">    &quot;sizes&quot;: &quot;48x48&quot;,  // 以空格分隔的图片尺寸</span><br><span class="line">    &quot;type&quot;: &quot;image/webp&quot;  // 帮助userAgent快速排除不支持的类型</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;src&quot;: &quot;icon/lowres&quot;,</span><br><span class="line">    &quot;sizes&quot;: &quot;48x48&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;src&quot;: &quot;icon/hd_hi.ico&quot;,</span><br><span class="line">    &quot;sizes&quot;: &quot;72x72 96x96 128x128 256x256&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;src&quot;: &quot;icon/hd_hi.svg&quot;,</span><br><span class="line">    &quot;sizes&quot;: &quot;72x72&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>Manifest</code>参考文档：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Manifest">https://developer.mozilla.org/zh-CN/docs/Web/Manifest</a></li>
<li>如果用的是安卓手机，可以下载chrome浏览器自己操作看看</li>
</ul>
</blockquote>
<h2 id="2-2-service-worker实现离线缓存"><a href="#2-2-service-worker实现离线缓存" class="headerlink" title="2.2 service worker实现离线缓存"></a>2.2 service worker实现离线缓存</h2><h3 id="2-2-1-什么是service-worker"><a href="#2-2-1-什么是service-worker" class="headerlink" title="2.2.1 什么是service worker"></a>2.2.1 什么是service worker</h3><blockquote>
<p><code>Service Worker</code> 是 Chrome 团队提出和力推的一个 WEB API，用于给 web 应用提供高级的可持续的后台处理能力</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/401.png" alt="img"></p>
<blockquote>
<p><code>Service Workers</code> 就像介于服务器和网页之间的拦截器，能够拦截进出的HTTP 请求，从而完全控制你的网站</p>
</blockquote>
<h3 id="2-2-2-最主要的特点"><a href="#2-2-2-最主要的特点" class="headerlink" title="2.2.2 最主要的特点"></a>2.2.2 最主要的特点</h3><ul>
<li>在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响，可以监听和截拦作用域范围内所有页面的 <code>HTTP</code> 请求。</li>
<li>网站必须使用 <code>HTTPS</code>。除了使用本地开发环境调试时(如域名使用 <code>localhost</code>)</li>
<li>运行于浏览器后台，可以控制打开的作用域范围下所有的页面请求</li>
<li>单独的作用域范围，单独的运行环境和执行线程</li>
<li>不能操作页面 <code>DOM</code>。但可以通过事件机制来处理</li>
<li>事件驱动型服务线程</li>
</ul>
<blockquote>
<p>为什么要求网站必须是<code>HTTPS</code>的，大概是因为<code>service worker</code>权限太大能拦截所有页面的请求，如果<code>http</code>的网站安装<code>service worker</code>很容易被攻击</p>
</blockquote>
<h3 id="2-2-3-生命周期"><a href="#2-2-3-生命周期" class="headerlink" title="2.2.3 生命周期"></a>2.2.3 生命周期</h3><p><img src="https://poetries1.gitee.io/img-repo/2019/10/402.png" alt="img"></p>
<blockquote>
<p>当用户首次导航至 URL 时，服务器会返回响应的网页。</p>
</blockquote>
<ul>
<li>第1步:当你调用 <code>register()</code> 函数时， <code>Service Worker</code>开始下载。</li>
<li>第2步:在注册过程中，浏览器会下载、解析并执行 <code>Service Worker ()</code>。如果在此步骤中出现任何错误，<code>register()</code>返回的 <code>promise</code> 都会执行 <code>reject</code>操作，并且 <code>Service Worker</code> 会被废弃。</li>
<li>第3步:一旦 <code>Service Worker</code> 成功执行了，<code>install</code> 事件就会激活</li>
<li>第4步:安装完成，<code>Service Worker</code> 便会激活，并控制在其范围内的一切。如果生命周期中的所有事件都成功了，<code>Service Worker</code>便已准备就绪，随时可以使用了！</li>
</ul>
<blockquote>
<p><code>chrome://serviceworker-internals</code> 来了解当前浏览器中所有已安装<code>Service Worker</code>的详细情况</p>
</blockquote>
<h3 id="2-2-4-实现离线缓存"><a href="#2-2-4-实现离线缓存" class="headerlink" title="2.2.4 实现离线缓存"></a>2.2.4 实现离线缓存</h3><p><strong>HTTP缓存</strong></p>
<ul>
<li><code>Web</code> 服务器可以使用 <code>Expires</code> 首部来通知 <code>Web</code>客户端，它可以使用资源的当前副本，直到指定的“过期时间”。反过来，浏览器可以缓存此资源，并且只有在有效期满后才会再次检查新版本。使用 <code>HTTP</code> 缓存意味着你要依赖服务器来告诉你何时缓存资源和何时过期</li>
</ul>
<p><strong>service worker缓存</strong></p>
<ul>
<li><code>Service Workers</code>的强大在于它们拦截 HTTP 请求的能力<br>进入任何传入的<code>HTTP</code> 请求，并决定想要如何响应。在你的 <code>Service Worker</code> 中，可以编写逻辑来决定想要缓存的资源，以及需要满足什么条件和资源需要缓存多久。一切尽归你掌控！</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--index.html--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Hello Caching World!&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;!-- Image --&gt;</span><br><span class="line">    &lt;img src=&quot;/images/hello.png&quot; /&gt;                 </span><br><span class="line">    &lt;!-- JavaScript --&gt;</span><br><span class="line">    &lt;script async src=&quot;/js/script.js&quot;&gt;&lt;/script&gt;     </span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      // 注册 service worker</span><br><span class="line">      if (&#x27;serviceWorker&#x27; in navigator) &#123;           </span><br><span class="line">        navigator.serviceWorker.register(&#x27;/service-worker.js&#x27;, &#123;scope: &#x27;/&#x27;&#125;).then(function (registration) &#123;</span><br><span class="line">          // 注册成功</span><br><span class="line">          console.log(&#x27;ServiceWorker registration successful with scope: &#x27;, registration.scope);</span><br><span class="line">        &#125;).catch(function (err) &#123;                   </span><br><span class="line">          // 注册失败 :(</span><br><span class="line">          console.log(&#x27;ServiceWorker registration failed: &#x27;, err);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>注：<code>Service Worker</code>的注册路径决定了其 <code>scope</code>默认作用页面的范围。</li>
<li>如果 <code>service-worker.js</code>是在 <code>/sw/</code> 页面路径下，这使得该 <code>Service Worker</code> 默认只会收到 页面<code>/sw/</code> 路径下的 fetch 事件。</li>
<li>如果存放在网站的根路径下，则将会收到该网站的所有 <code>fetch</code>事件。</li>
<li>如果希望改变它的作用域，可在第二个参数设置 <code>scope</code> 范围。示例中将其改为了根目录，即对整个站点生效。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// service-worker.js</span><br><span class="line"></span><br><span class="line">var cacheName = &#x27;helloWorld&#x27;;     // 缓存的名称  </span><br><span class="line">// install 事件，它发生在浏览器安装并注册 Service Worker 时        </span><br><span class="line">self.addEventListener(&#x27;install&#x27;, event =&gt; &#123; </span><br><span class="line">/* event.waitUtil 用于在安装成功之前执行一些预装逻辑</span><br><span class="line"> 但是建议只做一些轻量级和非常重要资源的缓存，减少安装失败的概率</span><br><span class="line"> 安装成功后 ServiceWorker 状态会从 installing 变为 installed */</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(cacheName)                  </span><br><span class="line">    .then(cache =&gt; cache.addAll([    // 如果所有的文件都成功缓存了，便会安装完成。如果任何文件下载失败了，那么安装过程也会随之失败。        </span><br><span class="line">      &#x27;/js/script.js&#x27;,</span><br><span class="line">      &#x27;/images/hello.png&#x27;</span><br><span class="line">    ]))</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line">  </span><br><span class="line">/**</span><br><span class="line">为 fetch 事件添加一个事件监听器。接下来，使用 caches.match() 函数来检查传入的请求 URL 是否匹配当前缓存中存在的任何内容。如果存在的话，返回缓存的资源。</span><br><span class="line">如果资源并不存在于缓存当中，通过网络来获取资源，并将获取到的资源添加到缓存中。</span><br><span class="line">*/</span><br><span class="line">self.addEventListener(&#x27;fetch&#x27;, function (event) &#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request)                  </span><br><span class="line">    .then(function (response) &#123;</span><br><span class="line">      if (response) &#123;                            </span><br><span class="line">        return response;                         </span><br><span class="line">      &#125;</span><br><span class="line">      var requestToCache = event.request.clone();  //          </span><br><span class="line">      return fetch(requestToCache).then(                   </span><br><span class="line">        function (response) &#123;</span><br><span class="line">          if (!response || response.status !== 200) &#123;      </span><br><span class="line">            return response;</span><br><span class="line">          &#125;</span><br><span class="line">          var responseToCache = response.clone();          </span><br><span class="line">          caches.open(cacheName)                           </span><br><span class="line">            .then(function (cache) &#123;</span><br><span class="line">              cache.put(requestToCache, responseToCache);  </span><br><span class="line">            &#125;);</span><br><span class="line">          return response;             </span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：为什么用<code>request.clone()</code>和<code>response.clone()</code><br>需要这么做是因为<code>request</code>和<code>response</code>是一个流，它只能消耗一次。因为我们已经通过缓存消耗了一次，然后发起 <code>HTTP</code> 请求还要再消耗一次，所以我们需要在此时克隆请求<br>Clone the request—a request is a stream and can only be consumed once</p>
</blockquote>
<h3 id="2-2-5-调试相关"><a href="#2-2-5-调试相关" class="headerlink" title="2.2.5 调试相关"></a>2.2.5 调试相关</h3><blockquote>
<p>chrome浏览器打开<code>https://googlechrome.github.io/samples/service-worker/basic/index.html</code>，这是一个实现了<code>service worker</code>离线缓存功能的网站，打开调试工具</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/403.png" alt="img"></p>
<ul>
<li>勾选可以模拟网站离线情况，勾选后<code>network</code>会有一个黄色警告图标，该网站已经离线。此时刷新页面，页面仍然能够正常显示</li>
<li>当前<code>service worker</code>的<code>scope</code>。它能够拦截<code>https://googlechrome.github.i</code>…，同样也能够拦截<code>https://googlechrome.github.i.</code>..<em>&#x2F;</em>.html下的请求</li>
</ul>
<blockquote>
<p>调试面板具体代表的什么参看 <code>https://x5.tencent.com/tbs/guide/serviceworker.html</code>的第三部分</p>
</blockquote>
<h2 id="2-3-serice-worker实现消息推送"><a href="#2-3-serice-worker实现消息推送" class="headerlink" title="2.3 serice worker实现消息推送"></a>2.3 serice worker实现消息推送</h2><p><img src="https://poetries1.gitee.io/img-repo/2019/10/404.png" alt="img"></p>
<ul>
<li>步骤一、提示用户并获得他们的订阅详细信息</li>
<li>步骤二、将这些详细信息保存在服务器上</li>
<li>步骤三、在需要时发送任何消息</li>
</ul>
<blockquote>
<p>不同浏览器需要用不同的推送消息服务器。以 Chrome 上使用 <code>Google Cloud Messaging</code> 作为推送服务为例，第一步是注册 <code>applicationServerKey</code>(通过 GCM 注册获取)，并在页面上进行订阅或发起订阅。每一个会话会有一个独立的端点（<code>endpoint</code>），订阅对象的属性(<code>PushSubscription.endpoint</code>) 即为端点值。将端点发送给服务器后，服务器用这一值来发送消息给会话的激活的 Service Worker （通过 GCM 与浏览器客户端沟通</p>
</blockquote>
<p><strong>步骤一和步骤二</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--index.html--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Progressive Times&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;manifest&quot; href=&quot;/manifest.json&quot;&gt;                                      </span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      var endpoint;</span><br><span class="line">      var key;</span><br><span class="line">      var authSecret;</span><br><span class="line">      var vapidPublicKey = &#x27;BAyb_WgaR0L0pODaR7wWkxJi__tWbM1MPBymyRDFEGjtDCWeRYS9EF7yGoCHLdHJi6hikYdg4MuYaK0XoD0qnoY&#x27;;</span><br><span class="line">      // 方法很复杂，但是可以不用具体看，知识用来转化vapidPublicKey用</span><br><span class="line">      function urlBase64ToUint8Array(base64String) &#123;                                  </span><br><span class="line">        const padding = &#x27;=&#x27;.repeat((4 - base64String.length % 4) % 4);</span><br><span class="line">        const base64 = (base64String + padding)</span><br><span class="line">          .replace(/\-/g, &#x27;+&#x27;)</span><br><span class="line">          .replace(/_/g, &#x27;/&#x27;);</span><br><span class="line">        const rawData = window.atob(base64);</span><br><span class="line">        const outputArray = new Uint8Array(rawData.length);</span><br><span class="line">        for (let i = 0; i &lt; rawData.length; ++i) &#123;</span><br><span class="line">          outputArray[i] = rawData.charCodeAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return outputArray;</span><br><span class="line">      &#125;</span><br><span class="line">      if (&#x27;serviceWorker&#x27; in navigator) &#123;</span><br><span class="line">        navigator.serviceWorker.register(&#x27;sw.js&#x27;).then(function (registration) &#123;</span><br><span class="line">          return registration.pushManager.getSubscription()                            </span><br><span class="line">            .then(function (subscription) &#123;</span><br><span class="line">              if (subscription) &#123;                                                      </span><br><span class="line">                return;</span><br><span class="line">              &#125;</span><br><span class="line">              return registration.pushManager.subscribe(&#123;                              </span><br><span class="line">                  userVisibleOnly: true,</span><br><span class="line">                  applicationServerKey: urlBase64ToUint8Array(vapidPublicKey)</span><br><span class="line">                &#125;)</span><br><span class="line">                .then(function (subscription) &#123;</span><br><span class="line">                  var rawKey = subscription.getKey ? subscription.getKey(&#x27;p256dh&#x27;) : &#x27;&#x27;;</span><br><span class="line">                  key = rawKey ? btoa(String.fromCharCode.apply(null, new Uint8Array(rawKey))) : &#x27;&#x27;;</span><br><span class="line">                  var rawAuthSecret = subscription.getKey ? subscription.getKey(&#x27;auth&#x27;) : &#x27;&#x27;;</span><br><span class="line">                  authSecret = rawAuthSecret ?</span><br><span class="line">                    btoa(String.fromCharCode.apply(null, new Uint8Array(rawAuthSecret))) : &#x27;&#x27;;</span><br><span class="line">                  endpoint = subscription.endpoint;</span><br><span class="line">                  return fetch(&#x27;./register&#x27;, &#123;                                         </span><br><span class="line">                    method: &#x27;post&#x27;,</span><br><span class="line">                    headers: new Headers(&#123;</span><br><span class="line">                      &#x27;content-type&#x27;: &#x27;application/json&#x27;</span><br><span class="line">                    &#125;),</span><br><span class="line">                    body: JSON.stringify(&#123;</span><br><span class="line">                      endpoint: subscription.endpoint,</span><br><span class="line">                      key: key,</span><br><span class="line">                      authSecret: authSecret,</span><br><span class="line">                    &#125;),</span><br><span class="line">                  &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;).catch(function (err) &#123;</span><br><span class="line">          // 注册失败 :(</span><br><span class="line">          console.log(&#x27;ServiceWorker registration failed: &#x27;, err);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>步骤三 服务器发送消息给service worker</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// app.js</span><br><span class="line"></span><br><span class="line">const webpush = require(&#x27;web-push&#x27;);                 </span><br><span class="line">const express = require(&#x27;express&#x27;);</span><br><span class="line">var bodyParser = require(&#x27;body-parser&#x27;);</span><br><span class="line">const app = express();</span><br><span class="line">webpush.setVapidDetails(                             </span><br><span class="line">  &#x27;mailto:contact@deanhume.com&#x27;,</span><br><span class="line">  &#x27;BAyb_WgaR0L0pODaR7wWkxJi__tWbM1MPBymyRDFEGjtDCWeRYS9EF7yGoCHLdHJi6hikYdg4MuYaK0XoD0qnoY&#x27;,</span><br><span class="line">  &#x27;p6YVD7t8HkABoez1CvVJ5bl7BnEdKUu5bSyVjyxMBh0&#x27;</span><br><span class="line">);</span><br><span class="line">app.post(&#x27;/register&#x27;, function (req, res) &#123;           </span><br><span class="line">  var endpoint = req.body.endpoint;</span><br><span class="line">  saveRegistrationDetails(endpoint, key, authSecret); </span><br><span class="line">  const pushSubscription = &#123;                          </span><br><span class="line">    endpoint: req.body.endpoint,</span><br><span class="line">    keys: &#123;</span><br><span class="line">      auth: req.body.authSecret,</span><br><span class="line">      p256dh: req.body.key</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  var body = &#x27;Thank you for registering&#x27;;</span><br><span class="line">  var iconUrl = &#x27;https://example.com/images/homescreen.png&#x27;;</span><br><span class="line">  // 发送 Web 推送消息</span><br><span class="line">  webpush.sendNotification(pushSubscription,          </span><br><span class="line">      JSON.stringify(&#123;</span><br><span class="line">        msg: body,</span><br><span class="line">        url: &#x27;http://localhost:3111/&#x27;,</span><br><span class="line">        icon: iconUrl</span><br><span class="line">      &#125;))</span><br><span class="line">    .then(result =&gt; res.sendStatus(201))</span><br><span class="line">    .catch(err =&gt; &#123;</span><br><span class="line">      console.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(3111, function () &#123;</span><br><span class="line">  console.log(&#x27;Web push app listening on port 3111!&#x27;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>service worker</code>监听push事件，将通知详情推送给用户</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// service-worker.js</span><br><span class="line"></span><br><span class="line">self.addEventListener(&#x27;push&#x27;, function (event) &#123;</span><br><span class="line"> // 检查服务端是否发来了任何有效载荷数据</span><br><span class="line">  var payload = event.data ? JSON.parse(event.data.text()) : &#x27;no payload&#x27;;</span><br><span class="line">  var title = &#x27;Progressive Times&#x27;;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    // 使用提供的信息来显示 Web 推送通知</span><br><span class="line">    self.registration.showNotification(title, &#123;                           </span><br><span class="line">      body: payload.msg,</span><br><span class="line">      url: payload.url,</span><br><span class="line">      icon: payload.icon</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://lzw.me/a/pwa-service-worker.html#3.3">网站渐进式增强体验(PWA)改造：Service Worker 应用详解</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/SangKa/PWA-Book-CN">PWA实战：面向下一代的Progressive Web APP</a></li>
<li><a target="_blank" rel="noopener" href="https://x5.tencent.com/tbs/guide/serviceworker.html">Service Worker最佳实践</a></li>
<li><a target="_blank" rel="noopener" href="https://fed.renren.com/2017/10/04/service-worker/">使用 Service Worker 做一个 PWA 离线网页应用</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28461857">理解Service Worker</a></li>
<li><a target="_blank" rel="noopener" href="http://obkoro1.com/web_accumulate/accumulate/JS/webWorker%E4%B8%8A%E6%89%8B.html">前端er来学习一下 WebWorker</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5bf3f656e51d45338e084044?utm_source=gold_browser_extension">Service Worker学习与实践（二）——PWA简介</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5bf3f6b2e51d45360069e527?utm_source=gold_browser_extension">Service Worker学习与实践（三）——消息推送</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/nicejade/nice-front-end-tutorial/blob/master/tutorial/pwa-tutorial.md">pwa-tutoria</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-浏览器/浏览器组成与架构" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/05/27/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%84%E6%88%90%E4%B8%8E%E6%9E%B6%E6%9E%84/" class="article-date">
  	<time datetime="2021-05-27T07:31:26.000Z" itemprop="datePublished">2021-05-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/27/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%84%E6%88%90%E4%B8%8E%E6%9E%B6%E6%9E%84/">
        浏览器组成与架构
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><p>​        浏览器由shell（用户界面、网络、UI后端、JavaScript解释器、XML解析器、数据存储）和内核（浏览器引擎、渲染引擎）组成，内核是浏览器的核心。不同的浏览器有不同的内核，ie 浏览器是 Trident，Firefox 浏览器是 Geoko（Mozilla自主研发的渲染引擎），Safari 和 Chrome 使用的是 webkit （后来 Chrome 推出了 Blink）。</p>
<h2 id="用户界面（User-Interface）"><a href="#用户界面（User-Interface）" class="headerlink" title="用户界面（User Interface）"></a>用户界面（User Interface）</h2><pre><code>    用户界面主要包括工具栏、地址栏、前进/后退按钮、书签菜单、可视化页面加载进度、智能下载处理、首选项、打印等。除了浏览器主窗口显示请求的页面之外，其他显示的部分都属于用户界面。

    用户界面还可以与桌面环境集成，以提供浏览器会话管理或与其他桌面应用程序的通信。
</code></pre>
<h2 id="网络（Networking）"><a href="#网络（Networking）" class="headerlink" title="网络（Networking）"></a>网络（Networking）</h2><pre><code>    网络系统实现HTTP和FTP等文件传输协议。 网络系统可以在不同的字符集之间进行转换，为文件解析MIME媒体类型。 网络系统可以实现最近检索资源的缓存功能。
</code></pre>
<h2 id="UI后端（Display-Backend）"><a href="#UI后端（Display-Backend）" class="headerlink" title="UI后端（Display Backend）"></a>UI后端（Display Backend）</h2><pre><code>    UI后端提供绘图和窗口原语，包括：用户界面控件集合、字体集合。
</code></pre>
<h2 id="JavaScript解释器（JavaScript-Interpreter）"><a href="#JavaScript解释器（JavaScript-Interpreter）" class="headerlink" title="JavaScript解释器（JavaScript Interpreter）"></a>JavaScript解释器（JavaScript Interpreter）</h2><pre><code>    JavaScript解释器能够解释并执行嵌入在网页中的JavaScript（又称ECMAScript）代码。 为了安全起见，浏览器引擎或渲染引擎可能会禁用某些JavaScript功能，如弹出窗口的打开。
</code></pre>
<h2 id="XML解析器（XML-Parser）"><a href="#XML解析器（XML-Parser）" class="headerlink" title="XML解析器（XML Parser）"></a>XML解析器（XML Parser）</h2><pre><code>    XML解析器可以将XML文档解析成文档对象模型（Document Object Model，DOM）树。 XML解析器是浏览器架构中复用最多的子系统之一，几乎所有的浏览器实现都利用现有的XML解析器，而不是从头开始创建自己的XML解析器。
</code></pre>
<h2 id="数据存储（Data-Persistence）"><a href="#数据存储（Data-Persistence）" class="headerlink" title="数据存储（Data Persistence）"></a>数据存储（Data Persistence）</h2><pre><code>    数据存储将与浏览会话相关联的各种数据存储在硬盘上。 这些数据可能是诸如：书签、工具栏设置等这样的高级数据，也可能是诸如：Cookie，安全证书、缓存等这样的低级数据。
</code></pre>
<h2 id="浏览器引擎（Browser-Engine）"><a href="#浏览器引擎（Browser-Engine）" class="headerlink" title="浏览器引擎（Browser Engine）"></a>浏览器引擎（Browser Engine）</h2><pre><code>    浏览器引擎是一个可嵌入的组件，其为渲染引擎提供高级接口。浏览器引擎可以加载一个给定的URI，并支持诸如：前进/后退/重新加载等浏览操作。浏览器引擎提供查看浏览会话的各个方面的挂钩，例如：当前页面加载进度、JavaScript alert。浏览器引擎还允许查询/修改渲染引擎设置。
</code></pre>
<h2 id="渲染引擎（Rendering-Engine-或-layout-engineer）"><a href="#渲染引擎（Rendering-Engine-或-layout-engineer）" class="headerlink" title="渲染引擎（Rendering Engine 或 layout engineer）"></a>渲染引擎（Rendering Engine 或 layout engineer）</h2><pre><code>    渲染引擎负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。渲染引擎能够显示HTML和XML文档，可选择CSS样式，以及嵌入式内容（如图片）。渲染引擎能够准确计算页面布局，可使用“回流”算法逐步调整页面元素的位置。渲染引擎内部包含HTML解析器。
</code></pre>
<h1 id="软件构造"><a href="#软件构造" class="headerlink" title="软件构造"></a>软件构造</h1><p>​        不同的浏览器软件架构也不一样，好的软件都是支持多进程和多线程，进程与进程相互独立，不同的进程之间通过IPC（Inter Process Communication）进行通信。</p>
<pre><code>    以 Chrome 浏览器为例，它的架构模式由浏览器进程（Browser Process）、渲染进程（Renderer Process）、插件进程（Plugin Process）、GPU进程（GPU Process）、网络进程（NetWork Process）和其他进程组成，每个进程都有自己核心的职责，它们相互配合完成浏览器的整体功能，每个进程中又包含多个线程，一个进程内的多个线程也会协同工作，配合完成所在进程的职责。和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个渲染引擎实例。每个标签页都是一个独立的进程，当标签页的数量足够多时（40个页面以上），会与之前的标签页共用同一个进程。
</code></pre>
<h2 id="浏览器进程（Browser-Process）"><a href="#浏览器进程（Browser-Process）" class="headerlink" title="浏览器进程（Browser Process）"></a>浏览器进程（Browser Process）</h2><pre><code>    主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。控制应用程序的 chrome 部分，包括地址栏、书签、后退和前进等按钮，还处理Web浏览器的隐形、底层操作，例如网络请求和文件访问。 
</code></pre>
<h2 id="渲染进程（Renderer-Process）"><a href="#渲染进程（Renderer-Process）" class="headerlink" title="渲染进程（Renderer Process）"></a>渲染进程（Renderer Process）</h2><pre><code>    核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，渲染引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。
</code></pre>
<h2 id="GPU-进程（GPU-Process）"><a href="#GPU-进程（GPU-Process）" class="headerlink" title="GPU 进程（GPU Process）"></a>GPU 进程（GPU Process）</h2><pre><code>    GPU 进程的使用初衷是为了实现 3D CSS 的效果，随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制。
</code></pre>
<h2 id="网络进程（NetWork-Process）"><a href="#网络进程（NetWork-Process）" class="headerlink" title="网络进程（NetWork Process）"></a>网络进程（NetWork Process）</h2><pre><code>    主要负责页面的网络资源加载。
</code></pre>
<h2 id="插件进程（Plugin-Process）"><a href="#插件进程（Plugin-Process）" class="headerlink" title="插件进程（Plugin Process）"></a>插件进程（Plugin Process）</h2><pre><code>    主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。
</code></pre>
<h2 id="utility进程（Utility-Process）"><a href="#utility进程（Utility-Process）" class="headerlink" title="utility进程（Utility Process）"></a>utility进程（Utility Process）</h2><pre><code>    有时候浏览器主进程需要做一些“危险”的事情，比如图片解码、文件解压缩。如果这些“危险”的操作发生了失败，会导致整个主进程发生异常崩溃，这是我们不愿意看到的。因此Chromium设计出了一个utility进程的机制。主进程临时需要做一些不方便的任务的情况下，可以启动一个utility进程来代替主进程执行，主进程与utility进程之间通过IPC消息来通信。
</code></pre>
<h2 id="其他进程"><a href="#其他进程" class="headerlink" title="其他进程"></a>其他进程</h2><pre><code>    UI进程、存储进程、备进程、Audio进程、Video进程、Profile进程等等。
</code></pre>
<p>面向服务架构<br>        面向服务架构（Services Oriented Architecture，简称 SOA），后端技术开发中比较火热的微服务架构就是 SOA 的一种变体，Chrome 官方团队将原来的各种模块重构成独立的服务（Service），访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，每个服务（Service）都可以在独立的进程中运行，并且可以轻松拆分为不同的进程或聚合为一个进程。当Chrome在功能强大的硬件上运行时，它可能会将每个服务拆分为不同的进程以提供更高的稳定性，但是如果是在资源受限的设备上，Chrome 会将服务整合到一个进程中以节省内存。</p>
<pre><code>    在最新的 Chrome 浏览器中，可以在设置中打开更多工具，找到任务管理器并打开。



     可以看到有部分的 Chrome Service 与进程同时在运行，Chrome 仍在努力的完善面向服务架构。
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-html+css+js+ts/await 在 forEach 中不生效解决方案" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/05/24/html+css+js+ts/await%20%E5%9C%A8%20forEach%20%E4%B8%AD%E4%B8%8D%E7%94%9F%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="article-date">
  	<time datetime="2021-05-24T06:46:21.000Z" itemprop="datePublished">2021-05-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/24/html+css+js+ts/await%20%E5%9C%A8%20forEach%20%E4%B8%AD%E4%B8%8D%E7%94%9F%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">
        await 在 forEach 中不生效解决方案
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、场景"><a href="#一、场景" class="headerlink" title="一、场景"></a>一、场景</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">	let arr = [3, 2, 1]</span><br><span class="line">	arr.forEach(async item =&gt; &#123;</span><br><span class="line">		const res = await fetch(item)</span><br><span class="line">		console.log(res)</span><br><span class="line">	&#125;)</span><br><span class="line">	console.log(&#x27;end&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fetch(x) &#123;</span><br><span class="line">	return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">		setTimeout(() =&gt; &#123;</span><br><span class="line">			resolve(x)</span><br><span class="line">		&#125;, 500 * x)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<p>期望的打印顺序是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>结果打印顺序居然是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">end</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong></p>
<blockquote>
<p>那就是 <code>forEach</code> 只支持同步代码。<code>forEach</code> 并不会去处理异步的情况</p>
</blockquote>
<h2 id="二、解决办法"><a href="#二、解决办法" class="headerlink" title="二、解决办法"></a>二、解决办法</h2><h3 id="2-1-第一种是使用-Promise-all-的方式"><a href="#2-1-第一种是使用-Promise-all-的方式" class="headerlink" title="2.1 第一种是使用 Promise.all 的方式"></a>2.1 第一种是使用 Promise.all 的方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function test() &#123;</span><br><span class="line">	let arr = [3, 2, 1]</span><br><span class="line">	await Promise.all(</span><br><span class="line">		arr.map(async item =&gt; &#123;</span><br><span class="line">			const res = await fetch(item)</span><br><span class="line">			console.log(res)</span><br><span class="line">		&#125;)</span><br><span class="line">	)</span><br><span class="line">	console.log(&#x27;end&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样可以生效的原因是 <code>async</code> 函数肯定会返回一个 <code>Promise</code> 对象，调用 <code>map</code> 以后返回值就是一个存放了 <code>Promise</code> 的数组了，这样我们把数组传入 <code>Promise.all</code> 中就可以解决问题了。但是这种方式其实并不能达成我们要的效果，如果你希望内部的 <code>fetch</code> 是顺序完成的，可以选择第二种方式</p>
</blockquote>
<h3 id="2-2-另一种方法是使用-for…of"><a href="#2-2-另一种方法是使用-for…of" class="headerlink" title="2.2 另一种方法是使用 for…of"></a>2.2 另一种方法是使用 for…of</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function test() &#123;</span><br><span class="line">	let arr = [3, 2, 1]</span><br><span class="line">	for (const item of arr) &#123;</span><br><span class="line">		const res = await fetch(item)</span><br><span class="line">		console.log(res)</span><br><span class="line">	&#125;</span><br><span class="line">	console.log(&#x27;end&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这种方式相比 <code>Promise.all</code> 要简洁的多，并且也可以实现开头我想要的输出顺序。</li>
<li>但是这时候你是否又多了一个疑问？为啥 <code>for...of</code> 内部就能让 <code>await</code> 生效呢。</li>
<li>因为 <code>for...of</code> 内部处理的机制和 f<code>orEach</code> 不同，<code>forEach</code> 是直接调用回调函数，<code>for...of</code> 是通过迭代器的方式去遍历。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async function test() &#123;</span><br><span class="line">	let arr = [3, 2, 1]</span><br><span class="line">	const iterator = arr[Symbol.iterator]()</span><br><span class="line">	let res = iterator.next()</span><br><span class="line">	while (!res.done) &#123;</span><br><span class="line">		const value = res.value</span><br><span class="line">		const res1 = await fetch(value)</span><br><span class="line">		console.log(res1)</span><br><span class="line">		res = iterator.next()</span><br><span class="line">	&#125;</span><br><span class="line">	console.log(&#x27;end&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码等价于 <code>for...of</code>，可以看成 <code>for...of</code> 是以上代码的语法糖</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/async-await/" rel="tag">async&#x2F;await</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/%E9%97%AE%E9%A2%98/">问题</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-浏览器/浏览器渲染原理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/05/19/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/" class="article-date">
  	<time datetime="2021-05-19T06:18:26.000Z" itemprop="datePublished">2021-05-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/19/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/">
        浏览器渲染原理
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、浏览器如何渲染网页"><a href="#一、浏览器如何渲染网页" class="headerlink" title="一、浏览器如何渲染网页"></a>一、浏览器如何渲染网页</h2><p><strong>概述：浏览器渲染一共有五步</strong></p>
<ol>
<li>处理 <code>HTML</code> 并构建 <code>DOM</code> 树。</li>
<li>处理 <code>CSS</code>构建 <code>CSSOM</code> 树。</li>
<li>将 <code>DOM</code> 与 <code>CSSOM</code> 合并成一个渲染树。</li>
<li>根据渲染树来布局，计算每个节点的位置。</li>
<li>调用 <code>GPU</code> 绘制，合成图层，显示在屏幕上</li>
</ol>
<blockquote>
<p>第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染</p>
</blockquote>
<p>具体如下图过程如下图所示</p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/19.png" alt="img"></p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/20.png" alt="img"></p>
<p><strong>渲染</strong></p>
<ul>
<li>网页生成的时候，至少会渲染一次</li>
<li>在用户访问的过程中，还会不断重新渲染</li>
</ul>
<blockquote>
<p>重新渲染需要重复之前的第四步(重新生成布局)+第五步(重新绘制)或者只有第五个步(重新绘制)</p>
</blockquote>
<ul>
<li>在构建 <code>CSSOM</code> 树时，会阻塞渲染，直至 <code>CSSOM</code>树构建完成。并且构建 <code>CSSOM</code> 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 <code>CSS</code> 选择器，执行速度越慢</li>
<li>当 <code>HTML</code> 解析到 <code>script</code> 标签时，会暂停构建 <code>DOM</code>，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 <code>JS</code> 文件。并且<code>CSS</code>也会影响 <code>JS</code> 的执行，只有当解析完样式表才会执行 <code>JS</code>，所以也可以认为这种情况下，<code>CSS</code> 也会暂停构建 <code>DOM</code></li>
</ul>
<h2 id="二、浏览器渲染五个阶段"><a href="#二、浏览器渲染五个阶段" class="headerlink" title="二、浏览器渲染五个阶段"></a>二、浏览器渲染五个阶段</h2><h3 id="2-1-第一步：解析HTML标签，构建DOM树"><a href="#2-1-第一步：解析HTML标签，构建DOM树" class="headerlink" title="2.1 第一步：解析HTML标签，构建DOM树"></a>2.1 第一步：解析HTML标签，构建DOM树</h3><blockquote>
<p>在这个阶段，引擎开始解析<code>html</code>，解析出来的结果会成为一棵<code>dom</code>树<br><code>dom</code>的目的至少有<code>2</code>个</p>
</blockquote>
<ul>
<li>作为下个阶段渲染树状图的输入</li>
<li>成为网页和脚本的交互界面。(最常用的就是<code>getElementById</code>等等)</li>
</ul>
<p><strong>当解析器到达script标签的时候，发生下面四件事情</strong></p>
<ol>
<li><code>html</code>解析器停止解析,</li>
<li>如果是外部脚本，就从外部网络获取脚本代码</li>
<li>将控制权交给<code>js</code>引擎，执行<code>js</code>代码</li>
<li>恢复<code>html</code>解析器的控制权</li>
</ol>
<blockquote>
<p>由此可以得到第一个结论1</p>
</blockquote>
<ul>
<li>由于&#96;&#96;标签是阻塞解析的，将脚本放在网页尾部会加速代码渲染。</li>
<li><code>defer</code>和<code>async</code>属性也能有助于加载外部脚本。</li>
<li><code>defer</code>使得脚本会在<code>dom</code>完整构建之后执行；</li>
<li><code>async</code>标签使得脚本只有在完全<code>available</code>才执行，并且是以非阻塞的方式进行的</li>
</ul>
<h3 id="2-2-第二步：解析CSS标签，构建CSSOM树"><a href="#2-2-第二步：解析CSS标签，构建CSSOM树" class="headerlink" title="2.2 第二步：解析CSS标签，构建CSSOM树"></a>2.2 第二步：解析CSS标签，构建CSSOM树</h3><ul>
<li>我们已经看到<code>html</code>解析器碰到脚本后会做的事情，接下来我们看下<code>html</code>解析器碰到样式表会发生的情况</li>
<li><code>js</code>会阻塞解析，因为它会修改文档(<code>document</code>)。<code>css</code>不会修改文档的结构，如果这样的话，似乎看起来<code>css</code>样式不会阻塞浏览器<code>html</code>解析。但是事实上 <code>css</code>样式表是阻塞的。阻塞是指当<code>cssom</code>树建立好之后才会进行下一步的解析渲染</li>
</ul>
<p><strong>通过以下手段可以减轻cssom带来的影响</strong></p>
<ul>
<li>将<code>script</code>脚本放在页面底部</li>
<li>尽可能快的加载<code>css</code>样式表</li>
<li>将样式表按照<code>media type</code>和<code>media query</code>区分，这样有助于我们将<code>css</code>资源标记成非阻塞渲染的资源。</li>
<li>非阻塞的资源还是会被浏览器下载，只是优先级较低</li>
</ul>
<h3 id="2-3-第三步：把DOM和CSSOM组合成渲染树（render-tree）"><a href="#2-3-第三步：把DOM和CSSOM组合成渲染树（render-tree）" class="headerlink" title="2.3 第三步：把DOM和CSSOM组合成渲染树（render tree）"></a>2.3 第三步：把DOM和CSSOM组合成渲染树（render tree）</h3><p><img src="https://poetries1.gitee.io/img-repo/2019/10/21.png" alt="img"></p>
<h3 id="2-4-第四步：在渲染树的基础上进行布局，计算每个节点的几何结构"><a href="#2-4-第四步：在渲染树的基础上进行布局，计算每个节点的几何结构" class="headerlink" title="2.4 第四步：在渲染树的基础上进行布局，计算每个节点的几何结构"></a>2.4 第四步：在渲染树的基础上进行布局，计算每个节点的几何结构</h3><blockquote>
<p>布局(<code>layout</code>)：定位坐标和大小，是否换行，各种<code>position</code>, <code>overflow</code>, <code>z-index</code>属性</p>
</blockquote>
<h3 id="2-5-调用-GPU-绘制，合成图层，显示在屏幕上"><a href="#2-5-调用-GPU-绘制，合成图层，显示在屏幕上" class="headerlink" title="2.5 调用 GPU 绘制，合成图层，显示在屏幕上"></a>2.5 调用 GPU 绘制，合成图层，显示在屏幕上</h3><blockquote>
<p>将渲染树的各个节点绘制到屏幕上，这一步被称为绘制<code>painting</code></p>
</blockquote>
<h2 id="三、渲染优化相关"><a href="#三、渲染优化相关" class="headerlink" title="三、渲染优化相关"></a>三、渲染优化相关</h2><h3 id="3-1-Load-和-DOMContentLoaded-区别"><a href="#3-1-Load-和-DOMContentLoaded-区别" class="headerlink" title="3.1 Load 和 DOMContentLoaded 区别"></a>3.1 Load 和 DOMContentLoaded 区别</h3><ul>
<li><code>Load</code> 事件触发代表页面中的 <code>DOM</code>，<code>CSS</code>，<code>JS</code>，图片已经全部加载完毕。</li>
<li><code>DOMContentLoaded</code> 事件触发代表初始的 <code>HTML</code> 被完全加载和解析，不需要等待 <code>CSS</code>，<code>JS</code>，图片加载</li>
</ul>
<h3 id="3-2-图层"><a href="#3-2-图层" class="headerlink" title="3.2 图层"></a>3.2 图层</h3><blockquote>
<p>一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。</p>
</blockquote>
<p><strong>通过以下几个常用属性可以生成新图层</strong></p>
<ul>
<li><code>3D</code> 变换：<code>translate3d</code>、<code>translateZ</code></li>
<li><code>will-change</code></li>
<li><code>video</code>、<code>iframe</code> 标签</li>
<li>通过动画实现的 <code>opacity</code> 动画转换</li>
<li><code>position: fixed</code></li>
</ul>
<h3 id="3-3-重绘（Repaint）和回流（Reflow）"><a href="#3-3-重绘（Repaint）和回流（Reflow）" class="headerlink" title="3.3 重绘（Repaint）和回流（Reflow）"></a>3.3 重绘（Repaint）和回流（Reflow）</h3><blockquote>
<p>重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大</p>
</blockquote>
<ul>
<li>重绘是当节点需要更改外观而不会影响布局的，比如改变 <code>color</code> 就叫称为重绘</li>
<li>回流是布局或者几何属性需要改变就称为回流。</li>
</ul>
<blockquote>
<p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流</p>
</blockquote>
<p><strong>以下几个动作可能会导致性能问题</strong></p>
<ul>
<li>改变 <code>window</code> 大小</li>
<li>改变字体</li>
<li>添加或删除样式</li>
<li>文字改变</li>
<li>定位或者浮动</li>
<li>盒模型</li>
</ul>
<p><strong>很多人不知道的是，重绘和回流其实和 Event loop 有关</strong></p>
<ul>
<li>当 <code>Event loop</code> 执行完<code>Microtasks</code> 后，会判断 <code>document</code> 是否需要更新。因为浏览器是 <code>60Hz</code> 的刷新率，每 <code>16ms</code> 才会更新一次。</li>
<li>然后判断是否有 <code>resize</code> 或者 <code>scroll</code> ，有的话会去触发事件，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 <code>16ms</code>才会触发一次，并且自带节流功能。</li>
<li>判断是否触发了 <code>media query</code></li>
<li>更新动画并且发送事件</li>
<li>判断是否有全屏操作事件</li>
<li>执行 <code>requestAnimationFrame</code> 回调</li>
<li>执行 <code>IntersectionObserver</code> 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好</li>
<li>更新界面</li>
<li>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 <code>requestIdleCallback</code> 回调</li>
</ul>
<p><strong>常见的引起重绘的属性</strong></p>
<ul>
<li><code>color</code></li>
<li><code>border-style</code></li>
<li><code>visibility</code></li>
<li><code>background</code></li>
<li><code>text-decoration</code></li>
<li><code>background-image</code></li>
<li><code>background-position</code></li>
<li><code>background-repeat</code></li>
<li><code>outline-color</code></li>
<li><code>outline</code></li>
<li><code>outline-style</code></li>
<li><code>border-radius</code></li>
<li><code>outline-width</code></li>
<li><code>box-shadow</code></li>
<li><code>background-size</code></li>
</ul>
<h3 id="3-4-常见引起回流属性和方法"><a href="#3-4-常见引起回流属性和方法" class="headerlink" title="3.4 常见引起回流属性和方法"></a>3.4 常见引起回流属性和方法</h3><blockquote>
<p>任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发重排，下面列一些栗子</p>
</blockquote>
<ul>
<li>添加或者删除可见的<code>DOM</code>元素；</li>
<li>元素尺寸改变——边距、填充、边框、宽度和高度</li>
<li>内容变化，比如用户在<code>input</code>框中输入文字</li>
<li>浏览器窗口尺寸改变——<code>resize</code>事件发生时</li>
<li>计算 <code>offsetWidth</code> 和 <code>offsetHeight</code> 属性</li>
<li>设置 <code>style</code> 属性的值</li>
</ul>
<p><strong>回流影响的范围</strong></p>
<blockquote>
<p>由于浏览器渲染界面是基于流失布局模型的，所以触发重排时会对周围DOM重新排列，影响的范围有两种</p>
</blockquote>
<ul>
<li>全局范围：从根节点<code>html</code>开始对整个渲染树进行重新布局。</li>
<li>局部范围：对渲染树的某部分或某一个渲染对象进行重新布局</li>
</ul>
<p><strong>全局范围回流</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;h4&gt;hello&lt;/h4&gt;</span><br><span class="line">    &lt;p&gt;&lt;strong&gt;Name:&lt;/strong&gt;BDing&lt;/p&gt;</span><br><span class="line">    &lt;h5&gt;male&lt;/h5&gt;</span><br><span class="line">    &lt;ol&gt;</span><br><span class="line">      &lt;li&gt;coding&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;loving&lt;/li&gt;</span><br><span class="line">    &lt;/ol&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当<code>p</code>节点上发生<code>reflow</code>时，<code>hello</code>和<code>body</code>也会重新渲染，甚至<code>h5</code>和<code>ol</code>都会收到影响</p>
</blockquote>
<p><strong>局部范围回流</strong></p>
<blockquote>
<p>用局部布局来解释这种现象：把一个<code>dom</code>的宽高之类的几何信息定死，然后在<code>dom</code>内部触发重排，就只会重新渲染该<code>dom</code>内部的元素，而不会影响到外界</p>
</blockquote>
<h3 id="3-5-减少重绘和回流"><a href="#3-5-减少重绘和回流" class="headerlink" title="3.5 减少重绘和回流"></a>3.5 减少重绘和回流</h3><blockquote>
<p>使用 <code>translate</code> 替代 <code>top</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;test&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .test &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 10px;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background: red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        // 引起回流</span><br><span class="line">        document.querySelector(&#x27;.test&#x27;).style.top = &#x27;100px&#x27;</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>visibility</code> 替换 <code>display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li>
<li>把 <code>DOM</code> 离线后修改，比如：先把 <code>DOM</code> 给 <code>display:none</code> (有一次 <code>Reflow)</code>，然后你修改<code>100</code>次，然后再把它显示出来</li>
<li>不要把 <code>DOM</code> 结点的属性值放在一个循环里当成循环里的变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">    // 获取 offsetTop 会导致回流，因为需要去获取正确的值</span><br><span class="line">    console.log(document.querySelector(&#x27;.test&#x27;).style.offsetTop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局</li>
<li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></li>
<li><code>CSS</code>选择符从右往左匹配查找，避免 <code>DOM</code>深度过深</li>
<li>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 <code>video</code>标签，浏览器会自动将该节点变为图层。</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/22.png" alt="img"></p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/23.png" alt="img"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://blog.poetries.top/2018/01/12/fed-performance-optimization/#%E5%85%AD%E3%80%81%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81">重绘与回流</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-浏览器/浏览器缓存原理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/05/07/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/" class="article-date">
  	<time datetime="2021-05-07T01:33:18.000Z" itemprop="datePublished">2021-05-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/07/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/">
        浏览器缓存原理
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、浏览器缓存基本认识"><a href="#一、浏览器缓存基本认识" class="headerlink" title="一、浏览器缓存基本认识"></a>一、浏览器缓存基本认识</h1><p><strong>分为强缓存和协商缓存</strong></p>
<ol>
<li>浏览器在加载资源时，先根据这个资源的一些<code>http header</code>判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个<code>css</code>文件，如果浏览器在加载它所在的网页时，这个<code>css</code>文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个<code>css</code>，连请求都不会发送到网页所在服务器</li>
<li>当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些<code>http header</code>验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源</li>
<li><strong>强缓存与协商缓存的共同点是</strong>：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：<strong>强缓存不发请求到服务器</strong>，协商缓存会发请求到服务器</li>
<li>当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据</li>
</ol>
<h1 id="二、强缓存的原理"><a href="#二、强缓存的原理" class="headerlink" title="二、强缓存的原理"></a>二、强缓存的原理</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><blockquote>
<p>当浏览器对某个资源的请求命中了强缓存时，返回的<code>http</code>状态为<code>200</code>，在<code>chrome</code>的开发者工具的<code>network</code>里面<code>size</code>会显示为<code>from cache</code>，比如京东的首页里就有很多静态资源配置了强缓存，用<code>chrome</code>打开几次，再用<code>f12</code>查看<code>network</code>，可以看到有不少请求就是从缓存中加载的</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/1.png" alt="img"></p>
<ul>
<li>强缓存是利用<code>Expires</code>或者<code>Cache-Control</code>这两个<code>http response header</code>实现的，它们都用来表示资源在客户端缓存的有效期。</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires`是`http1.0`提出的一个表示资源过期时间的`header`，它描述的是一个绝对时间，由服务器返回，用`GMT`格式的字符串表示，如：`Expires:Thu, 31 Dec 2037 23:55:55 GMT</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="2-2-Expires缓存原理"><a href="#2-2-Expires缓存原理" class="headerlink" title="2.2 Expires缓存原理"></a>2.2 Expires缓存原理</h2><ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在<code>respone</code>的<code>header</code>加上<code>Expires</code>，如</li>
</ol>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/2.png" alt="img"></p>
<ol>
<li>浏览器在接收到这个资源后，会把这个资源连同所有<code>response header</code>一起缓存下来（所以缓存命中的请求返回的<code>header</code>并不是来自服务器，而是来自之前缓存的<code>header</code>）</li>
<li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的<code>Expires</code>跟当前的请求时间比较，如果请求时间在<code>Expires</code>指定的时间之前，就能命中缓存，否则就不行</li>
<li>如果缓存没有命中，浏览器直接从服务器加载资源时，<code>Expires Header</code>在重新加载的时候会被更新</li>
</ol>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires`是较老的强缓存管理`header`，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在`http1.1`的时候，提出了一个新的`header`，就是`Cache-Control`，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：`Cache-Control:max-age=315360000</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="2-3-Cache-Control缓存原理"><a href="#2-3-Cache-Control缓存原理" class="headerlink" title="2.3 Cache-Control缓存原理"></a>2.3 Cache-Control缓存原理</h2><ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在<code>respone</code>的<code>header</code>加上<code>Cache-Control</code>，如：</li>
</ol>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/3.png" alt="img"></p>
<ol>
<li>浏览器在接收到这个资源后，会把这个资源连同所有<code>response header</code>一起缓存下来</li>
<li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和<code>Cache-Control</code>设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行</li>
<li>如果缓存没有命中，浏览器直接从服务器加载资源时，<code>Cache-Control Header</code>在重新加载的时候会被更新</li>
</ol>
<ul>
<li><code>Cache-Control</code>描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较<code>Expires</code>，<code>Cache-Control</code>的缓存管理更有效，安全一些。</li>
<li>这两个<code>header</code>可以只启用一个，也可以同时启用，当<code>response header</code>中，<code>Expires</code>和<code>Cache-Control</code>同时存在时，<code>Cache-Control</code>优先级高于<code>Expires</code>：</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/4.png" alt="img"></p>
<h1 id="三、强缓存的管理"><a href="#三、强缓存的管理" class="headerlink" title="三、强缓存的管理"></a>三、强缓存的管理</h1><blockquote>
<p>前面介绍的是强缓存的原理，在实际应用中我们会碰到需要强缓存的场景和不需要强缓存的场景，通常有2种方式来设置是否启用强缓存</p>
</blockquote>
<ol>
<li>通过代码的方式，在<code>web</code>服务器返回的响应中添加<code>Expires</code>和<code>Cache-Control Header</code></li>
<li>通过配置<code>web</code>服务器的方式，让<code>web</code>服务器在响应资源的时候统一添加<code>Expires</code>和<code>Cache-Control Header</code></li>
</ol>
<blockquote>
<p>比如在javaweb里面，我们可以使用类似下面的代码设置强缓存</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.util.Date date = new java.util.Date();    </span><br><span class="line">response.setDateHeader(&quot;Expires&quot;,date.getTime()+20000); //Expires:过时期限值 </span><br><span class="line">response.setHeader(&quot;Cache-Control&quot;, &quot;public&quot;); //Cache-Control来控制页面的缓存与否,public:浏览器和缓存服务器都可以缓存页面信息；</span><br><span class="line">response.setHeader(&quot;Pragma&quot;, &quot;Pragma&quot;); //Pragma:设置页面是否缓存，为Pragma则缓存，no-cache则不缓存</span><br></pre></td></tr></table></figure>

<blockquote>
<p>还可以通过类似下面的<code>java</code>代码设置不启用强缓存</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader( &quot;Pragma&quot;, &quot;no-cache&quot; );   </span><br><span class="line">response.setDateHeader(&quot;Expires&quot;, 0);   </span><br><span class="line">response.addHeader( &quot;Cache-Control&quot;, &quot;no-cache&quot; );//浏览器和缓存服务器都不应该缓存页面信息</span><br></pre></td></tr></table></figure>

<ul>
<li><code>nginx</code>和<code>apache</code>作为专业的<code>web</code>服务器，都有专门的配置文件，可以配置<code>expires</code>和<code>cache-control</code>，这方面的知识，如果你对运维感兴趣的话，可以在百度上搜索<code>nginx</code> 设置 <code>expires cache-control</code>或 <code>apache 设置 expires cache-control</code> 都能找到不少相关的文章。</li>
<li>由于在开发的时候不会专门去配置强缓存，而浏览器又默认会缓存图片，<code>css</code>和<code>js</code>等静态资源，所以开发环境下经常会因为强缓存导致资源没有及时更新而看不到最新的效果，解决这个问题的方法有很多，常用的有以下几种</li>
</ul>
<p><strong>处理缓存带来的问题</strong></p>
<ol>
<li>直接<code>ctrl+f5</code>，这个办法能解决页面直接引用的资源更新的问题</li>
<li>使用浏览器的隐私模式开发</li>
<li>如果用的是<code>chrome</code>，可以<code>f12</code>在<code>network</code>那里把缓存给禁掉（这是个非常有效的方法）</li>
</ol>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/5.png" alt="img"></p>
<ol>
<li>在开发阶段，给资源加上一个动态的参数，如<code>css/index.css?v=0.0001</code>，由于每次资源的修改都要更新引用的位置，同时修改参数的值，所以操作起来不是很方便，除非你是在动态页面比如jsp里开发就可以用服务器变量来解决（<code>v=$&#123;sysRnd&#125;</code>），或者你能用一些前端的构建工具来处理这个参数修改的问题</li>
<li>如果资源引用的页面，被嵌入到了一个<code>iframe</code>里面，可以在<code>iframe</code>的区域右键单击重新加载该页面，以<code>chrome</code>为例</li>
</ol>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/6.png" alt="img"></p>
<ol>
<li>如果缓存问题出现在<code>ajax</code>请求中，最有效的解决办法就是<code>ajax</code>的请求地址追加随机数</li>
<li>还有一种情况就是动态设置<code>iframe</code>的<code>src</code>时，有可能也会因为缓存问题，导致看不到最新的效果，这时候在要设置的<code>src</code>后面添加随机数也能解决问题</li>
<li>如果你用的是<code>grunt</code>和<code>gulp</code>、<code>webpack</code>这种前端工具开发，通过它们的插件比如<code>grunt-contrib-connect</code>来启动一个静态服务器，则完全不用担心开发阶段的资源更新问题，因为在这个静态服务器下的所有资源返回的<code>respone header</code>中，<code>cache-control</code>始终被设置为不缓存</li>
</ol>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/7.png" alt="img"></p>
<h1 id="四、强缓存的应用"><a href="#四、强缓存的应用" class="headerlink" title="四、强缓存的应用"></a>四、强缓存的应用</h1><blockquote>
<p>强缓存是前端性能优化最有力的工具，没有之一，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度。通常的做法是，为这些静态资源全部配置一个超时时间超长的<code>Expires</code>或<code>Cache-Control</code>，这样用户在访问网页时，只会在第一次加载时从服务器请求静态资源，其它时候只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载，比如前面提到过的京东首页缓存的资源，它的缓存过期时间都设置到了<code>2026</code>年</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/8.png" alt="img"></p>
<blockquote>
<p>然而这种缓存配置方式会带来一个新的问题，就是发布时资源更新的问题，比如某一张图片，在用户访问第一个版本的时候已经缓存到了用户的电脑上，当网站发布新版本，替换了这个图片时，已经访问过第一个版本的用户由于缓存的设置，导致在默认的情况下不会请求服务器最新的图片资源，除非他清掉或禁用缓存或者强制刷新，否则就看不到最新的图片效果</p>
</blockquote>
<p>这个问题已经有成熟的解决方案，具体内容可阅读知乎这篇文章详细了解：<a target="_blank" rel="noopener" href="http://www.zhihu.com/question/20790576">http://www.zhihu.com/question/20790576</a></p>
<p>文章提到的东西都属于理论上的解决方案，不过现在已经有很多前端工具能够实际地解决这个问题，由于每个工具涉及到的内容细节都有很多，本文没有办法一一深入介绍。有兴趣的可以去了解下<code>grunt</code> <code>gulp</code> <code>webpack</code> <code>fis</code>还有edp这几个工具，基于这几个工具都能解决这个问题，尤其是<code>fis</code>和<code>edp</code>是百度推出的前端开发平台，有现成的文档可以参考：</p>
<p><a target="_blank" rel="noopener" href="http://fis.baidu.com/fis3/api/index.html">http://fis.baidu.com/fis3/api/index.html</a></p>
<p><a target="_blank" rel="noopener" href="http://ecomfe.github.io/edp/doc/initialization/install/">http://ecomfe.github.io/edp/doc/initialization/install/</a></p>
<blockquote>
<p>强缓存还有一点需要注意的是，通常都是针对静态资源使用，动态资源需要慎用，除了服务端页面可以看作动态资源外，那些引用静态资源的<code>html</code>也可以看作是动态资源，如果这种<code>html</code>也被缓存，当这些<code>html</code>更新之后，可能就没有机制能够通知浏览器这些html有更新，尤其是前后端分离的应用里，页面都是纯<code>html</code>页面，每个访问地址可能都是直接访问<code>html</code>页面，这些页面通常不加强缓存，以保证浏览器访问这些页面时始终请求服务器最新的资源</p>
</blockquote>
<h1 id="五、协商缓存的原理"><a href="#五、协商缓存的原理" class="headerlink" title="五、协商缓存的原理"></a>五、协商缓存的原理</h1><h2 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h2><blockquote>
<p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的<code>http</code>状态为<code>304</code>并且会显示一个<code>Not Modified</code>的字符串，比如你打开京东的首页，按<code>f12</code>打开开发者工具，再按<code>f5</code>刷新页面，查看<code>network</code>，可以看到有不少请求就是命中了协商缓存的</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/9.png" alt="img"></p>
<blockquote>
<p>查看单个请求的<code>Response Header</code>，也能看到<code>304</code>的状态码和<code>Not Modified</code>的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的，而不是服务器最新的资源</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/10.png" alt="img"></p>
<h2 id="5-2-Last-Modified，If-Modified-Since控制协商缓存"><a href="#5-2-Last-Modified，If-Modified-Since控制协商缓存" class="headerlink" title="5.2 Last-Modified，If-Modified-Since控制协商缓存"></a>5.2 Last-Modified，If-Modified-Since控制协商缓存</h2><ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在<code>respone</code>的<code>header</code>加上<code>Last-Modified</code>的<code>header</code>，这个<code>header</code>表示这个资源在服务器上的最后修改时间</li>
</ol>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/11.png" alt="img"></p>
<ol>
<li>浏览器再次跟服务器请求这个资源时，在<code>request</code>的<code>header</code>上加上<code>If-Modified-Since</code>的<code>header</code>，这个<code>header</code>的值就是上一次请求时返回的<code>Last-Modified</code>的值</li>
</ol>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/12.png" alt="img"></p>
<ol>
<li>服务器再次收到资源请求时，根据浏览器传过来<code>If-Modified-Since</code>和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回<code>304 Not Modified</code>，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回<code>304 Not Modified</code>的响应时，<code>response header</code>中不会再添加<code>Last-Modified</code>的<code>header</code>，因为既然资源没有变化，那么<code>Last-Modified</code>也就不会改变，这是服务器返回<code>304</code>时的<code>response header</code></li>
</ol>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/13.png" alt="img"></p>
<ol>
<li>浏览器收到<code>304</code>的响应后，就会从缓存中加载资源</li>
<li>如果协商缓存没有命中，浏览器直接从服务器加载资源时，<code>Last-Modified</code> <code>Header</code>在重新加载的时候会被更新，下次请求时，<code>If-Modified-Since</code>会启用上次返回的<code>Last-Modified</code>值</li>
</ol>
<blockquote>
<p>【<code>Last-Modified</code>，<code>If-Modified-Since</code>】都是根据服务器时间返回的<code>header</code>，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个<code>header</code>配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对<code>header</code>来管理协商缓存，这对<code>header</code>就是【<code>ETag</code>、<code>If-None-Match</code>】。它们的缓存管理的方式是</p>
</blockquote>
<h2 id="5-3-ETag、If-None-Match控制协商缓存"><a href="#5-3-ETag、If-None-Match控制协商缓存" class="headerlink" title="5.3 ETag、If-None-Match控制协商缓存"></a>5.3 ETag、If-None-Match控制协商缓存</h2><ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在<code>respone</code>的<code>header</code>加上<code>ETag</code>的<code>header</code>，这个<code>header</code>是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充<code>Last-Modified</code>的问题</li>
</ol>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/14.png" alt="img"></p>
<ol>
<li>浏览器再次跟服务器请求这个资源时，在<code>request</code>的<code>header</code>上加上<code>If-None-Match</code>的<code>header</code>，这个<code>header</code>的值就是上一次请求时返回的<code>ETag</code>的值</li>
</ol>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/15.png" alt="img"></p>
<ol>
<li>服务器再次收到资源请求时，根据浏览器传过来<code>If-None-Match</code>和然后再根据资源生成一个新的<code>ETag</code>，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回<code>304 Not Modified</code>，但是不会返回资源内容；如果有变化，就正常返回资源内容。与<code>Last-Modified</code>不一样的是，当服务器返回<code>304 Not Modified</code>的响应时，由于<code>ETag</code>重新生成过，<code>response header</code>中还会把这个<code>ETag</code>返回，即使这个<code>ETag</code>跟之前的没有变化</li>
</ol>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/16.png" alt="img"></p>
<ol>
<li>浏览器收到<code>304</code>的响应后，就会从缓存中加载资源。</li>
</ol>
<h1 id="六、协商缓存的管理"><a href="#六、协商缓存的管理" class="headerlink" title="六、协商缓存的管理"></a>六、协商缓存的管理</h1><blockquote>
<p>协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分<code>web</code>服务器都默认开启协商缓存，而且是同时启用【<code>Last-Modified</code>，<code>If-Modified-Since</code>】和【<code>ETag</code>、<code>If-None-Match</code>】，比如<code>apache</code>:</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/17.png" alt="img"></p>
<blockquote>
<p>如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。</p>
</blockquote>
<ul>
<li>【<code>Last-Modified</code>，<code>If-Modified-Since</code>】和【<code>ETag</code>、<code>If-None-Match</code>】一般都是同时启用，这是为了处理<code>Last-Modified</code>不可靠的情况。</li>
</ul>
<p><strong>有一种场景需要注意</strong></p>
<ul>
<li>分布式系统里多台机器间文件的<code>Last-Modified</code>必须保持一致，以免负载均衡到不同机器导致比对失败；</li>
<li>分布式系统尽量关闭掉<code>ETag</code>(每台机器生成的<code>ETag</code>都会不一样）；</li>
<li>京东页面的资源请求，返回的<code>repsones header</code>就只有<code>Last-Modified</code>，没有<code>ETag</code>：</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/18.png" alt="img"></p>
<blockquote>
<p>协商缓存需要配合强缓存使用，你看前面这个截图中，除了<code>Last-Modified</code>这个<code>header</code>，还有强缓存的相关<code>header</code>，因为如果不启用强缓存的话，协商缓存根本没有意义</p>
</blockquote>
<h1 id="七、相关浏览器行为对缓存的影响"><a href="#七、相关浏览器行为对缓存的影响" class="headerlink" title="七、相关浏览器行为对缓存的影响"></a>七、相关浏览器行为对缓存的影响</h1><blockquote>
<p>如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变：</p>
</blockquote>
<ul>
<li>当<code>ctrl+f5</code>强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</li>
<li>当<code>f5</code>刷新网页时，跳过强缓存，但是会检查协商缓存</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-浏览器/浏览器安全插箱跨域" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/04/29/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E6%8F%92%E7%AE%B1%E8%B7%A8%E5%9F%9F/" class="article-date">
  	<time datetime="2021-04-29T07:31:05.000Z" itemprop="datePublished">2021-04-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/29/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E6%8F%92%E7%AE%B1%E8%B7%A8%E5%9F%9F/">
        浏览器安全插箱跨域
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>什么是跨域？</strong></p>
<ul>
<li>概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域</li>
</ul>
<p><strong>下面是具体的跨域情况详解</strong></p>
<table>
<thead>
<tr>
<th align="left">URL</th>
<th align="left">说明</th>
<th align="left">是否允许通信</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="http://www.a.com/a.js%E3%80%81http://www.a.com/b.js">http://www.a.com/a.js、http://www.a.com/b.js</a></td>
<td align="left">同一域名下</td>
<td align="left">允许</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="http://www.a.com/lab/a.js%E3%80%81http://www.a.com/script/b.js">http://www.a.com/lab/a.js、http://www.a.com/script/b.js</a></td>
<td align="left">同一域名下不同文件夹</td>
<td align="left">允许</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="http://www.a.com:8000/a.js%E3%80%81http://www.a.com/b.js">http://www.a.com:8000/a.js、http://www.a.com/b.js</a></td>
<td align="left">同一域名，不同端口</td>
<td align="left">不允许</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="http://www.a.com/a.js%E3%80%81https://www.a.com/b.js">http://www.a.com/a.js、https://www.a.com/b.js</a></td>
<td align="left">同一域名，不同协议</td>
<td align="left">不允许</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="http://www.a.com/a.js%E3%80%81http://70.32.92.74/b.js">http://www.a.com/a.js、http://70.32.92.74/b.js</a></td>
<td align="left">域名和域名对应ip</td>
<td align="left">不允许</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="http://www.a.com/a.js%E3%80%81http://script.a.com/b.js">http://www.a.com/a.js、http://script.a.com/b.js</a></td>
<td align="left">主域相同，子域不同</td>
<td align="left">不允许（cookie这种情况下也不允许访问）</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="http://www.a.com/a.js%E3%80%81http://a.com/b.js">http://www.a.com/a.js、http://a.com/b.js</a></td>
<td align="left">同一域名，不同二级域名（同上）</td>
<td align="left">不允许（cookie这种情况下也不允许访问）</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="http://www.cnblogs.com/a.js%E3%80%81http://www.a.com/b.js">http://www.cnblogs.com/a.js、http://www.a.com/b.js</a></td>
<td align="left">不同域名</td>
<td align="left">不允许</td>
</tr>
</tbody></table>
<h2 id="一、document-domain跨域"><a href="#一、document-domain跨域" class="headerlink" title="一、document.domain跨域"></a>一、document.domain跨域</h2><hr>
<ul>
<li>原理：相同主域名不同子域名下的页面，可以设置<code>document.domain</code>让它们同域</li>
<li>限制：同域<code>document</code>提供的是页面间的互操作，需要载入<code>iframe</code>页面</li>
</ul>
<blockquote>
<p>下面几个域名下的页面都是可以通过<code>document.domain</code>跨域互操作的： <code>http://a.com/foo</code>, <code>http://b.a.com/bar</code>, <code>http://c.a.com/bar</code>。 但只能以页面嵌套的方式来进行页面互操作，比如常见的<code>iframe</code>方式就可以完成页面嵌套</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// URL http://a.com/foo</span><br><span class="line">var ifr = document.createElement(&#x27;iframe&#x27;);</span><br><span class="line">ifr.src = &#x27;http://b.a.com/bar&#x27;; </span><br><span class="line">ifr.onload = function()&#123;</span><br><span class="line">    var ifrdoc = ifr.contentDocument || ifr.contentWindow.document;</span><br><span class="line">    ifrdoc.getElementsById(&quot;foo&quot;).innerHTML);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ifr.style.display = &#x27;none&#x27;;</span><br><span class="line">document.body.appendChild(ifr);</span><br></pre></td></tr></table></figure>

<ul>
<li>上述代码所在的<code>URL</code>是<code>http://a.com/foo</code>，它对<code>http://b.a.com/bar</code>的<code>DOM</code>访问要求后者将 <code>document.domain</code>往上设置一级</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// URL http://b.a.com/bar</span><br><span class="line">document.domain = &#x27;a.com&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>document.domain</code>只能从子域设置到主域，往下设置以及往其他域名设置都是不允许的， 在<code>Chrome</code>中给出的错误是这样的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught DOMException: Failed to set the &#x27;domain&#x27; property on &#x27;Document&#x27;: &#x27;baidu.com&#x27; is not a suffix of &#x27;b.a.com&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="二、有src的标签"><a href="#二、有src的标签" class="headerlink" title="二、有src的标签"></a>二、有src的标签</h2><hr>
<ul>
<li>原理：所有具有<code>src</code>属性的<code>HTML</code>标签都是可以跨域的，包括<code>, </code></li>
<li>限制：需要创建一个<code>DOM</code>对象，只能用于<code>GET</code>方法</li>
</ul>
<blockquote>
<ul>
<li>在<code>document.body</code>中<code>append</code>一个具有<code>src</code>属性的<code>HTML</code>标签， <code>src</code>属性值指向的<code>URL</code>会以<code>GET</code>方法被访问，该访问是可以跨域的</li>
<li>其实样式表的&#96;&#96;标签也是可以跨域的，只要是有<code>src</code>或<code>href</code>的<code>HTML</code>标签都有跨域的能力</li>
</ul>
</blockquote>
<ul>
<li>不同的<code>HTML</code>标签发送<code>HTTP</code>请求的时机不同，例如&#96;&#96;在更改<code>src</code>属性时就会发送请求，而<code>script</code>, <code>iframe</code>, <code>link[rel=stylesheet]</code>只有在添加到<code>DOM</code>树之后才会发送<code>HTTP</code>请求：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var img = new Image();</span><br><span class="line">img.src = &#x27;http://some/picture&#x27;;        // 发送HTTP请求</span><br><span class="line"></span><br><span class="line">var ifr = $(&#x27;&lt;iframe&gt;&#x27;, &#123;src: &#x27;http://b.a.com/bar&#x27;&#125;);</span><br><span class="line">$(&#x27;body&#x27;).append(ifr);                  // 发送HTTP请求</span><br></pre></td></tr></table></figure>

<h2 id="三、JSONP"><a href="#三、JSONP" class="headerlink" title="三、JSONP"></a>三、JSONP</h2><hr>
<ul>
<li>原理：&#96;&#96;是可以跨域的，而且在跨域脚本中可以直接回调当前脚本的函数</li>
<li>限制：需要创建一个<code>DOM</code>对象并且添加到<code>DOM</code>树，只能用于<code>GET</code>方法</li>
</ul>
<blockquote>
<p><code>JSONP</code>利用的是&#96;&#96;可以跨域的特性，跨域<code>URL</code>返回的脚本不仅包含数据，还包含一个回调</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// URL: http://b.a.com/foo</span><br><span class="line">var data = &#123;</span><br><span class="line">    foo: &#x27;bar&#x27;,</span><br><span class="line">    bar: &#x27;foo&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">callback(data);</span><br></pre></td></tr></table></figure>

<ul>
<li>然后在我们在主站<code>http://a.com</code>中，可以这样来跨域获取<code>http://b.a.com</code>的数据：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// URL: http://a.com/foo</span><br><span class="line">var callback = function(data)&#123;</span><br><span class="line">    // 处理跨域请求得到的数据</span><br><span class="line">&#125;;</span><br><span class="line">var script = $(&#x27;&lt;script&gt;&#x27;, &#123;src: &#x27;http://b.a.com/bar&#x27;&#125;);</span><br><span class="line">$(&#x27;body&#x27;).append(script);</span><br></pre></td></tr></table></figure>

<ul>
<li>其实<code>jQuery</code>已经封装了<code>JSONP</code>的使用，我们可以这样来</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.getJSON( &quot;http://b.a.com/bar?callback=callback&quot;, function( data )&#123;</span><br><span class="line">    // 处理跨域请求得到的数据</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>$.getJSON</code>与<code>$.get</code>的区别是前者会把<code>responseText</code>转换为<code>JSON</code>，而且当<code>URL</code>具有<code>callback</code>参数时， <code>jQuery</code>将会把它解释为一个<code>JSONP</code>请求，创建一个&#96;&#96;标签来完成该请求</p>
</blockquote>
<h2 id="四、navigation-对象"><a href="#四、navigation-对象" class="headerlink" title="四、navigation 对象"></a>四、navigation 对象</h2><hr>
<ul>
<li>原理：<code>iframe</code>之间是共享<code>navigator</code>对象的，用它来传递信息</li>
<li>要求：<code>IE6/7</code></li>
</ul>
<blockquote>
<p>有些人注意到了<code>IE6/7</code>的一个漏洞：<code>iframe</code>之间的<code>window.navigator</code>对象是共享的。 我们可以把它作为一个<code>Messenger</code>，通过它来传递信息。比如一个简单的委托：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// a.com</span><br><span class="line">navigation.onData()&#123;</span><br><span class="line">    // 数据到达的处理函数</span><br><span class="line">&#125;</span><br><span class="line">typeof navigation.getData === &#x27;function&#x27; </span><br><span class="line">    || navigation.getData()</span><br><span class="line">// b.com</span><br><span class="line">navigation.getData = function()&#123;</span><br><span class="line">    $.get(&#x27;/path/under/b.com&#x27;)</span><br><span class="line">        .success(function(data)&#123;</span><br><span class="line">            typeof navigation.onData === &#x27;function&#x27;</span><br><span class="line">                || navigation.onData(data)</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>与<code>document.navigator</code>类似，<code>window.name</code>也是当前窗口所有页面所共享的。也可以用它来传递信息。 同样蛋疼的办法还有传递<code>Hash</code>（有些人叫锚点），这是因为每次浏览器打开一个<code>URL</code>时，<code>URL</code>后面的<code>#xxx</code>部分会保留下来，那么新的页面可以从这里获得上一个页面的数据</p>
</blockquote>
<h2 id="五、跨域资源共享（CORS）"><a href="#五、跨域资源共享（CORS）" class="headerlink" title="五、跨域资源共享（CORS）"></a>五、跨域资源共享（CORS）</h2><hr>
<ul>
<li>原理：服务器设置<code>Access-Control-Allow-OriginHTTP</code>响应头之后，浏览器将会允许跨域请求</li>
<li>限制：浏览器需要支持<code>HTML5</code>，可以支持<code>POST</code>，<code>PUT</code>等方法</li>
</ul>
<blockquote>
<p>前面提到的跨域手段都是某种意义上的<code>Hack</code>， <code>HTML5</code>标准中提出的跨域资源共享（<code>Cross Origin Resource Share</code>，<code>CORS</code>）才是正道。 它支持其他的<code>HTTP</code>方法如<code>PUT</code>, <code>POST</code>等，可以从本质上解决跨域问题。</p>
</blockquote>
<ul>
<li>例如，从<code>http://a.com</code>要访问<code>http://b.com</code>的数据，通常情况下<code>Chrome</code>会因跨域请求而报错</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest cannot load http://b.com. No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource. Origin &#x27;http://a.com&#x27; is therefore not allowed access</span><br></pre></td></tr></table></figure>

<ul>
<li>错误原因是被请求资源没有设置<code>Access-Control-Allow-Origin</code>，所以我们在<code>b.com</code>的服务器中设置这个响应头字段即可</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *              # 允许所有域名访问，或者</span><br><span class="line">Access-Control-Allow-Origin: http://a.com   # 只允许所有域名访问</span><br></pre></td></tr></table></figure>

<h2 id="六、window-postMessage"><a href="#六、window-postMessage" class="headerlink" title="六、window.postMessage"></a>六、window.postMessage</h2><hr>
<ul>
<li>原理：<code>HTML5</code>允许窗口之间发送消息</li>
<li>限制：浏览器需要支持<code>HTML5</code>，获取窗口句柄后才能相互通信</li>
</ul>
<blockquote>
<p>这是一个安全的跨域通信方法，<code>postMessage(message,targetOrigin)</code>也是<code>HTML5</code>引入的特性。 可以给任何一个<code>window</code>发送消息，不论是否同源。第二个参数可以是*但如果你设置了一个<code>URL</code>但不相符，那么该事件不会被分发。看一个普通的使用方式吧</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// URL: http://a.com/foo</span><br><span class="line">var win = window.open(&#x27;http://b.com/bar&#x27;);</span><br><span class="line">win.postMessage(&#x27;Hello, bar!&#x27;, &#x27;http://b.com&#x27;);</span><br><span class="line">// URL: http://b.com/bar</span><br><span class="line">window.addEventListener(&#x27;message&#x27;,function(event) &#123;</span><br><span class="line">    console.log(event.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="七、访问控制安全的讨论"><a href="#七、访问控制安全的讨论" class="headerlink" title="七、访问控制安全的讨论"></a>七、访问控制安全的讨论</h2><hr>
<ul>
<li>在<code>HTML5</code>之前，<code>JSONP</code>已经成为跨域的事实标准了，<code>jQuery</code>都给出了支持。 值得注意的是它只是<code>Hack</code>，并没有产生额外的安全问题。 因为<code>JSONP</code>要成功获取数据，需要跨域资源所在服务器的配合，比如资源所在服务器需要自愿地回调一个合适的函数，所以服务器仍然有能力控制资源的跨域访问</li>
<li>跨域的正道还是要使用<code>HTML5</code>提供的CORS头字段以及<code>window.postMessage</code>， 可以支持<code>POST</code>, <code>PUT</code>等<code>HTTP</code>方法，从机制上解决跨域问题。 值得注意的是<code>Access-Control-Allow-Origin</code>头字段是资源所在服务器设置的， 访问控制的责任仍然是在提供资源的服务器一方，这和<code>JSONP</code>是一样的</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2022 mr.杜
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>