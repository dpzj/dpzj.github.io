<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="杜鹏之家">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="杜鹏之家">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="mr.杜">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 6.2.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="https://img1.baidu.com/it/u=412709218,617594518&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=504&amp;h=500" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">mr.杜</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">Home</a></li>
				        
							<li><a href="/archives">Archives</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
						<!-- music -->
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Event-Loop/" style="font-size: 10px;">Event Loop</a> <a href="/tags/Graphviz/" style="font-size: 10px;">Graphviz</a> <a href="/tags/Mock/" style="font-size: 10px;">Mock</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/React/" style="font-size: 19.29px;">React</a> <a href="/tags/Redux/" style="font-size: 11.43px;">Redux</a> <a href="/tags/async-await/" style="font-size: 10px;">async/await</a> <a href="/tags/css/" style="font-size: 13.57px;">css</a> <a href="/tags/echart/" style="font-size: 10px;">echart</a> <a href="/tags/es6/" style="font-size: 16.43px;">es6</a> <a href="/tags/eslint/" style="font-size: 10px;">eslint</a> <a href="/tags/git/" style="font-size: 15.71px;">git</a> <a href="/tags/glup/" style="font-size: 10.71px;">glup</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/html/" style="font-size: 14.29px;">html</a> <a href="/tags/http/" style="font-size: 17.14px;">http</a> <a href="/tags/javascript/" style="font-size: 18.57px;">javascript</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/nginx/" style="font-size: 10.71px;">nginx</a> <a href="/tags/nodejs/" style="font-size: 12.86px;">nodejs</a> <a href="/tags/python/" style="font-size: 10.71px;">python</a> <a href="/tags/qiankun/" style="font-size: 10px;">qiankun</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/serveless/" style="font-size: 10px;">serveless</a> <a href="/tags/typescript/" style="font-size: 12.14px;">typescript</a> <a href="/tags/vs-code/" style="font-size: 11.43px;">vs code</a> <a href="/tags/vue/" style="font-size: 20px;">vue</a> <a href="/tags/vue3/" style="font-size: 10px;">vue3</a> <a href="/tags/webpack/" style="font-size: 17.86px;">webpack</a> <a href="/tags/xml/" style="font-size: 10px;">xml</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 13.57px;">优化</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10.71px;">前端</a> <a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 15px;">小程序</a> <a href="/tags/%E6%8A%93%E5%8C%85/" style="font-size: 10px;">抓包</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正则表达式</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 12.86px;">浏览器</a> <a href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/" style="font-size: 10.71px;">移动端</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.57px;">设计模式</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/">github</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">I&#39;m a developer.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://img1.baidu.com/it/u=412709218,617594518&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=504&amp;h=500" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">Home</a></li>
		        
					<li><a href="/archives">Archives</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-webpack/glup工作流" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/09/02/webpack/glup%E5%B7%A5%E4%BD%9C%E6%B5%81/" class="article-date">
  	<time datetime="2020-09-02T07:14:26.000Z" itemprop="datePublished">2020-09-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/02/webpack/glup%E5%B7%A5%E4%BD%9C%E6%B5%81/">
        glup工作流
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>配置一套基于<code>gulp</code>的工作流，满足日常的基本开发。</p>
</blockquote>
<h3 id="一、目录结构"><a href="#一、目录结构" class="headerlink" title="一、目录结构"></a>一、目录结构</h3><p><img src="https://poetries1.gitee.io/img-repo/2019/10/221.png" alt="img"></p>
<h3 id="二、-package-json"><a href="#二、-package-json" class="headerlink" title="二、 package.json"></a>二、 package.json</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;gulp-project&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;gulp dev&quot;, //npm run dev   开发</span><br><span class="line">    &quot;build&quot;: &quot;gulp build&quot;, //npm run build   发布</span><br><span class="line">    &quot;upload&quot;: &quot;gulp upload&quot;, //npm run upload 上传服务器 </span><br><span class="line">    &quot;zip&quot;: &quot;gulp zip&quot; ////npm run zip 打包文件</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;babel-preset-es2015&quot;: &quot;^6.22.0&quot;, //编译es6</span><br><span class="line">    &quot;browser-sync&quot;: &quot;^2.15.0&quot;,  //监听改动刷新</span><br><span class="line">    &quot;gulp&quot;: &quot;^3.9.1&quot;, //gulp</span><br><span class="line">    &quot;gulp-autoprefixer&quot;: &quot;^3.1.1&quot;, //补齐css浏览器前缀</span><br><span class="line">    &quot;gulp-babel&quot;: &quot;^6.1.2&quot;, // Es6</span><br><span class="line">    &quot;gulp-clean&quot;: &quot;^0.3.2&quot;, //删除文件</span><br><span class="line">    &quot;gulp-clean-css&quot;: &quot;^2.0.12&quot;, //css压缩，gulp-minify-css不更新了</span><br><span class="line">    &quot;gulp-concat&quot;: &quot;^2.6.0&quot;,//合并文件</span><br><span class="line">    &quot;gulp-ftp&quot;: &quot;^1.1.0&quot;,//提交到ftp服务器</span><br><span class="line">    &quot;gulp-git&quot;: &quot;^1.11.3&quot;,//提交到git</span><br><span class="line">    &quot;gulp-htmlmin&quot;: &quot;^2.0.0&quot;,//压缩html</span><br><span class="line">    &quot;gulp-imagemin&quot;: &quot;^3.0.3&quot;,//压缩图片</span><br><span class="line">    &quot;gulp-rename&quot;: &quot;^1.2.2&quot;,//重命名文件</span><br><span class="line">    &quot;gulp-rev-append&quot;: &quot;^0.1.6&quot;, //添加MD5版本号，这里改成了时间戳</span><br><span class="line">    &quot;gulp-sass&quot;: &quot;^2.3.2&quot;,//编译SASS</span><br><span class="line">    &quot;gulp-uglify&quot;: &quot;^2.0.0&quot;,//js压缩</span><br><span class="line">    &quot;gulp-util&quot;: &quot;^3.0.7&quot;, //说是ftp配套用的，看了下是包装了些常用函数</span><br><span class="line">    &quot;gulp-zip&quot;: &quot;^3.2.0&quot; // 打包文件</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、-gulpfile-js"><a href="#三、-gulpfile-js" class="headerlink" title="三、 gulpfile.js"></a>三、 gulpfile.js</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line">//组件</span><br><span class="line"></span><br><span class="line">let gulp = require(&#x27;gulp&#x27;),</span><br><span class="line">	browserSync = require(&#x27;browser-sync&#x27;).create(), //监听刷新</span><br><span class="line">    reload = browserSync.reload,</span><br><span class="line">    ftp = require(&#x27;gulp-ftp&#x27;), // ftp上传</span><br><span class="line">    gutil = require(&#x27;gulp-util&#x27;),</span><br><span class="line">    sass = require(&#x27;gulp-sass&#x27;), // sass</span><br><span class="line">    cleancss = require(&#x27;gulp-clean-css&#x27;), // CSS压缩</span><br><span class="line">    autoprefixer = require(&quot;gulp-autoprefixer&quot;),</span><br><span class="line">    uglify = require(&#x27;gulp-uglify&#x27;), // js压缩</span><br><span class="line">    concat = require(&#x27;gulp-concat&#x27;), // 合并文件</span><br><span class="line">    rename = require(&#x27;gulp-rename&#x27;), // 重命名</span><br><span class="line">    clean = require(&#x27;gulp-clean&#x27;), //清空文件夹</span><br><span class="line">    imagemin = require(&#x27;gulp-imagemin&#x27;), //压缩图片</span><br><span class="line">    zip = require(&#x27;gulp-zip&#x27;), //打包文件</span><br><span class="line">    rev = require(&#x27;gulp-rev-append&#x27;), //添加MD5</span><br><span class="line">    htmlmin = require(&#x27;gulp-htmlmin&#x27;), // 压缩html</span><br><span class="line">	git = require(&#x27;gulp-git&#x27;),     //git</span><br><span class="line">	babel = require(&quot;gulp-babel&quot;); //ES6 转es5</span><br><span class="line">// =========== 开发构建流程 [多文件输出] ==============</span><br><span class="line"></span><br><span class="line">//dev</span><br><span class="line">gulp.task(&#x27;sass:dev&#x27;, () =&gt; &#123;</span><br><span class="line">    gulp.src(&#x27;src/sass/*.scss&#x27;)</span><br><span class="line">        .pipe(sass())</span><br><span class="line">        .pipe(gulp.dest(&#x27;src/css/&#x27;))</span><br><span class="line">        .pipe(reload(&#123; stream: true &#125;))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 合并、重命名css</span><br><span class="line">gulp.task(&#x27;css:dev&#x27;, [&#x27;sass:dev&#x27;], () =&gt; &#123;</span><br><span class="line">    gulp.src([&#x27;src/css/*.css&#x27;, &#x27;!src/css/areaMap.css&#x27;])</span><br><span class="line">        .pipe(concat(&#x27;all.css&#x27;))</span><br><span class="line">        .pipe(gulp.dest(&#x27;dist/css/&#x27;))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 合并、重命名js</span><br><span class="line">gulp.task(&#x27;js:dev&#x27;, () =&gt; &#123;</span><br><span class="line">    gulp.src(&#x27;src/js/*.js&#x27;)</span><br><span class="line">    	.pipe(babel(&#123;</span><br><span class="line">		      	 	presets: [&#x27;es2015&#x27;]</span><br><span class="line">     			&#125;)) //ES6转ES5</span><br><span class="line">        //.pipe(concat(&#x27;all.js&#x27;)) 开发阶段分开输出js文件</span><br><span class="line">        .pipe(gulp.dest(&#x27;dist/js/&#x27;))</span><br><span class="line">        .pipe(reload(&#123; stream: true &#125;))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// HTML</span><br><span class="line"></span><br><span class="line">gulp.task(&#x27;html:dev&#x27;, () =&gt; &#123;</span><br><span class="line">    gulp.src(&#x27;src/tpl/*.html&#x27;)</span><br><span class="line">        .pipe(gulp.dest(&#x27;dist&#x27;))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 将lib的库文件对应到指定位置</span><br><span class="line">gulp.task(&#x27;lib:dev&#x27;, () =&gt; &#123;</span><br><span class="line">    gulp.src(&#x27;./src/lib/*&#x27;)</span><br><span class="line">        .pipe(gulp.dest(&#x27;./dist/lib/&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//开发构建</span><br><span class="line">gulp.task(&#x27;dev&#x27;, [&#x27;css:dev&#x27;, &#x27;js:dev&#x27;, &#x27;html:dev&#x27;, &#x27;img&#x27;,&#x27;copyFonts&#x27;,&#x27;lib&#x27;], () =&gt; &#123;</span><br><span class="line">    browserSync.init(&#123;</span><br><span class="line">        server: &#123;</span><br><span class="line">            baseDir: &quot;dist&quot; // 设置服务器的根目录为dist目录</span><br><span class="line">        &#125;,</span><br><span class="line">        notify: false // 开启静默模式</span><br><span class="line">    &#125;);</span><br><span class="line">    // 我们使用gulp的文件监听功能，来实时编译修改过后的文件</span><br><span class="line"></span><br><span class="line">    gulp.watch(&#x27;src/js/*.js&#x27;, [&#x27;js:dev&#x27;]);</span><br><span class="line">    gulp.watch(&#x27;src/sass/*.scss&#x27;, [&#x27;sass:dev&#x27;]);</span><br><span class="line">    gulp.watch(&#x27;src/tpl/*.html&#x27;, [&#x27;html:dev&#x27;]);</span><br><span class="line">    gulp.watch(&#x27;src/fonts/**&#x27;, [&#x27;copyFonts&#x27;]);</span><br><span class="line">    gulp.watch(&#x27;src/images/**&#x27;, [&#x27;img&#x27;]);</span><br><span class="line">    gulp.watch(&#x27;src/lib/**&#x27;, [&#x27;lib&#x27;]);</span><br><span class="line">&#125;);</span><br><span class="line">// =========== 正式构建 build [单文件输出] ==============</span><br><span class="line"></span><br><span class="line">// sass解析</span><br><span class="line">gulp.task(&#x27;sass&#x27;, () =&gt; &#123;</span><br><span class="line">    gulp.src(&#x27;src/sass/*.scss&#x27;)</span><br><span class="line">        //输出为压缩</span><br><span class="line">         .pipe(sass(&#123;</span><br><span class="line">             outputStyle: &#x27;compressed&#x27;</span><br><span class="line">         &#125;))</span><br><span class="line">        .pipe(sass())</span><br><span class="line">        .pipe(gulp.dest(&#x27;src/css/&#x27;))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 合并、压缩、重命名css</span><br><span class="line"></span><br><span class="line">gulp.task(&#x27;css&#x27;, [&#x27;sass&#x27;], () =&gt; &#123;</span><br><span class="line">    gulp.src([&#x27;src/css/*.css&#x27;, &#x27;!src/css/areaMap.css&#x27;])</span><br><span class="line">        .pipe(concat(&#x27;all.css&#x27;))</span><br><span class="line">        .pipe(autoprefixer(&#123;</span><br><span class="line">            browsers: [&#x27;last 2 versions&#x27;, &#x27;Android &gt;= 4.0&#x27;],</span><br><span class="line">            cascade: true, //是否美化属性值 默认：true 像这样：</span><br><span class="line">            remove: false //是否去掉不必要的前缀 默认：true </span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(cleancss()) //压缩css</span><br><span class="line">        .pipe(gulp.dest(&#x27;dist/css&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 合并，压缩,重命名js文件</span><br><span class="line"></span><br><span class="line">gulp.task(&#x27;js&#x27;, () =&gt; &#123;</span><br><span class="line">    gulp.src(&#x27;src/js/*.js&#x27;)</span><br><span class="line">    	.pipe(babel(&#123;</span><br><span class="line">		      	 	presets: [&#x27;es2015&#x27;]</span><br><span class="line">     			&#125;)) //ES6转ES5</span><br><span class="line">        .pipe(concat(&#x27;all.js&#x27;))</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(&#x27;dist/js&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 压缩HTML</span><br><span class="line"></span><br><span class="line">gulp.task(&#x27;html&#x27;, () =&gt; &#123;</span><br><span class="line">    gulp.src(&#x27;src/tpl/*.html&#x27;)</span><br><span class="line">        .pipe(rev())//记得在引用地址后面加后缀，插件原本是ver=@@hash ,这里改成了v=@@hash</span><br><span class="line">      //&lt;link rel=&quot;stylesheet&quot; href=&quot;css/all.css?v=@@hash&quot;&gt;</span><br><span class="line">      //&lt;script src=&quot;js/all.js?v=@@hash&quot;&gt;&lt;/script&gt;</span><br><span class="line">        .pipe(htmlmin(&#123;</span><br><span class="line">            removeComments: true, //清除HTML注释</span><br><span class="line">            collapseWhitespace: true, //压缩HTML</span><br><span class="line">            collapseBooleanAttributes: true, //省略布尔属性的值 &lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt;</span><br><span class="line">            removeEmptyAttributes: true, //删除所有空格作属性值 &lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt;</span><br><span class="line">            removeScriptTypeAttributes: true, //删除&lt;script&gt;的type=&quot;text/javascript&quot;</span><br><span class="line">            removeStyleLinkTypeAttributes: true, //删除&lt;style&gt;和&lt;link&gt;的type=&quot;text/css&quot;</span><br><span class="line">            minifyJS: true, //压缩页面JS</span><br><span class="line">            minifyCSS: true //压缩页面CSS</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(&#x27;dist&#x27;))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//压缩图片</span><br><span class="line"></span><br><span class="line">gulp.task(&#x27;img&#x27;, () =&gt; &#123;</span><br><span class="line">    gulp.src(&#x27;src/images/*.&#123;png,jpg,gif,ico&#125;&#x27;)</span><br><span class="line">        .pipe(imagemin(&#123;</span><br><span class="line">            optimizationLevel: 5, //类型：Number  默认：3  取值范围：0-7（优化等级）</span><br><span class="line">            progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片</span><br><span class="line">            interlaced: true, //类型：Boolean 默认：false 隔行扫描gif进行渲染</span><br><span class="line">            multipass: true //类型：Boolean 默认：false 多次优化svg直到完全优化</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(&#x27;dist/images&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//字体文件</span><br><span class="line">gulp.task(&#x27;copyFonts&#x27;, function () &#123;</span><br><span class="line">    gulp.src(&#x27;src/fonts/**/*&#x27;)</span><br><span class="line">        .pipe(gulp.dest(&#x27;dist/fonts/&#x27;))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 清空图片、样式、js</span><br><span class="line"></span><br><span class="line">gulp.task(&#x27;clean&#x27;, () =&gt; &#123;</span><br><span class="line">    gulp.src(&#x27;dist&#x27;, &#123; read: false &#125;)</span><br><span class="line">        .pipe(clean(&#123; force: true &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 将bower的库文件对应到指定位置</span><br><span class="line"></span><br><span class="line">gulp.task(&#x27;lib&#x27;, () =&gt; &#123;</span><br><span class="line">    gulp.src(&#x27;/src/lib/*&#x27;)</span><br><span class="line">        .pipe(gulp.dest(&#x27;/dist/lib/&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line">// ================ 打包主体dist 文件夹 zip ====</span><br><span class="line"></span><br><span class="line">//打包主体dist 文件夹并按照时间重命名</span><br><span class="line">gulp.task(&#x27;zip&#x27;, function()&#123;</span><br><span class="line">      function checkTime(i) &#123;</span><br><span class="line">          if (i &lt; 10) &#123;</span><br><span class="line">              i = &quot;0&quot; + i</span><br><span class="line">          &#125;</span><br><span class="line">          return i</span><br><span class="line">      &#125;</span><br><span class="line">          </span><br><span class="line">      var d=new Date();</span><br><span class="line">      var year=d.getFullYear();</span><br><span class="line">      var month=checkTime(d.getMonth() + 1);</span><br><span class="line">      var day=checkTime(d.getDate());</span><br><span class="line">      var hour=checkTime(d.getHours());</span><br><span class="line">      var minute=checkTime(d.getMinutes());</span><br><span class="line"></span><br><span class="line">  return gulp.src(&#x27;./dist/**&#x27;)</span><br><span class="line">        .pipe(zip(year+month+day +hour+minute+&#x27;.zip&#x27;))</span><br><span class="line">        .pipe(gulp.dest(&#x27;./zip&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line">//正式构建</span><br><span class="line"></span><br><span class="line">gulp.task(&#x27;build&#x27;, [&#x27;clean&#x27;,&#x27;css&#x27;, &#x27;js&#x27;, &#x27;img&#x27;, &#x27;html&#x27;,&#x27;copyFonts&#x27;,&#x27;lib&#x27;]);</span><br><span class="line"></span><br><span class="line">// ================ 上传 upload ====</span><br><span class="line"></span><br><span class="line">gulp.task(&#x27;upload&#x27;, () =&gt; &#123;</span><br><span class="line">    gulp.src(&#x27;dist/**&#x27;)</span><br><span class="line">        .pipe(ftp(&#123;</span><br><span class="line">            host: &#x27;8.8.8.8&#x27;, // 远程主机ip</span><br><span class="line">            port: 22, // 端口</span><br><span class="line">            user: &#x27;username&#x27;, // 帐号</span><br><span class="line">            pass: &#x27;password&#x27;, // 密码</span><br><span class="line">            remotePath: &#x27;/project&#x27; // 上传路径，不存在则新建</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gutil.noop())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/glup/" rel="tag">glup</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-python/opencv进阶篇" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/07/04/python/opencv%E8%BF%9B%E9%98%B6%E7%AF%87/" class="article-date">
  	<time datetime="2020-07-04T06:31:08.000Z" itemprop="datePublished">2020-07-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/04/python/opencv%E8%BF%9B%E9%98%B6%E7%AF%87/">
        opencv进阶
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="OpenCV进阶篇"><a href="#OpenCV进阶篇" class="headerlink" title="OpenCV进阶篇"></a>OpenCV进阶篇</h1><h1 id="第10章-模板匹配"><a href="#第10章-模板匹配" class="headerlink" title="第10章　模板匹配"></a>第10章　模板匹配</h1><p>模板匹配是一种最原始、最基本的识别方法，可以在原始图像中寻找特定图像的位置。模板匹配经常应用于简单的图像查找场景中，例如，在集体合照中找到某个人的位置。本章将介绍如何利用OpenCV实现模板匹配。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122082012339.png" alt="image-20211122082012339"></p>
<h2 id="10-1-模板匹配方法"><a href="#10-1-模板匹配方法" class="headerlink" title="10.1　模板匹配方法"></a>10.1　模板匹配方法</h2><p>模板是被查找目标的图像，查找模板在原始图像中的哪个位置的过程就叫模板匹配。OpenCV提供的matchTemplate()方法就是模板匹配方法，其语法如下：</p>
<pre><code> result = cv2.matchTemplate(image, templ, method, mask)
</code></pre>
<p>参数说明：　</p>
<p>image：原始图像。　</p>
<p>templ：模板图像，尺寸必须小于或等于原始图像。　</p>
<p>method：匹配的方法，可用参数值如表10.1所示。</p>
<p>表10.1　</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122082047351.png" alt="image-20211122082047351"></p>
<p>匹配方法的参数值　</p>
<p>mask：可选参数。掩模，只有cv2.TM_SQDIFF和cv2.TM_CCORR_NORMED支持此参数，建议采用默认值。</p>
<p>返回值说明：　</p>
<p>result：计算得出的匹配结果。如果原始图像的宽、高分别为W、H，模板图像的宽、高分别为w、h，result就是一个W-w+1列、H-h+1行的32位浮点型数组。数组中每一个浮点数都是原始图像中对应像素位置的匹配结果，其含义需要根据method参数来解读。<br>在模板匹配的计算过程中，模板会在原始图像中移动。模板与重叠区域内的像素逐个对比，最后将对比的结果保存在模板左上角像素点索引位置对应的数组位置中。计算过程如图10.1所示。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122082229394.png" alt="image-20211122082229394"></p>
<pre><code>                                                                     图10.1　模板在原始图像中移动并逐个匹配
</code></pre>
<p>使用cv2.TM_SQDIFF（平方差匹配）方法计算出的数组格式如下（其他方法计算出的数组格式相同，仅数值不同）：</p>
<pre><code> [[0.10165964 0.10123613 0.1008469  ... 0.10471864 0.10471849 0.10471849]
  [0.10131165 0.10087635 0.10047968 ... 0.10471849 0.10471834 0.10471849]
  [0.10089004 0.10045089 0.10006084 ... 0.10471849 0.10471819 0.10471849]
  ...
  [0.16168603 0.16291814 0.16366465 ... 0.12178455 0.12198001 0.12187888]
  [0.15859096 0.16000605 0.16096526 ... 0.12245651 0.12261643 0.12248362]
  [0.15512456 0.15672517 0.15791312 ... 0.12315679 0.1232616  0.12308815]]
</code></pre>
<p>模板将原始图像中每一块区域都覆盖一遍，但结果数组的行、列数并不等于原始图像的像素的行、列数。假设模板的宽为w，高为h，原始图像的宽为W，高为H，如图10.2所示。<br>模板移动到原始图像的边缘之后就不会继续移动了，所以模板的移动区域如图10.3所示，该区域的边长为“原始图像边长-模板边长+1”，最后加1是因为移动区域内的上下、左右的2个边都被模板覆盖到了，如果不加1会丢失数据。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122085327267.png" alt="image-20211122085327267"></p>
<pre><code>                                                                                    图10.2　模板和原始图像的宽、高
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122085350483.png" alt="image-20211122085350483"></p>
<pre><code>                                                                                            图10.3　模板移动的范围
</code></pre>
<h2 id="10-2-单模板匹配"><a href="#10-2-单模板匹配" class="headerlink" title="10.2　单模板匹配"></a>10.2　单模板匹配</h2><p>匹配过程中只用到一个模板场景叫单模板匹配。原始图像中可能只有一个和模板相似的图像，也可能有多个。如果只获取匹配程度最高的那一个结果，这种操作叫作单目标匹配。如果需要同时获取所有匹配程度较高的结果，这种操作叫作多目标匹配。</p>
<h3 id="10-2-1-单目标匹配"><a href="#10-2-1-单目标匹配" class="headerlink" title="10.2.1　单目标匹配"></a>10.2.1　单目标匹配</h3><p>单目标匹配只获取一个结果即可，就是匹配程度最高的结果（如果使用平方差匹配，则为计算出的最小结果；如果使用相关匹配或相关系数匹配，则为计算出的最大结果）。本节以平方差匹配为例介绍。<br>matchTemplate()方法的计算结果是一个二维数组，OpenCV提供了一个minMaxLoc()方法专门用来解析这个二维数组中的最大值、最小值以及这2个值对应的坐标，minMaxLoc()方法的语法如下：</p>
<pre><code> minValue, maxValue, minLoc, maxLoc = cv2.minMaxLoc(src, mask)
</code></pre>
<p>参数说明：　</p>
<p>src：matchTemplate()方法计算得出的数组。　</p>
<p>mask：可选参数，掩模，建议使用默认值。</p>
<p>返回值说明：　</p>
<p>minValue：数组中的最小值。</p>
<p>maxValue：数组中的最大值。　</p>
<p>minLoc：最小值的坐标，格式为(x, y)。　</p>
<p>maxLoc：最大值的坐标，格式为(x, y)。<br>平方差匹配的计算结果越小，匹配程度越高。minMaxLoc()方法返回的minValue值就是模板匹配的最优结果，minLoc就是最优结果区域左上角的点坐标，区域大小与模板大小一致。</p>
<p>【实例10.1】　为原始图片中匹配成功的区域绘制红框。<br>将图10.4作为模板，将图10.5作为原始图像，使用cv2.TM_SQDIFF_NORMED方式进行模板匹配，在原始图像中找到与模板一样的图案，并在该图案上绘制红色方框。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122085451979.png" alt="image-20211122085451979"></p>
<pre><code>                                                                                                              图10.4　模板
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122085539068.png" alt="image-20211122085539068"></p>
<pre><code>                                                                           图10.5　原始图片
</code></pre>
<p>具体代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122085602382.png" alt="image-20211122085602382"></p>
<p>上述代码的运行结果如图10.6所示。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122085749850.png" alt="image-20211122085749850"></p>
<pre><code>                                                                                    图10.6　模板匹配的效果
</code></pre>
<p>在许多综艺节目里，导演组给选手们一幅图像，让选手在指定区域内寻找图像中的某一静物。为了增加游戏难度，导演组可能会让选手们从2个或者多个相似的场景中选择最佳的匹配结果。接下来，使用模板匹配的相应方法模拟这个游戏。</p>
<p>【实例10.2】　从2幅图像中选择最佳的匹配结果。<br>将图10.7作为模板，将图10.8和图10.9作为原始图像，使用cv2.TM_SQDIFF_NORMED方式进行模板匹配，在2幅原始图像中找到与模板匹配结果最好的图像，并在窗口中显示出来。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122085811909.png" alt="image-20211122085811909">		</p>
<pre><code>                                                                                                      图10.7　模板
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122085837681.png" alt="image-20211122085837681"></p>
<pre><code>                                                                                              图10.8　原始图像221
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122085907444.png" alt="image-20211122085907444"></p>
<pre><code>                                                                                         图10.9　原始图像222
</code></pre>
<p>具体代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122085934422.png" alt="image-20211122085934422"></p>
<p>上述代码的运行结果如图10.10所示。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122090014973.png" alt="image-20211122090014973"></p>
<pre><code>                                                                        图10.10　从2幅图像中选择最佳的匹配结果
</code></pre>
<p>网速的提升让容量较大的文件更容易在互联网上传播，最明显结果就是现在用户计算机里被堆满了各种各样的图像文件。<br>图像文件与其他文件不同，相同内容的图像可能保存在不同大小、不同格式的文件中，这些文件的二进制字节码差别较大，很难用简单的程序识别。在没有高级识别软件的情况下想要找出内容相同的图像就只能一个一个打开用肉眼识别了。<br>OpenCV能够打破图像文件规格、格式的限制来识别图像内容。</p>
<p>【实例10.3】　查找重复的图像。<br>图10.11所示的文件夹中有10幅图像，这些图像不仅有JPG格式的，还有PNG格式的，而且这些图像的分辨率也各不相同。接下来将编写一个程序，在该文件夹中找出哪些是重复的照片。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122090116485.png" alt="image-20211122090116485"></p>
<pre><code>                                                                          图10.11　文件夹中的所有照片文件
</code></pre>
<p>想要解决这个问题，可以使用OpenCV提供的matchTemplate()方法来判断2幅图像的相似度，如果相似度大于0.9，就认为这2幅图像是相同的。<br>具体代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122090219888.png" alt="image-20211122090219888"></p>
<p>上述代码的运行结果如下：</p>
<pre><code> 相同的照片：10.png, 4.jpg,
 相同的照片：2.jpg, 5.jpg, 9.png,
</code></pre>
<h3 id="10-2-2-多目标匹配"><a href="#10-2-2-多目标匹配" class="headerlink" title="10.2.2　多目标匹配"></a>10.2.2　多目标匹配</h3><p>多目标匹配需要将原始图像中所有与模板相似的图像都找出来，使用相关匹配或相关系数匹配可以很好地实现这个功能。如果计算结果大于某值（例如0.999），则认为匹配区域的图案和模板是相同的。</p>
<p>【实例10.4】　为原始图片中所有匹配成功的图案绘制红框。<br>将图10.12作为模板，将图10.13作为原始图像。原始图像中有很多重复的图案，每一个与模板相似的图案都需要被标记出来。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122090300666.png" alt="image-20211122090300666"></p>
<pre><code>                                                                                                 图10.12　模板
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122090321173.png" alt="image-20211122090321173"></p>
<pre><code>                                                                                   图10.13　包含重复内容的原始图像
</code></pre>
<p>使用cv2.TM_CCOEFF_NORMED方法进行模板匹配，使用for循环遍历matchTemplate()方法返回的结果，找到所有大于0.99的计算结果，在这些结果的对应区域位置绘制红色矩形边框。编写代码时要注意：数组的列数在图像坐标系中为横坐标，数组的行数在图像坐标系中为纵坐标。<br>具体代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122090346039.png" alt="image-20211122090346039"></p>
<p>上述代码的运行结果如图10.14所示，程序找到了3处与模板相似的图案。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122090426271.png" alt="image-20211122090426271"></p>
<pre><code>                                                                                                图10.14　匹配结果
</code></pre>
<p>多目标匹配在实际生活中有很多应用场景。例如，统计一条快轨线路的站台总数；同一地点附近有2个地铁站，优先选择直线距离最短的地铁站等。</p>
<p>【实例10.5】　统计一条快轨线路的站台总数。<br>将图10.15作为模板，图10.16作为原始图像，在原始图像中标记快轨线路各个站台，统计这条快轨线路的站台总数。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122090450906.png" alt="image-20211122090450906"></p>
<pre><code>                                                                                                   图10.15　模板
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122090516424.png" alt="image-20211122090516424"></p>
<pre><code>                                                                                             图10.16　原始图像
</code></pre>
<p>使用cv2.TM_CCOEFF_NORMED方法进行模板匹配，使用for循环遍历matchTemplate()方法返回的结果，找到所有大于0.99的计算结果，在这些结果的对应区域位置绘制蓝色矩形边框，代码如下：       </p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122090545588.png" alt="image-20211122090545588"></p>
<p>上述代码的运行结果如图10.17所示。<br>实例10.5第6行中的results包含所有蓝色矩形边框左上角的横、纵坐标。利用这一特点，还可以模拟“同一地点附近有2个地铁站，优先选择直线距离最短的地铁站”这一生活场景，模板如图10.18所示。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122090628716.png" alt="image-20211122090628716"></p>
<pre><code>                                                                               图10.17　统计一条快轨线路的站台总数
</code></pre>
<p>【实例10.6】　优先选择直线距离最短的地铁站。<br>如图10.19所示，坐标为(62, 150)的地点附近有人民广场和解放大路两个地铁站，如何优先选择直线距离最短的地铁站呢？首先将图10.18作为模板，将图10.19作为原始图像，然后在原始图像中标记出这两个地铁站，最后计算并比较坐标为(62, 150)这个地点与这两个地铁站的直线距离。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122090830746.png" alt="image-20211122090830746"></p>
<pre><code>                                                                                                  图10.18　模板



                                                                                             图10.19　原始图像
</code></pre>
<p>使用cv2.TM_CCOEFF_NORMED方法进行模板匹配，使用for循环遍历matchTemplate()方法返回的结果，找到所有大于0.99的计算结果，在这些结果的对应区域位置绘制蓝色矩形边框，分别计算(62,150)到蓝色矩形边框左上角的距离，用绿色线段标记出直线距离最短的地铁站，代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122091313117.png" alt="image-20211122091313117"></p>
<p>上述代码的运行结果如图10.20所示。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122091347963.png" alt="image-20211122091347963"></p>
<pre><code>                                                                        图10.20　优先选择直线距离最短的地铁站
</code></pre>
<h2 id="10-3-多模板匹配"><a href="#10-3-多模板匹配" class="headerlink" title="10.3　多模板匹配"></a>10.3　多模板匹配</h2><p>匹配过程中同时查找多个模板的操作叫多模板匹配。多模板匹配实际上就是进行了n次“单模板多目标匹配”操作，n的数量为模板总数。【实例10.7】　同时匹配3个不同的模板。<br>将图10.21～图10.23作为模板，将图10.24（a）作为原始图像。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122091419764.png" alt="image-20211122091419764"></p>
<pre><code>                                                                                                   图10.21　模板1
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122091440162.png" alt="image-20211122091440162"></p>
<pre><code>                                                                                              图10.22　模板2
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122091458891.png" alt="image-20211122091458891"></p>
<pre><code>                                                                                                     图10.23　模板3
</code></pre>
<p>每一个模板都要做一次“单模板多目标匹配”，最后把所有模板的匹配结果汇总到一起。“单模板多目标匹配”的过程可以封装成一个方法，方法参数为模板和原始图像，方法内部将计算结果再加工一下，直接返回所有红框左上角和右下角两点横纵坐标的列表。在方法之外，将所有模板计算得出的坐标汇总到一个列表中，按照这些汇总的坐标一次性将所有红框都绘制出来。<br>具体代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122091539261.png" alt="image-20211122091539261"></p>
<p>上述代码的运行效果如图10.24（b）所示。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122091621151.png" alt="image-20211122091621151"></p>
<pre><code>                                                                                            图10.24　多模板匹配效果
</code></pre>
<p>使用多模板匹配能够解决很多生活中的实际问题。例如，一个收费停车场有4个车位，车位上陆续地停放了4辆车，通过多模板匹配，能够知晓这4辆车分别停在了哪个车位上。接下来将模拟这一生活场景。</p>
<p>【实例10.8】　使用多模板匹配让控制台判断4辆车分别停在了哪个车位上。<br>有4辆车按图10.25～图10.28的顺序陆续驶入停车场，这4辆车停在4个车位上的效果如图10.29所示。将图10.25～图10.28作为模板，将图10.29作为原始图像，使用cv2. TM_CCOEFF_NORMED方式进行模板匹配，在原始图像中找到与4个模板一样的图像后，在控制台上输出这4辆车分别停在了哪个车位上。</p>
<p>说明<br>在图10.29中，1号车位水平像素的取值范围是0<del>200，2号车位水平像素的取值范围是200</del>433，3号车位水平像素的取值范围是433<del>656，4号车位水平像素的取值范围是656</del>871。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122091712450.png" alt="image-20211122091712450"></p>
<pre><code>                                                                                                  图10.25　模板1
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122091731718.png" alt="image-20211122091731718"></p>
<pre><code>                                                                                                 图10.26　模板2
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122091750330.png" alt="image-20211122091750330"></p>
<pre><code>                                                                                                   图10.27　模板3
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122091808719.png" alt="image-20211122091808719"></p>
<pre><code>                                                                                                    图10.28　模板4
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122091825529.png" alt="image-20211122091825529"></p>
<pre><code>                                                                                                   图10.29　原始图像
</code></pre>
<p>具体代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122091850011.png" alt="image-20211122091850011"></p>
<p>上述代码的运行结果如下：</p>
<pre><code> 车位编号: 4
 车位编号: 3
 车位编号: 2
 车位编号: 1
</code></pre>
<p>上面的结果可以得出以下结论：图10.25所示的车辆停在了4号车位上，图10.26所示的车辆停在了3号车位上，图10.27所示的车辆停在了2号车位上，图10.28所示的车辆停在了1号车位上。</p>
<h2 id="10-4-小结"><a href="#10-4-小结" class="headerlink" title="10.4　小结"></a>10.4　小结</h2><p>模板匹配包括单模板匹配和多模板匹配，单模板匹配又包括单目标匹配和多目标匹配。实现这些内容的基础方法就是模板匹配方法，即matchTemplate()方法。其中，重点掌握模板匹配方法的6个参数值。此外，为了实现单目标匹配，除了需要使用模板匹配方法matchTemplate()外，还要使用minMaxLoc()方法，这个方法返回的就是单目标匹配的最优结果。对于多目标匹配，要将它和多模板匹配区分开：多目标匹配只有一个模板，而多模板匹配则有多个模板。</p>
<h1 id="第11章-滤波器"><a href="#第11章-滤波器" class="headerlink" title="第11章　滤波器"></a>第11章　滤波器</h1><p>在尽量保留原图像信息的情况下，去除图像内噪声、降低细节层次信息等一系列过程，叫作图像的平滑处理（或图像的模糊处理）。实现平滑处理最常用的工具就是滤波器。通过调节滤波器的参数，可以控制图像的平滑程度。OpenCV提供了种类丰富的滤波器，每种滤波器使用的算法均不同，但都能对图像中的像素值进行微调，让图像呈现平滑效果。本章将介绍均值滤波器、中值滤波器、高斯滤波器和双边滤波器的使用方法。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122092213657.png" alt="image-20211122092213657"></p>
<h2 id="11-1-均值滤波器"><a href="#11-1-均值滤波器" class="headerlink" title="11.1　均值滤波器"></a>11.1　均值滤波器</h2><p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122092621030.png" alt="image-20211122092621030"></p>
<pre><code>                                                                                           图11.1　噪声图像
</code></pre>
<p>图像中可能会出现这样一种像素，该像素与周围像素的差别非常大，导致从视觉上就能看出该像素无法与周围像素组成可识别的图像信息，降低了整个图像的质量。这种“格格不入”的像素就是图像的噪声。如果图像中的噪声都是随机的纯黑像素或者纯白像素，这样的噪声称作“<strong>椒盐噪声”或“盐噪声</strong>”。例如如图7.1所示的就是一幅只有噪声的图像，常称为“雪花点”。<br>以一个像素为核心，其周围像素可以组成一个n行n列（简称n×n）的矩阵，这样的矩阵结构在滤波操作中被称为“滤波核”。矩阵的行、列数决定了滤波核的大小，如图11.2所示的滤波核大小为3×3，包含9个像素；图11.3所示的滤波核大小为5×5，包含25个像素。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122092605201.png" alt="image-20211122092605201"></p>
<pre><code>                                                                                             图11.2　3×3的滤波核
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122092712502.png" alt="image-20211122092712502"></p>
<pre><code>                                                                                               图11.3　5×5的滤波核
</code></pre>
<p>均值滤波器（也称为低通滤波器）可以把图像中的每一个像素都当成滤波核的核心，然后计算核内所有像素的平均值，最后让核心像素值等于这个平均值。<br>例如，图11.4就是均值滤波的计算过程。滤波核大小为3×3，核心像素值是35，颜色较深，周围像素值都为110～150，因此可以认为核心像素是噪声。将滤波核中的所有像素值相加，然后除以像素个数，就得出了平均值123（四舍五入取整）。将核心像素的值改成123，其颜色就与周围颜色差别不大，图像就变得平滑了。这就是均值滤波去噪的原理。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122092745945.png" alt="image-20211122092745945"></p>
<pre><code>                                                                           图11.4　均值滤波的计算过程
</code></pre>
<p>OpenCV将均值滤波器封装成blur()方法，其语法如下：</p>
<pre><code> dst = cv2.blur(src, ksize, anchor, borderType)
</code></pre>
<p>参数说明：　</p>
<p>src：被处理的图像。　</p>
<p>ksize：滤波核大小，其格式为(高度，宽度)，建议使用如(3, 3)、(5, 5)、(7, 7)等宽、高相等的奇数边长。滤波核越大，处理之后的图像就越模糊。　</p>
<p>anchor：可选参数，滤波核的锚点，建议采用默认值，可以自动计算锚点。</p>
<p>borderType：可选参数，边界样式，建议采用默认值。</p>
<p>返回值说明：　</p>
<p>dst：经过均值滤波处理之后的图像。</p>
<p>【实例11.1】　对花朵图像进行均值滤波操作。<br>分别使用大小为3×3、5×5和9×9的滤波核对花朵图像进行均值滤波操</p>
<p>作，具体代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122094217442.png" alt="image-20211122094217442"></p>
<p>上述代码的运行结果如图11.5所示，从这个结果可以看出，滤波核越大，处理之后的图像就越模糊。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122092914325.png" alt="image-20211122092914325"></p>
<pre><code>                                                                                      图11.5　图像均值滤波效果
</code></pre>
<h2 id="11-2-中值滤波器"><a href="#11-2-中值滤波器" class="headerlink" title="11.2　中值滤波器"></a>11.2　中值滤波器</h2><p>中值滤波器的原理与均值滤波器非常相似，唯一的不同就是不计算像素的平均值，而是将所有像素值排序，把最中间的像素值取出，赋值给核心像素。</p>
<p>例如，图11.6就是中值滤波的计算过程。滤波核大小为3×3，核心像素值是35，周围像素值都为110～150。将核内所有像素值按升序排列，9个像素值排成一行，最中间位置为第5个位置，这个位置的像素值为131。不需再做任何计算，直接把131赋值给核心像素，其颜色就与周围颜色差别不大，图像就变得平滑了。这就是中值滤波去噪的原理。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122095233594.png" alt="image-20211122095233594"></p>
<p>图11.6　中值滤波的计算过程<br>OpenCV将中值滤波器封装成medianBlur()方法，其语法如下：</p>
<pre><code> dst = cv2.medianBlur(src, ksize)
</code></pre>
<p>参数说明：　</p>
<p>src：被处理的图像。　</p>
<p>ksize：滤波核的边长，必须是大于1的奇数，如3、5、7等。该方法根据此边长自动创建一个正方形的滤波核。</p>
<p>返回值说明：　</p>
<p>dst：经过中值滤波处理之后的图像。</p>
<p>注意<br>中值滤波器的ksize参数是边长，而其他滤波器的ksize参数通常为（高，宽）。</p>
<p>【实例11.2】　对花朵图像进行中值滤波操作.<br>分别使用边长为3、5、9的滤波核对花朵图像进行中值滤波操作，具体代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122095347319.png" alt="image-20211122095347319"></p>
<p>上述代码的运行结果如图11.7所示，滤波核的边长越长，处理之后的图像就越模糊。中值滤波处理的图像会比均值滤波处理的图像丢失更多细节。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122095440078.png" alt="image-20211122095440078"></p>
<pre><code>                                                                                  图11.7　图像中值滤波效果
</code></pre>
<h2 id="11-3-高斯滤波器"><a href="#11-3-高斯滤波器" class="headerlink" title="11.3　高斯滤波器"></a>11.3　高斯滤波器</h2><p>高斯滤波也被称为高斯模糊或高斯平滑，是目前应用最广泛的平滑处理算法。高斯滤波可以很好地在降低图片噪声、细节层次的同时保留更多的图像信息，经过处理的图像呈现“磨砂玻璃”的滤镜效果。<br>进行均值滤波处理时，核心周围每个像素的权重都是均等的，也就是每个像素都同样重要，所以计算平均值即可。但在高斯滤波中，越靠近核心的像素权重越大，越远离核心的像素权重越小，例如5×5大小的高斯滤波卷积核的权重示意图如图11.8所示。像素权重不同不能取平均值，要从权重大的像素中取较多的信息，从权重小的像素中取较少的信息。简单概括就是“离谁更近，跟谁更像”。<br>高斯滤波的计算过程涉及卷积运算，会有一个与滤波核大小相等的卷积核。本节仅以3×3的滤波核为例，简单地描述一下高斯滤波的计算过程。<br>卷积核中保存的值就是核所覆盖区域的权重值，其遵循图11.8的规律。卷积核中所有权重值相加的结果为1。例如，3×3的卷积核可以是如图11.9所示的值。随着核大小、σ标准差的变化，卷积核中的值也会发生较大变化，图11.9仅是一种最简单的情况。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122095530857.png" alt="image-20211122095530857"></p>
<pre><code>                                                             图11.8　5×5的高斯滤波卷积核的权重示意图
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122095559972.png" alt="image-20211122095559972"></p>
<pre><code>                                                                               图11.9　简化的3×3的卷积核
</code></pre>
<p>进行高斯滤波的过程中，滤波核中像素与卷积核进行卷积计算，最后将计算结果赋值给滤波核的核心像素。其计算过程如图11.10所示。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122095620790.png" alt="image-20211122095620790"></p>
<pre><code>                                                                                       图11.10　像素与卷积核进行卷积计算
</code></pre>
<p>OpenCV将高斯滤波器封装成了GaussianBlur()方法，其语法如下：</p>
<pre><code> dst = cv2.GaussianBlur(src, ksize, sigmaX, sigmaY, borderType)
</code></pre>
<p>参数说明：　</p>
<p>src：被处理的图像。</p>
<p>ksize：滤波核的大小，宽高必须是奇数，如(3, 3)、(5, 5)等。　</p>
<p>sigmaX：卷积核水平方向的标准差。　</p>
<p>sigmaY：卷积核垂直方向的标准差。　修改sigmaX或sigmaY的值都可以改变卷积核中的权重比例。如果不知道如何设计这2个参数值，就直接把这2个参数的值写成0，该方法就会根据滤波核的大小自动计算合适的权重比例。　</p>
<p>borderType：可选参数，边界样式，建议使用默认值。</p>
<p>返回值说明：　</p>
<p>dst：经过高斯滤波处理之后的图像。</p>
<p>【实例11.3】　对花朵图像进行高斯滤波操作。<br>分别使用大小为5×5、9×9和15×15的滤波核对花朵图像进行高斯滤波操作，水平方向和垂直方向的标准差参数值全部为0，具体代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122095728517.png" alt="image-20211122095728517"></p>
<p>上述代码的运行结果如图11.11所示，滤波核越大，处理之后的图像就越模糊。和均值滤波、中值滤波处理的图像相比，高斯滤波处理的图像更加平滑，保留的图像信息更多，更容易辨认。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122095747712.png" alt="image-20211122095747712"></p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122095856218.png" alt="image-20211122095856218"></p>
<pre><code>                                                                                图11.11　图像的高斯滤波效果
</code></pre>
<h2 id="11-4-双边滤波器"><a href="#11-4-双边滤波器" class="headerlink" title="11.4　双边滤波器"></a>11.4　双边滤波器</h2><p>不管是均值滤波、中值滤波还是高斯滤波，都会使整幅图像变得平滑，图像中的边界会变得模糊不清。双边滤波是一种在平滑处理过程中可以有效保护边界信息的滤波操作方法。<br>双边滤波器自动判断滤波核处于“平坦”区域还是“边缘”区域：如果滤波核处于“平坦”区域，则会使用类似高斯滤波的算法进行滤波；如果滤波核处于“边缘”区域，则加大“边缘”像素的权重，尽可能地让这些像素值保持不变。<br>例如，图11.12是一幅黑白拼接图像，对这幅图像进行高斯滤波，黑白交界处就会变得模糊不清，效果如图11.13所示，但如果对这幅图像进行双边滤波，黑白交界处的边界则可以很好地保留下来，效果如图11.14所示。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122095927108.png" alt="image-20211122095927108"></p>
<pre><code>                                                                                         图11.12　原图
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122095943849.png" alt="image-20211122095943849"></p>
<pre><code>                                                                                  图11.13　高斯滤波效果
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122100141070.png" alt="image-20211122100141070"></p>
<pre><code>                                                                                  图11.14　双边滤波效果
</code></pre>
<p>OpenCV将双边滤波器封装成bilateralFilter()方法，其语法如下：</p>
<pre><code> dst = cv2.bilateralFilter(src, d, sigmaColor, sigmaSpace, borderType)
</code></pre>
<p>参数说明：　</p>
<p>src：被处理的图像。　</p>
<p>d：以当前像素为中心的整个滤波区域的直径。如果d&lt;0，则自动根据sigmaSpace参数计算得到。该值与保留的边缘信息数量成正比，与方法运行效率成反比。　</p>
<p>sigmaColor：参与计算的颜色范围，这个值是像素颜色值与周围颜色值的最大差值，只有颜色值之差小于这个值时，周围的像素才进行滤波计算。值为255时，表示所有颜色都参与计算。　</p>
<p>sigmaSpace：坐标空间的σ（sigma）值，该值越大，参与计算的像素数量就越多。　</p>
<p>borderType：可选参数，边界样式，建议默认。<br>返回值说明：　</p>
<p>dst：经过双边滤波处理之后的图像。</p>
<p>【实例11.4】　对比高斯滤波和双边滤波的处理效果。</p>
<p>使用大小为(15, 15)的滤波核对花朵图像进行高斯滤波处理，同样使用15作为范围直径对花朵图像进行双边滤波处理，观察两种滤波处理之后的图像边缘有什么差别，具体代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122100239643.png" alt="image-20211122100239643"></p>
<p>上述代码的运行结果如图11.15所示，可以看出高斯滤波模糊了整个画面，但双边滤波保留了较清晰的边缘信息。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211122100319332.png" alt="image-20211122100319332"></p>
<pre><code>                                                                       图11.15　两种滤波方法效果对比
</code></pre>
<h2 id="11-5-小结"><a href="#11-5-小结" class="headerlink" title="11.5　小结"></a>11.5　小结</h2><p>噪声指的是一幅图像内部的、高亮度的像素点。图像平滑处理是指在尽量保留原图像信息的情况下，去除图像内部的这些高亮度的像素点（也就是“噪声”）。为了实现图像平滑处理，需要的工具就是滤波器。本章主要讲解了OpenCV中的4种滤波器，虽然每种滤波器的实现原理都不同，但是每种滤波器都能对图像进行图像平滑处理。读者朋友在掌握这4种滤波器的实现方法的同时，也要熟悉这4种滤波器的实现原理。</p>
<h1 id="第12章-腐蚀与膨胀"><a href="#第12章-腐蚀与膨胀" class="headerlink" title="第12章　腐蚀与膨胀"></a>第12章　腐蚀与膨胀</h1><p>腐蚀和膨胀是图像形态学中的两种核心操作，通过这两种操作可以清除或强化图像中的细节。合理使用腐蚀和膨胀，还可以实现图像开运算、闭运算、梯度运算、顶帽运算和黑帽运算等极具特点的操作。下面将对腐蚀、膨胀以及其他形态学操作进行详细的介绍。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125193906728.png" alt="image-20211125193906728"></p>
<h2 id="12-1-腐蚀"><a href="#12-1-腐蚀" class="headerlink" title="12.1　腐蚀"></a>12.1　腐蚀</h2><p>腐蚀操作可以让图像沿着自己的边界向内收缩。OpenCV通过“核”来实现收缩计算。“核”的英文名为kernel，在形态学中可以理解为“由n个像素组成的像素块”，像素块包含一个核心（核心通常在中央位置，也可以定义在其他位置）。像素块在图像的边缘移动，在移动过程中，核会将图像边缘那些与核重合但又没有越过核心的像素点都抹除，效果类似图12.1所示的过程，就像削土豆皮一样，将图像一层一层地“削薄”。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125193959328.png" alt="image-20211125193959328"></p>
<pre><code>                                                                                   图12.1　核腐蚀图像中的像素
</code></pre>
<p>OpenCV将腐蚀操作封装成erode()方法，该方法的语法如下：</p>
<pre><code> dst = cv2.erode(src, kernel, anchor, iterations, borderType, borderValue)
</code></pre>
<p>参数说明：</p>
<p>src：原始图像。</p>
<p>kernel：腐蚀使用的核。　</p>
<p>anchor：可选参数，核的锚点位置。　</p>
<p>iterations：可选参数，腐蚀操作的迭代次数，默认值为1。　</p>
<p>borderType：可选参数，边界样式，建议默认。　</p>
<p>borderValue：可选参数，边界值，建议默认。</p>
<p>返回值说明：　</p>
<p>dst：经过腐蚀之后的图像。<br>图像经过腐蚀操作之后，可以抹除一些外部的细节，如图12.2所示是一个卡通小蜘蛛，如果用一个5×5的像素块作为核对小蜘蛛进行腐蚀操作，可以得到如图12.3所示的结果。小蜘蛛的腿被当成外部细节抹除了，同时小蜘蛛的眼睛变大了，因为核从内部也“削”了一圈。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125194100364.png" alt="image-20211125194100364"></p>
<pre><code>                                                                                           图12.2　原图
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125194124001.png" alt="image-20211125194124001"></p>
<pre><code>                                                                                     图12.3　腐蚀之后的图像
</code></pre>
<p>在OpenCV做腐蚀或其他形态学操作时，通常使用numpy模块来创建核数组，例如：</p>
<pre><code> import numpy as np
 k = np.ones((5, 5), np.uint8)
</code></pre>
<p>这两行代码就是通过numpy模块的ones()方法创建了一个5行5列（简称5×5）、数字类型为无符号8位整数、每一个数字的值都是1的数组，这个数组作为erode()方法的核参数。除了5×5的结构，还可以使用3×3、9×9、11×11等结构，行列数越大，计算出的效果就越粗糙，行列数越小，计算出的效果就越精细。</p>
<p>【实例12.1】　将仙人球图像中的刺抹除。<br>仙人球的叶子呈针状，茎呈深绿色，如图12.4所示。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125194225098.png" alt="image-20211125194225098"></p>
<pre><code>                                                                                           图12.4　仙人球
</code></pre>
<p>使用3×3的核对仙人球图像进行腐蚀操作，可以将图像里的刺抹除，具体代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125194308740.png" alt="image-20211125194308740"></p>
<p>上述代码的运行结果如图12.5所示。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125194341145.png" alt="image-20211125194341145"></p>
<pre><code>                                                                          图12.5　图像腐蚀操作效果
</code></pre>
<h2 id="12-2-膨胀"><a href="#12-2-膨胀" class="headerlink" title="12.2　膨胀"></a>12.2　膨胀</h2><p>膨胀操作与腐蚀操作相反，膨胀操作可以让图像沿着自己的边界向内扩张。同样是通过核来计算，当核在图像的边缘移动时，核会将图像边缘填补新的像素，效果类似图12.6所示的过程，就像在一面墙上反反复复地涂水泥，让墙变得越来越厚。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125194443041.png" alt="image-20211125194443041"></p>
<pre><code>                                                                                  图12.6　核填补图像中的像素
</code></pre>
<p>OpenCV将膨胀操作封装成dilate()方法，该方法的语法如下：</p>
<pre><code> dst = cv2.dilate(src, kernel, anchor, iterations, borderType, borderValue)
</code></pre>
<p>参数说明：　</p>
<p>src：原始图像。　</p>
<p>kernel：膨胀使用的核。　</p>
<p>anchor：可选参数，核的锚点位置。　</p>
<p>iterations：可选参数，腐蚀操作的迭代次数，默认值为1。　</p>
<p>borderType：可选参数，边界样式，建议默认。　</p>
<p>borderValue：可选参数，边界值，建议默认。<br>返回值说明：　</p>
<p>dst：经过膨胀之后的图像。<br>图像经过膨胀操作之后，可以放大一些外部的细节，如图12.7（a）所示的卡通小蜘蛛，如果用一个5×5的像素块作为核对小蜘蛛进行膨胀操作，可以得到如图12.7（b）所示的结果，小蜘蛛不仅腿变粗了，而且连眼睛都胖没了。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125194535307.png" alt="image-20211125194535307"></p>
<pre><code>                                                                            图12.7　图像膨胀操作效果
</code></pre>
<p>【实例12.2】　将图像加工成“近视眼”效果。<br>近视眼由于聚焦不准，看东西都需要放大并且模模糊糊的，利用膨胀操作可以将正常画面处理成近视眼看到的画面。采用9×9的数组作为核，对图12.8（a）进行膨胀操作。<br>具体代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125194619331.png" alt="image-20211125194619331"></p>
<p>上述代码的运行结果如图12.8所示</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125194637143.png" alt="image-20211125194637143"></p>
<pre><code>                                                               图12.8　图像膨胀操作“近视眼”效果
</code></pre>
<h2 id="12-3-开运算"><a href="#12-3-开运算" class="headerlink" title="12.3　开运算"></a>12.3　开运算</h2><p>开运算是将图像<strong>先进行腐蚀操作，再进行膨胀操作</strong>。开运算可以用来抹除图像外部的细节（或者噪声）。<br>例如，图12.9是一个简单的二叉树，父子节点之间都有线连接。如果对此图像进行腐蚀操作，可以得出如图12.10所示的图像，连接线消失了，节点也比原图节点小一圈。此时再执行膨胀操作，让缩小的节点恢复到原来的大小，就得到了如图12.11所示的效果。<br>这3幅图就是开运算的过程，从结果中可以明显地看出：经过开运算之后，二叉树中的连接线消失了，只剩下光秃秃的节点。因为连接线被核当成“细节”抹除了，所以利用检测轮廓的方法可以统计二叉树节点数量，也就是说在某些情况下，开运算的结果还可以用来做数量统计。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125194659165.png" alt="image-20211125194659165"></p>
<pre><code>                                                                                    图12.9　简单的二叉树
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125194754294.png" alt="image-20211125194754294"></p>
<pre><code>                                                                  图12.10　二叉树图像腐蚀之后的效果
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125194813564.png" alt="image-20211125194813564"></p>
<pre><code>                                                                     图12.11　对腐蚀的图像做膨胀操作
</code></pre>
<p>【实例12.3】　抹除黑种草图像中的针状叶子。<br>黑种草如图12.12（a）所示，花呈蓝色，叶子像针一样又细又长，呈羽毛状。要抹除黑种草图像中的叶子，可以使用5×5的核对图像进行开运算。<br>具体代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125194832293.png" alt="image-20211125194832293"></p>
<p>上述代码的运行结果如图12.12（b）所示，经过开运算后黑种草图像虽然略为模糊，但叶子都不见了。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125194853964.png" alt="image-20211125194853964"></p>
<pre><code>                                                                                               图12.12　图像开运算效果
</code></pre>
<h2 id="12-4-闭运算"><a href="#12-4-闭运算" class="headerlink" title="12.4　闭运算"></a>12.4　闭运算</h2><p>闭运算是将图像先进行膨胀操作，再进行腐蚀操作。闭运算可以抹除图像内部的细节（或者噪声）。<br>例如，图12.13（a）是一个身上布满斑点的小蜘蛛，这些斑点就是图像的内部细节。先将图像进行膨胀操作，小蜘蛛身上的斑点（包括眼睛）被抹除，效果如图12.13（b）所示。然后再将图像进行腐蚀操作，膨胀的小蜘蛛恢复到原来的大小，效果如图12.13（c）所示。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125194952165.png" alt="image-20211125194952165"></p>
<pre><code>                                                                              图12.13　图像闭运算效果
</code></pre>
<p>这3幅图就是闭运算的过程，从结果中可以明显地看出：经过闭运算后，小蜘蛛身上的花纹都被抹除了，就连眼睛也被当成“细节”抹除了。<br>闭运算除了会抹除图像内部的细节，还会让一些离得较近的区域合并成一块区域。</p>
<p>【实例12.4】　对汉字图片进行闭运算。<br>使用15×15的核对图12.14（a）做闭运算。因为使用的核比较大，很容易导致一些间隔较近的区域合并到一起，观察闭运算对汉字图片造成了哪些影响。<br>具体代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125195012305.png" alt="image-20211125195012305"></p>
<p>上述代码的运行结果如图12.14（b）所示，“田”字经过闭运算之后没有多大变化，但是“野”字经过闭运算之后，许多独立的区域因膨胀操作合并到一起，导致文字很难辨认。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125195103765.png" alt="image-20211125195103765"></p>
<pre><code>                                                                                    图12.14　汉字图片闭运算效果
</code></pre>
<h2 id="12-5-形态学运算"><a href="#12-5-形态学运算" class="headerlink" title="12.5　形态学运算"></a>12.5　形态学运算</h2><p>腐蚀和膨胀是形态学的基础操作，除了开运算和闭运算以外，形态学中还有几种比较有特点的运算。OpenCV提供了一个morphologyEx()形态学方法，包含所有常用的运算，其语法如下：</p>
<pre><code> dst = cv2.morphologyEx(src, op, kernel, anchor, iterations, borderType, borderValue)
</code></pre>
<p>参数说明：　</p>
<p>src：原始图像。　</p>
<p>op：操作类型，具体值如表12.1所示。</p>
<pre><code>                                                                       表12.1　形态学函数的操作类型参数　
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125195140684.png" alt="image-20211125195140684"></p>
<p>kernel：操作过程中使用的核。　</p>
<p>anchor：可选参数，核的锚点位置。　</p>
<p>iterations：可选参数，迭代次数，默认值为1。　</p>
<p>borderType：可选参数，边界样式，建议默认。　</p>
<p>borderValue：可选参数，边界值，建议默认。</p>
<p>返回值说明：　</p>
<p>dst：操作之后得到的图像。<br>morphologyEx()方法实现的腐蚀、膨胀、开运算和闭运算效果与前文中介绍的效果完全一致，本节不再赘述，下面将介绍3个特点鲜明的操作：梯度运算、顶帽运算和黑帽运算。</p>
<h3 id="12-5-1-梯度运算"><a href="#12-5-1-梯度运算" class="headerlink" title="12.5.1　梯度运算"></a>12.5.1　梯度运算</h3><p>这里的梯度是指图像梯度，可以简单地理解为像素的变化程度。如果几个连续的像素，其像素值跨度越大，则梯度值越大。<br>梯度运算的运算过程如图12.15所示，让原图的膨胀图减原图的腐蚀图。因为膨胀图比原图大，腐蚀图比原图小，利用腐蚀图将膨胀图掏空，就得到了原图的轮廓图。说明<br>梯度运算中得到的轮廓图只是一个大概轮廓，不精准。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125195234243.png" alt="image-20211125195234243"></p>
<pre><code>                                                                             图12.15　梯度运算过程
</code></pre>
<p>梯度运算的参数为cv2.MORPH_GRADIENT，下面通过一段代码实现图12.15的效果。</p>
<p>【实例12.5】　通过梯度运算画出小蜘蛛的轮廓。<br>使用5×5的核对小蜘蛛图像进行形态学梯度运算，具体代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125195253240.png" alt="image-20211125195253240"></p>
<p>上述代码的运行结果如图12.16所示。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125195322974.png" alt="image-20211125195322974"></p>
<pre><code>                                                                                       图12.16　图像梯度运算效果
</code></pre>
<h3 id="12-5-2-顶帽运算"><a href="#12-5-2-顶帽运算" class="headerlink" title="12.5.2　顶帽运算"></a>12.5.2　顶帽运算</h3><p>顶帽运算的运算过程如图12.17所示，让原图减原图的开运算图。因为开运算抹除图像的外部细节，“有外部细节”的图像减去“无外部细节”的图像，得到的结果就只剩外部细节了，所以经过顶帽运算之后，小蜘蛛就只剩蜘蛛腿了。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125195410644.png" alt="image-20211125195410644"></p>
<pre><code>                                                                                  图12.17　顶帽运算过程
</code></pre>
<p>顶帽运算的参数为cv2.MORPH_TOPHAT，下面通过一段代码实现图12.18的效果。</p>
<p>【实例12.6】　通过顶帽运算画出小蜘蛛的腿。<br>使用5×5的核对小蜘蛛图像进行顶帽运算，具体代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125195435250.png" alt="image-20211125195435250"></p>
<p>上述代码的运算结果如图12.18所示。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125195455237.png" alt="image-20211125195455237"></p>
<pre><code>                                                                                            图12.18　图像开运算效果
</code></pre>
<h3 id="12-5-3-黑帽运算"><a href="#12-5-3-黑帽运算" class="headerlink" title="12.5.3　黑帽运算"></a>12.5.3　黑帽运算</h3><p>黑帽运算的运算过程如图12.19所示，让原图的闭运算图减去原图。因为闭运算抹除图像的内部细节，“无内部细节”的图像减去“有内部细节”的图像，得到的结果就只剩内部细节了，所以经过黑帽运算之后，小蜘蛛就只剩下斑点、花纹和眼睛了。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125195549507.png" alt="image-20211125195549507"></p>
<pre><code>                                                                              图12.19　黑帽运算过程
</code></pre>
<p>黑帽运算的参数为cv2.MORPH_BLACKHAT，下面通过一段代码实现图12.19的效果。</p>
<p>【实例12.7】　通过黑帽运算画出小蜘蛛身上的花纹。<br>使用5×5的核对小蜘蛛图像进行黑帽运算，具体代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125195624673.png" alt="image-20211125195624673"></p>
<p>上述代码的运行结果如图20所示。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125195644815.png" alt="image-20211125195644815"></p>
<pre><code>                                                                                图12.20　图像黑帽运算效果
</code></pre>
<h2 id="12-6-小结"><a href="#12-6-小结" class="headerlink" title="12.6　小结"></a>12.6　小结</h2><p>本章介绍的基础内容是腐蚀和膨胀。读者掌握了其用法，就能轻而易举地实现开运算和闭运算。其中，开运算是对图像先进行腐蚀操作，再进行膨胀操作，其作用是抹除图像外部的细节；而闭运算是对图像先进行膨胀操作，再进行腐蚀操作，其作用是抹除图像内部的细节。此外，形态学运算也是构建在腐蚀和膨胀的基础上的。其中，梯度运算是让原图的膨胀图减原图的腐蚀图，得到的结果是原图的轮廓；顶帽运算是让原图减原图的开运算图，得到的结果是图像的外部细节；黑帽运算是让原图的闭运算图减去原图，得到的结果是图像的内部细节。</p>
<h1 id="第13章-图形检测"><a href="#第13章-图形检测" class="headerlink" title="第13章　图形检测"></a>第13章　图形检测</h1><p>图形检测是计算机视觉的一项重要功能。通过图形检测可以分析图像中可能存在的形状，然后对这些形状进行描绘，如搜索并绘制图像的边缘，定位图像的位置，判断图像中有没有直线、圆形等。虽然图形检测涉及非常深奥的数学算法，但OpenCV已经将这些算法封装成简单的方法，开发者只要学会如何调用方法、调整参数即可很好地实现检测功能。<br>本章将介绍如何检测图像的形状、图像所占的区域，以及如何查找图像中出现的几何图形等。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125195758972.png" alt="image-20211125195758972"></p>
<h2 id="13-1-图像的轮廓"><a href="#13-1-图像的轮廓" class="headerlink" title="13.1　图像的轮廓"></a>13.1　图像的轮廓</h2><p>轮廓是指<strong>图像中图形或物体的外边缘线条</strong>。简单的几何图形轮廓是由平滑的线构成的，容易识别，但不规则图形的轮廓可能由许多个点构成，识别起来比较困难。<br>OpenCV提供的findContours()方法可以<strong>通过计算图像梯度来判断图像的边缘，然后将边缘的点封装成数组返回。</strong>findContours()方法的语法如下：</p>
<pre><code> contours, hierarchy = cv2.findContours(image, mode, methode)
</code></pre>
<p>参数说明：　</p>
<p>image：被检测的图像，必须是8位单通道二值图像。如果原始图像是彩色图像，必须转为灰度图像，并经过二值化处理。　</p>
<p>mode：轮廓的检索模式，具体值如表13.1所示。</p>
<pre><code>                                                                                          表13.1　轮廓的检索模式参数值
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125195942347.png" alt="image-20211125195942347"></p>
<p>methode：</p>
<p>检测轮廓时使用的方法，具体值如表13.2所示。</p>
<pre><code>                                                                                        表13.2　检测轮廓时使用的方法
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125200003759.png" alt="image-20211125200003759"></p>
<p>返回值说明：　</p>
<p>contours：检测出的所有轮廓，list类型，每一个元素都是某个轮廓的像素坐标数组。　</p>
<p>hierarchy：轮廓之间的层次关系。<br>通过findContours()方法找到图像轮廓后，为了方便开发人员观测，最好能把轮廓画出来，于是OpenCV提供了drawContours()方法用来绘制这些轮廓。drawContours()方法的语法如下：</p>
<pre><code> image = cv2.drawContours(image, contours, contourIdx, color, thickness, lineTypee, hierarchy, maxLevel, offse)
</code></pre>
<p>参数说明：</p>
<p>image：被绘制轮廓的原始图像，可以是多通道图像。　</p>
<p>contours：findContours()方法得出的轮廓列表。　</p>
<p>contourIdx：绘制轮廓的索引，如果为-1则绘制所有轮廓。　</p>
<p>color：绘制颜色，使用BGR格式。　</p>
<p>thickness：可选参数，画笔的粗细程度，如果该值为-1则绘制实心轮廓。　</p>
<p>lineTypee：可选参数，绘制轮廓的线型。　</p>
<p>hierarchy：可选参数，findContours()方法得出的层次关系。　</p>
<p>maxLevel：可选参数，绘制轮廓的层次深度，最深绘制第maxLevel层。　</p>
<p>offse：可选参数，偏移量，可以改变绘制结果的位置。</p>
<p>返回值说明：</p>
<p>image：同参数中的image，执行后原始图中就包含绘制的轮廓了，可以不使用此返回值保存结果。</p>
<p>【实例13.1】　绘制几何图像的轮廓。<br>将如图13.1所示的几何图像转换成二值灰度图像，然后通过findContours()方法找到出现的所有轮廓，再通过drawContours()方法将这些轮廓绘制成红色。轮廓的检索模式采用cv2.RETR_LIST，检测方法采用cv2.CHAIN_APPROX_NONE。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125200104772.png" alt="image-20211125200104772"></p>
<pre><code>                                                                             图13.1　简单的几何图像
</code></pre>
<p>具体代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125200222796.png" alt="image-20211125200222796"></p>
<p>上述代码的运行结果如图13.2所示。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125200313470.png" alt="image-20211125200313470"></p>
<pre><code>                                                                                       图13.2　绘制全部轮廓
</code></pre>
<p>如果使用cv2.RETR_EXTERNAL做参数则只绘制外轮廓，关键代码如下：</p>
<pre><code> contours, hierarchy = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
 cv2.drawContours(img, contours, -1, (0, 0, 255), 5)
</code></pre>
<p>绘制轮廓的效果如图13.3所示。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125200347818.png" alt="image-20211125200347818"></p>
<pre><code>                                                                           图13.3　只绘制外轮廓的效果
</code></pre>
<p>drawContours()方法的第3个参数可以指定绘制哪个索引的轮廓。索引的顺序由轮廓的检索模式决定，例如cv2.RETR_CCOMP模式下绘制索引为0的轮廓的关键代码如下：</p>
<pre><code> contours, hierarchy = cv2.findContours(binary, cv2.RETR_CCOMP, cv2.CHAIN_APPROX_NONE)
 cv2.drawContours(img, contours, 0, (0, 0, 255), 5)
</code></pre>
<p>在同样的检索模式下，绘制索引为1的轮廓的关键代码如下：</p>
<pre><code> cv2.drawContours(img, contours, 1, (0, 0, 255), 5)
</code></pre>
<p>绘制索引为2的轮廓的关键代码如下：</p>
<pre><code> cv2.drawContours(img, contours, 2, (0, 0, 255), 5)
</code></pre>
<p>绘制索引为3的轮廓的关键代码如下：</p>
<pre><code> cv2.drawContours(img, contours, 3, (0, 0, 255), 5)
</code></pre>
<p>绘制的效果如图13.4～图13.7所示。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125200419734.png" alt="image-20211125200419734"></p>
<pre><code>                                                                             图13.4　绘制索引为0的轮廓
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125200519831.png" alt="image-20211125200519831"></p>
<pre><code>                                                                      图13.5　绘制索引为1的轮廓
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125200538416.png" alt="image-20211125200538416"></p>
<pre><code>                                                                        图13.6　绘制索引为2的轮廓
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125200557884.png" alt="image-20211125200557884"></p>
<pre><code>                                                                               图13.7　绘制索引为3的轮廓
</code></pre>
<p>【实例13.2】　绘制花朵的轮廓。<br>为图13.8（a）所示的花朵图像绘制轮廓，首先要降低图像中的噪声干扰，进行滤波处理，然后将图像处理成二值灰度图像，并检测出轮廓，最后利用绘制轮廓的方法在原始图像中绘制轮廓。<br>具体代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125200623625.png" alt="image-20211125200623625"></p>
<p>上述代码的运行结果如图13.8（b）和图13.8（c）所示。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125200704091.png" alt="image-20211125200704091"></p>
<pre><code>                                                                              图12.8　绘制花朵轮廓效果
</code></pre>
<h2 id="13-2-轮廓拟合"><a href="#13-2-轮廓拟合" class="headerlink" title="13.2　轮廓拟合"></a>13.2　轮廓拟合</h2><p>拟合是指将平面上的一系列点，用一条光滑的曲线连接起来。轮廓的拟合就是将凹凸不平的轮廓用平整的几何图形体现出来。本节将介绍如何按照轮廓绘制矩形包围框和圆形包围框。</p>
<h3 id="13-2-1-矩形包围框"><a href="#13-2-1-矩形包围框" class="headerlink" title="13.2.1　矩形包围框"></a>13.2.1　矩形包围框</h3><p>矩形包围框是指图像轮廓的最小矩形边界。OpenCV提供的boundingRect()方法可以自动计算轮廓最小矩形边界的坐标、宽和高。boundingRect()方法的语法如下：</p>
<pre><code> retval = cv2.boundingRect (array)
</code></pre>
<p>参数说明：　</p>
<p>array：轮廓数组。</p>
<p>返回值说明：</p>
<p>retval：元组类型，包含4个整数值，分别是最小矩形包围框的：左上角顶点的横坐标、左上角顶点的纵坐标、矩形的宽和高。所以也可以写成x, y, w, h &#x3D; cv2.boundingRect (array)的形式。</p>
<p>【实例13.3】　为爆炸图形绘制矩形包围框。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125200758268.png" alt="image-20211125200758268"></p>
<pre><code>                                                                                    图13.9　爆炸图形
</code></pre>
<p>为图13.9所示的爆炸图形绘制矩形包围框，首先判断图形的轮廓，使用cv2.RETR_LIST检索所有轮廓，使用cv2.CHAIN_APPROX_SIMPLE检索图形所有的端点，然后利用cv2.boundingRect()方法计算最小矩形包围框，并通过cv2.rectangle()方法将这个矩形绘制出来，具体代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125200901021.png" alt="image-20211125200901021"></p>
<p>上述代码的运行结果如图13.10所示。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125200917139.png" alt="image-20211125200917139"></p>
<pre><code>                                                                            图13.10　爆炸图形的最小矩形包围框
</code></pre>
<h3 id="13-2-2-圆形包围框"><a href="#13-2-2-圆形包围框" class="headerlink" title="13.2.2　圆形包围框"></a>13.2.2　圆形包围框</h3><p>圆形包围框与矩形包围框一样，是图像轮廓的最小圆形边界。OpenCV提供的minEnclosingCircle ()方法可以自动计算轮廓最小圆形边界的圆心和半径。minEnclosingCircle()方法的语法如下：</p>
<pre><code> center, radius = cv2.minEnclosingCircle(points)
</code></pre>
<p>参数说明：　</p>
<p>points：轮廓数组。</p>
<p>返回值说明：　</p>
<p>center：元组类型，包含2个浮点值，是最小圆形包围框圆心的横坐标和纵坐标。　</p>
<p>radius：浮点类型，最小圆形包围框的半径。</p>
<p>【实例13.4】　为爆炸图形绘制圆形包围框。<br>为图13.9所示的爆炸图形绘制矩形包围框，首先判断图形的轮廓，使用cv2.RETR_LIST检索所有轮廓，使用cv2.CHAIN_APPROX_SIMPLE检索图形所有的端点，然后利用cv2. minEnclosingCircle()方法计算最小圆形包围框，并通过cv2.circle()方法将这个矩形绘制出来。绘制过程中要注意：圆心坐标和圆半径都是浮点数，在绘制之前要将浮点数转换成整数。<br>具体代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125201112737.png" alt="image-20211125201112737"></p>
<p>上述代码的运行结果如图13.11所示。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125201129231.png" alt="image-20211125201129231"></p>
<pre><code>                                                                            图13.11　爆炸图形的最小圆形包围框
</code></pre>
<h2 id="13-3-凸包"><a href="#13-3-凸包" class="headerlink" title="13.3　凸包"></a>13.3　凸包</h2><p>之前介绍了矩形包围框和圆形包围框，这2种包围框虽然已经逼近了图形的边缘，但这种包围框为了保持几何形状，<strong>与图形的真实轮廓贴合度较差</strong>。<strong>如果能找出图形最外层的端点，将这些端点连接起来，就可以围出一个包围图形的最小包围框，这种包围框叫凸包。</strong><br>凸包是最逼近轮廓的多边形，凸包的每一处都是凸出来的，也就是<strong>任意3个点组成的内角均小于180°。</strong>例如，图13.12就是凸包，而图13.13就不是凸包。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125205558522.png" alt="image-20211125205558522"></p>
<pre><code>                                                                                                图13.12　凸包
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125205619316.png" alt="image-20211125205619316"></p>
<pre><code>                                                                                              图13.13　不是凸包
</code></pre>
<p>OpenCV提供的convexHull()方法可以自动找出轮廓的凸包，该方法的语法如下：</p>
<pre><code> hull = cv2.convexHull(points, clockwise, returnPoints)
</code></pre>
<p>参数说明：　</p>
<p>points：轮廓数组。　</p>
<p>clockwise：可选参数，布尔类型。当该值为True时，凸包中的点按顺时针排列，为False时按逆时针排列。　</p>
<p>returnPoints：可选参数，布尔类型。当该值为True时返回点坐标，为False时返回点索引。默认值为True。</p>
<p>返回值说明：　</p>
<p>hull：凸包的点阵数组。<br>下面通过一个例子演示如何绘制凸包。</p>
<p>【实例13.5】　为爆炸图形绘制凸包。<br>为图13.9所示的爆炸图形绘制凸包，首先要先判断图形的轮廓，使用cv2.RETR_LIST检索出图形的轮廓，然后使用convexHull()方法找到轮廓的凸包，最后通过polylines()方法将凸包中各点连接起来，具体代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125205730374.png" alt="image-20211125205730374"></p>
<p>上述代码的运行结果如图13.14所示。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125205746309.png" alt="image-20211125205746309"></p>
<pre><code>                                                                                      图13.14　爆炸图形的凸包
</code></pre>
<h2 id="13-4-Canny边缘检测"><a href="#13-4-Canny边缘检测" class="headerlink" title="13.4　Canny边缘检测"></a>13.4　Canny边缘检测</h2><p>Canny边缘检测算法是John F. Canny于1986年开发的一个多级边缘检测算法，该算法根据像素的梯度变化寻找图像边缘，最终可以绘制十分精细的二值边缘图像。<br>OpenCV将Canny边缘检测算法封装在Canny()方法中，该方法的语法如下：</p>
<pre><code> edges = cv2.Canny(image, threshold1, threshold2, apertureSize, L2gradient)
</code></pre>
<p>参数说明：　</p>
<p>image：检测的原始图像。　</p>
<p>threshold1：计算过程中使用的第一个阈值，可以是最小阈值，也可以是最大阈值，通常用来设置最小阈值。　</p>
<p>threshold2：计算过程中使用的第二个阈值，通常用来设置最大阈值。　</p>
<p>apertureSize：可选参数，Sobel算子的孔径大小。　</p>
<p>L2gradient：可选参数，计算图像梯度的标识，默认值为False。值为True时采用更精准的算法进行计算。</p>
<p>返回值说明：　</p>
<p>edges：计算后得出的边缘图像，是一个二值灰度图像。</p>
<p>在开发过程中可以通过调整最小阈值和最大阈值控制边缘检测的精细程度。当2个阈值都较小时，检测出较多的细节；当2个阈值都较大时，忽略较多的细节。</p>
<p>【实例13.6】　使用Canny算法检测花朵边缘。<br>利用Canny()方法检测图13.15（a）所示的花朵图像，分别使用10和50、100和200、400和600作为最低阈值和最高阈值检测3次，具体代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125205855069.png" alt="image-20211125205855069"></p>
<p>上述代码的运行结果如图13.15所示，阈值越小，检测出的边缘越多；阈值越大，检测出的边缘越少，只能检测出一些较明显的边缘。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125205918990.png" alt="image-20211125205918990"></p>
<pre><code>                                                                               图13.15　图像Canny检测效果
</code></pre>
<h2 id="13-5-霍夫变换"><a href="#13-5-霍夫变换" class="headerlink" title="13.5　霍夫变换"></a>13.5　霍夫变换</h2><p>霍夫变换是一种特征检测，通过算法识别图像的特征，从而判断图像中的特殊形状，例如直线和圆。本节将介绍如何检测图像中的直线和圆。</p>
<h3 id="13-5-1-直线检测"><a href="#13-5-1-直线检测" class="headerlink" title="13.5.1　直线检测"></a>13.5.1　直线检测</h3><p>霍夫直线变换是通过霍夫坐标系的直线与笛卡儿坐标系的点之间的映射关系来判断图像中的点是否构成直线。OpenCV将此算法封装成两个方法，分别是cv2.HoughLines()和cv2.HoughLinesP()，前者用于检测无限延长的直线，后者用于检测线段。本节仅介绍比较常用的HoughLinesP()方法。<br>HoughLinesP()方法名称最后有一个大写的P，该方法只能检测二值灰度图像，也就是只有两种像素值的黑白图像。该方法最后把找出的所有线段的两个端点坐标保存成一个数组。<br>HoughLinesP()方法的语法如下：</p>
<pre><code> lines = cv2.HoughLinesP(image, rho, theta, threshold, minLineLength, maxLineGap)
</code></pre>
<p>参数说明：　</p>
<p>image：检测的原始图像。　</p>
<p>rho：检测直线使用的半径步长，值为1时，表示检测所有可能的半径步长。　</p>
<p>theta：搜索直线的角度，值为π&#x2F;180°时，表示检测所有角度。　</p>
<p>threshold：阈值，该值越小，检测出的直线就越多。　</p>
<p>minLineLength：线段的最小长度，小于该长度的线段不记录到结果中。　</p>
<p>maxLineGap：线段之间的最小距离。</p>
<p>返回值说明：</p>
<p>lines：一个数组，元素为所有检测出的线段，每条线段是一个数组，代表线段两个端点的横、纵坐标，格式为[[[x1, y1, x2, y2], [x1, y1, x2, y2]]]。注意<br>使用该方法前应该为原始图像进行降噪处理，否则会影响检测结果。</p>
<p>【实例13.7】　检测笔图像中出现的直线。</p>
<p>检测如图13.16所示的中性笔照片，先将图像降噪，再对图像进行边缘检测，然后利用HoughLinesP()方法找出边缘图像中的直线线段，最后用cv2.line()方法将找出的线段绘制成红色。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211125210047560.png" alt="image-20211125210047560"></p>
<pre><code>                                                                                            图13.16　笔图像
</code></pre>
<p>具体代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211126130401949.png" alt="image-20211126130401949"></p>
<p>上述代码的运行结果如图13.17和图13.18所示。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211126130420890.png" alt="image-20211126130420890"></p>
<pre><code>                                                                               图13.17　笔图像的边缘检测结果
</code></pre>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211126130515954.png" alt="image-20211126130515954"></p>
<pre><code>                                                                     图13.18　将笔图像中检测出的线段描红
</code></pre>
<h3 id="13-5-2-圆环检测"><a href="#13-5-2-圆环检测" class="headerlink" title="13.5.2　圆环检测"></a>13.5.2　圆环检测</h3><p>霍夫圆环变换的原理与霍夫直线变换类似。OpenCV提供的HoughCircles()方法用于检测图像中的圆环，该方法在检测过程中进行两轮筛选：第一轮筛选找出可能是圆的圆心坐标，第二轮筛选计算这些圆心坐标可能对应的半径长度。该方法最后将圆心坐标和半径封装成一个浮点型数组。<br>HoughCircles()方法的语法如下：</p>
<pre><code> circles = cv2.HoughCircles(image, method, dp, minDist, param1, param2, minRadius, maxRadius)
</code></pre>
<p>参数说明：　</p>
<p>image：检测的原始图像。　</p>
<p>method：检测方法，OpenCV 4.0.0及以前版本仅提供了cv2.HOUGH_GRADIENT作为唯一可用方法。　</p>
<p>dp：累加器分辨率与原始图像分辨率之比的倒数。值为1时，累加器与原始图像具有相同的分辨率；值为2时，累加器的分辨率为原始图像的1&#x2F;2。通常使用1作为参数。　</p>
<p>minDist：圆心之间的最小距离。　</p>
<p>param1：可选参数，Canny边缘检测使用的最大阈值。　</p>
<p>param2：可选参数，检测圆环结果的投票数。第一轮筛选时投票数超过该值的圆环才会进入第二轮筛选。值越大，检测出的圆环越少，但越精准。　</p>
<p>minRadius：可选参数，圆环的最小半径。　</p>
<p>maxRadius：可选参数，圆环的最大半径。</p>
<p>返回值说明：　</p>
<p>circles：一个数组，元素为所有检测出的圆环，每个圆环也是一个数组，内容为圆心的横、纵坐标和半径长度，格式为：[[[x1 ,y1, r1], [x2 ,y2, r2]]]。</p>
<p>注意<br>使用该方法前应该为原始图像进行降噪处理，否则会影响检测结果。</p>
<p>【实例13.8】　检测硬币图像中出现的圆环。<br>检测如图13.19所示的硬币照片，先将图像降噪，再将图像变成单通道灰度图像，然后利用HoughCircles()方法检测图像中可能是圆环的位置，最后通过cv2.circle()方法在这些位置上绘制圆环和对应的圆心。在绘制圆环之前，要将HoughCircles()方法返回的浮点数组元素转换成整数。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211126130634358.png" alt="image-20211126130634358"></p>
<pre><code>                                                                                                   图13.19　硬币图像
</code></pre>
<p>具体代码如下：</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211126130715358.png" alt="image-20211126130715358"></p>
<p>上述代码的运行结果如图13.20所示。</p>
<p><img src="http://127.0.0.1:8000/static/stu/OpenCV%E8%BF%9B%E9%98%B6%E7%AF%87.assets/image-20211126130658457.png" alt="image-20211126130658457"></p>
<pre><code>                                                                                               图13.20　检测出的圆环位置
</code></pre>
<h2 id="13-6-小结"><a href="#13-6-小结" class="headerlink" title="13.6　小结"></a>13.6　小结</h2><p>图像轮廓指的是将图像的边缘连接起来形成的一个整体，它是图像的一个重要的特征信息，通过对图像的轮廓进行操作，能够得到这幅图像的大小、位置和方向等信息，用于后续的计算。为此，OpenCV提供了findContours()方法，通过计算图像的梯度，判断图像的轮廓。为了绘制图像的轮廓，OpenCV又提供了drawContours()方法。但需要注意的是，Canny()方法虽然能够检测出图像的边缘，但这个边缘是不连续的。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/%E7%AE%97%E6%B3%95/">算法</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-算法+计算机基础/7种常用的排序算法总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/28/%E7%AE%97%E6%B3%95+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/7%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" class="article-date">
  	<time datetime="2020-06-28T08:34:23.000Z" itemprop="datePublished">2020-06-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/28/%E7%AE%97%E6%B3%95+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/7%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">
        图解前端性能优化
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>排序算法</strong>：一种能将一串数据依照特定的排序方式进行排列的一种算法。<br><strong>排序算法性能</strong>：取决于时间和空间复杂度，其次还得考虑稳定性，及其适应的场景。<br><strong>稳定性</strong>：让原本有相等键值的记录维持相对次序。也就是若一个排序算法是稳定的，当有俩个相等键值的记录R和S，且原本的序列中R在S前，那么排序后的列表中R应该也在S之前。</p>
<hr>
<h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1-冒泡排序"></a><strong>1-冒泡排序</strong></h3><p><strong>原理</strong><br>俩俩比较相邻记录的排序码，若发生逆序，则交换；有俩种方式进行冒泡，一种是先把小的冒泡到前边去，另一种是把大的元素冒泡到后边。冒泡法大家都较熟悉。其原理为从a[0]开始，依次将其和后面的元素比较,若a[0]&gt;a[i]，则交换它们，一直比较到a[n]。同理对a<a target="_blank" rel="noopener" href="http://images.cnitblog.com/blog/441348/201301/18154959-d81ff153bc6647e49d6296303d6e6484.jpg">1</a>,a<a target="_blank" rel="noopener" href="http://images.cnitblog.com/blog/441348/201301/18160646-f229ab053232408fbf80b9f2d1737e28.jpg">2</a>,…a[n-1]处理，即完成排序</p>
<p><strong>冒泡排序的基本概念：</strong></p>
<p>依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。至此第一趟结束，将最大的数放到了最后。在第二趟：仍从第一对数开始比较（因为可能由于第2个数和第3个数的交换，使得第1个数不再小于第2个数），将小数放前，大数放后，一直比较到倒数第二个数（倒数第一的位置上已经是最大的），第二趟结束，在倒数第二的位置上得到一个新的最大数（其实在整个数列中是第二大的数）。如此下去，重复以上过程，直至最终完成排序。由于在排序过程中总是小数往前放，大数往后放，相当于气泡往上升，所以称作冒泡排序。</p>
<p><strong>实现：</strong></p>
<p>外循环变量设为i，内循环变量设为j。假如有10个数需要进行排序，则外循环重复9次，内循环依次重复9，8，…，1次。每次进行比较的两个元素都是与内循环j有关的，它们可以分别用a[j]和a[j+1]标识，i的值依次为1,2,…,9，对于每一个i,j的值依次为1,2,…10-i。</p>
<p>图示：<br><img src="http://images.cnitblog.com/blog/441348/201301/18154959-d81ff153bc6647e49d6296303d6e6484.jpg" alt="此处输入图片的描述"></p>
<p><strong>性能</strong><br>时间复杂度为O(N^2)，空间复杂度为O(1)。排序是稳定的，排序比较次数与初始序列无关，但交换次数与初始序列有关。</p>
<p><strong>优化</strong><br>若初始序列就是排序好的，对于冒泡排序仍然还要比较O(N^2)次，但无交换次数。可根据这个进行优化，设置一个flag，当在一趟序列中没有发生交换，则该序列已排序好，但优化后排序的时间复杂度没有发生量级的改变</p>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void sort(int *a,int len)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,t;</span><br><span class="line">    </span><br><span class="line">    for( i = 0;i&lt;len-1;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j = 0;j&lt;len-1-i;++j) 或者 j=i+1;j&lt;len;++j</span><br><span class="line">        &#123;</span><br><span class="line">            if(a[j] &gt;a[j+1])</span><br><span class="line">            &#123;</span><br><span class="line">                t  = a[j];</span><br><span class="line">                a[j] = a[j+1];</span><br><span class="line">                a[j+1] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[6] = &#123;10,2,8,-8,11,0&#125;;</span><br><span class="line">    int i = 0;</span><br><span class="line">    sort(a,6);</span><br><span class="line">    </span><br><span class="line">    for(i = 0; i&lt;6;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d &quot;,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>冒泡法原理简单，但其缺点是交换次数多，效率低。下面介绍一种源自冒泡法但更有效率的方法“选择法”。</p>
<hr>
<h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2-选择排序"></a><strong>2-选择排序</strong></h3><p><strong>原理</strong><br>每次从未排序的序列中找到最小值，记录并最后存放到已排序序列的末尾.选择法循环过程与冒泡法一致，它还定义了记号k&#x3D;i,然后依次把a[k]同后面元素比较，若a[k]&gt;a[j],则使k&#x3D;j.最后看看k&#x3D;i是否还成立，不成立则交换a[k],a[i],这样就比冒泡法省下许多无用的交换，提高了效率。</p>
<p><strong>性能</strong><br>时间复杂度为O(N^2)，空间复杂度为O(1)，排序是不稳定的（把最小值交换到已排序的末尾导致的），每次都能确定一个元素所在的最终位置，比较次数与初始序列无关。</p>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//直接选择排序</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void sort(int *a,int len)</span><br><span class="line">&#123;</span><br><span class="line">	int i,j,min,t;</span><br><span class="line"></span><br><span class="line">	for(i = 0;i&lt;len-1;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		for(min=i,j=i+1;j&lt;len;++j)</span><br><span class="line">		&#123;</span><br><span class="line">			if(a[min]&gt;a[j])</span><br><span class="line">				min = j;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if(min!=i)</span><br><span class="line">		&#123;</span><br><span class="line">			t = a[i];</span><br><span class="line">			a[i] = a[min];</span><br><span class="line">			a[min] = t;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	int a[6] = &#123;4,0,3,2,5,1&#125;;</span><br><span class="line"></span><br><span class="line">	sort(a,6);//a代表数组的首地址</span><br><span class="line"></span><br><span class="line">	for(int i=0;i&lt;6;++i)</span><br><span class="line">		printf(&quot;%d\n&quot;,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>选择法比冒泡法效率更高，但说到高效率，非“快速法”莫属，现在就让我们来了解它。</p>
<hr>
<h3 id="3-快速排序"><a href="#3-快速排序" class="headerlink" title="3-快速排序"></a><strong>3-快速排序</strong></h3><p><strong>原理</strong><br>基本思想：</p>
<p>快速排序是对冒泡排序的一种改进。由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p><strong>实现：</strong><br>设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用第一个数据）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。</p>
<p><strong>一趟快速排序的算法是：</strong><br>1）设置两个变量i、j，排序开始的时候：i&#x3D;0，j&#x3D;N-1；<br>2）以第一个数组元素作为关键数据，赋值给key，即 key&#x3D;A[0]；<br>3）从j开始向前搜索，即由后开始向前搜索（j – ），找到第一个小于key的值A[j]，A[i]与A[j]交换；<br>4）从i开始向后搜索，即由前开始向后搜索（i ++ ），找到第一个大于key的A[i]，A[i]与A[j]交换；<br>5）重复第3、4、5步，直到 I&#x3D;J； (3,4步是在程序中没找到时候j&#x3D;j-1，i&#x3D;i+1，直至找到为止。找到并交换的时候i， j指针位置不变。另外当i&#x3D;j这过程一定正好是i+或j-完成的最后令循环结束。）</p>
<p>图示：<br><img src="http://images.cnitblog.com/blog/441348/201301/18160646-f229ab053232408fbf80b9f2d1737e28.jpg" alt="此处输入图片的描述"></p>
<p><strong>举例说明：</strong></p>
<p>如无序数组[6 2 4 1 5 9]</p>
<ul>
<li>a),先把第一项[6]取出来,<ul>
<li>用[6]依次与其余项进行比较,</li>
<li>如果比[6]小就放[6]前边,2 4 1 5都比[6]小,所以全部放到[6]前边</li>
<li>如果比[6]大就放[6]后边,9比[6]大,放到[6]后边,&#x2F;&#x2F;6出列后大喝一声,比我小的站前边,比我大的站后边,行动吧!霸气十足~</li>
</ul>
</li>
</ul>
<p><strong>一趟排完后变成下边这样:</strong></p>
<ul>
<li>排序前 6 2 4 1 5 9</li>
<li>排序后 2 4 1 5 6 9</li>
</ul>
<p>b),对前半拉[2 4 1 5]继续进行快速排序</p>
<p><strong>重复步骤a)后变成下边这样:</strong></p>
<ul>
<li>排序前 2 4 1 5</li>
<li>排序后 1 2 4 5</li>
</ul>
<p><strong>前半拉排序完成,总的排序也完成:</strong></p>
<ul>
<li>排序前:[6 2 4 1 5 9]</li>
<li>排序后:[1 2 4 5 6 9]</li>
</ul>
<p><strong>性能</strong><br>快排的平均时间复杂度为O(NlogN），空间复杂度为O(logN)，但最坏情况下，时间复杂度为O(N^2)，空间复杂度为O(N)；且排序是不稳定的，但每次都能确定一个元素所在序列中的最终位置，复杂度与初始序列有关。</p>
<p>优化<br>当初始序列是非递减序列时，快排性能下降到最坏情况，主要因为基准每次都是从最左边取得，这时每次只能排好一个元素。<br>所以快排的优化思路如下：</p>
<p>优化基准，不每次都从左边取，可以进行三路划分，分别取最左边，中间和最右边的中间值，再交换到最左边进行排序；或者进行随机取得待排序数组中的某一个元素，再交换到最左边，进行排序。<br>在规模较小情况下，采用直接插入排序<br>代码</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//快速排序</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int FindPos(int * a, int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">	int val = a[low];</span><br><span class="line"></span><br><span class="line">	while (low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		while (low&lt;high  &amp;&amp; a[high]&gt;=val)</span><br><span class="line">			--high;</span><br><span class="line">		a[low] = a[high];</span><br><span class="line"></span><br><span class="line">		while (low&lt;high &amp;&amp; a[low]&lt;=val)</span><br><span class="line">			++low;</span><br><span class="line">		a[high] = a[low];</span><br><span class="line">	&#125;//终止while循环之后low和high一定是相等的</span><br><span class="line"></span><br><span class="line">	a[low] = val; </span><br><span class="line"></span><br><span class="line">	return high; //high可以改为low, 但不能改为val 也不能改为a[low]  也不能改为a[high]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void QuickSort(int *a,int low,int high)</span><br><span class="line">&#123;</span><br><span class="line">	int pos;</span><br><span class="line"></span><br><span class="line">	if(low&lt;high)</span><br><span class="line">	&#123;</span><br><span class="line">		pos = FindPos(a,low,high);//找到a数组下标low-high  </span><br><span class="line">		QuickSort(a,low,pos-1);//把元素劈成两半  左半边</span><br><span class="line">		QuickSort(a,pos+1,high);//右半边</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	int a[6] = &#123;2,1,3,0,5,4&#125;;</span><br><span class="line"></span><br><span class="line">	QuickSort(a,0,5);//0表示第一个元素下标 5表示最后一个元素的下标</span><br><span class="line">	</span><br><span class="line">	for(i = 0;i&lt;6;++i)</span><br><span class="line">		printf(&quot;%d\n&quot;,a[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-插入排序"><a href="#4-插入排序" class="headerlink" title="4-插入排序"></a><strong>4-插入排序</strong></h3><p><strong>原理</strong><br>依次选择一个待排序的数据，插入到前边已排好序的序列中。</p>
<p><strong>性能</strong><br>时间复杂度为O(N^2)，空间复杂度为O(1)。算法是稳定的，比较次数和交换次数都与初始序列有关。</p>
<p><strong>优化</strong><br>直接插入排序每次往前插入时，是按顺序依次往前找，可在这里进行优化，往前找合适的插入位置时采用二分查找的方式，即折半插入。<br>折半插入排序相对直接插入排序而言：平均性能更快，时间复杂度降至O(NlogN)，排序是稳定的，但排序的比较次数与初始序列无关，总是需要foor(log(i))+1次排序比较。</p>
<p><strong>使用场景</strong><br>当数据基本有序时，采用插入排序可以明显减少数据交换和数据移动次数，进而提升排序效率</p>
<p><strong>代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void insert_sort(int *a,int n) </span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line">    </span><br><span class="line">    int i,j,temp; </span><br><span class="line">    </span><br><span class="line">    for(i=1;i&lt;n;i++) </span><br><span class="line">    &#123; </span><br><span class="line">    </span><br><span class="line">        temp=a[i]; /*temp为要插入的元素*/ </span><br><span class="line">        </span><br><span class="line">        j=i-1; </span><br><span class="line">        </span><br><span class="line">        while(j&gt;=0&amp;&amp;temp&lt;a[j]) </span><br><span class="line">        &#123; </span><br><span class="line">            /*从a[i-1]开始找比a[i]小的数，同时把数组元素向后移*/ </span><br><span class="line">            </span><br><span class="line">            a[j+1]=a[j]; </span><br><span class="line">            </span><br><span class="line">            j--; </span><br><span class="line">    </span><br><span class="line">        &#125; </span><br><span class="line">    </span><br><span class="line">         a[j+1]=temp; /*插入*/ </span><br><span class="line">    </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-希尔排序"><a href="#5-希尔排序" class="headerlink" title="5-希尔排序"></a><strong>5-希尔排序</strong></h3><p><strong>原理</strong></p>
<p>Shell法是一个叫 shell 的美国人与1969年发明的。它首先把相距k(k&gt;&#x3D;1)的那几个元素排好序，再缩小k值（一般取其一半），再排序，直到k&#x3D;1时完成排序</p>
<p>插入排序的改进版，是基于插入排序的以下俩点性质而提出的改进方法：</p>
<ul>
<li>插入排序对几乎已排好序的数据操作时，效率很高，可以达到线性排序的效率。</li>
<li>但插入排序在每次往前插入时只能将数据移动一位，效率比较低。</li>
</ul>
<p><strong>性能</strong><br>开始时，gap取值较大，子序列中的元素较少，排序速度快，克服了直接插入排序的缺点；其次，gap值逐渐变小后，虽然子序列的元素逐渐变多，但大多元素已基本有序，所以继承了直接插入排序的优点，能以近线性的速度排好序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void shell_sort(int *a,int n) </span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">    int i,j,k,x; </span><br><span class="line">    </span><br><span class="line">    k=n/2; /*间距值*/ </span><br><span class="line">    </span><br><span class="line">    while(k&gt;=1) </span><br><span class="line">    &#123; </span><br><span class="line">    </span><br><span class="line">        for(i=k;i&lt;n;i++)</span><br><span class="line">        &#123; </span><br><span class="line">        </span><br><span class="line">                x=a[i]; </span><br><span class="line">                </span><br><span class="line">                j=i-k; </span><br><span class="line">                </span><br><span class="line">                while(j&gt;=0&amp;&amp;x&lt;a[j]) </span><br><span class="line">                &#123; </span><br><span class="line">                    </span><br><span class="line">                    a[j+k]=a[j]; </span><br><span class="line">                    </span><br><span class="line">                    j-=k; </span><br><span class="line">                &#125; </span><br><span class="line">                </span><br><span class="line">                   a[j+k]=x;    </span><br><span class="line">                </span><br><span class="line">        &#125; </span><br><span class="line">                </span><br><span class="line">                k/=2; /*缩小间距值*/ </span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6-归并排序"></a><strong>6-归并排序</strong></h3><p><strong>原理</strong></p>
<p><strong>分而治之思想：</strong></p>
<ul>
<li>Divide：将n个元素平均划分为各含n&#x2F;2个元素的子序列；</li>
<li>Conquer：递归的解决俩个规模为n&#x2F;2的子问题；</li>
<li>Combine：合并俩个已排序的子序列。</li>
</ul>
<p><strong>性能</strong><br>时间复杂度总是为O(NlogN)，空间复杂度也总为为O(N)，算法与初始序列无关，排序是稳定的。</p>
<p><strong>优化</strong><br><strong>优化思路：</strong></p>
<ul>
<li>在规模较小时，合并排序可采用直接插入；</li>
<li>在写法上，可以在生成辅助数组时，俩头小，中间大，这时不需要再在后边加俩个while循环进行判断，只需一次比完</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">//归并排序</span><br><span class="line">void merge(int arr[],int temp_arr[],int left,int mid, int right)&#123;</span><br><span class="line">    //简单归并：先复制到temp_arr，再进行归并</span><br><span class="line">    for (int i = left; i &lt;= right; i++)&#123;</span><br><span class="line">        temp_arr[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int pa = left, pb = mid + 1;</span><br><span class="line">    int index = left;</span><br><span class="line">    while (pa &lt;= mid &amp;&amp; pb &lt;= right)&#123;</span><br><span class="line">        if (temp_arr[pa] &lt;= temp_arr[pb])&#123;</span><br><span class="line">            arr[index++] = temp_arr[pa++];</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            arr[index++] = temp_arr[pb++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(pa &lt;= mid)&#123;</span><br><span class="line">        arr[index++] = temp_arr[pa++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (pb &lt;= right)&#123;</span><br><span class="line">        arr[index++] = temp_arr[pb++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void merge_improve(int arr[], int temp_arr[], int left, int mid, int right)&#123;</span><br><span class="line">    //优化归并：复制时，俩头小，中间大，一次比较完</span><br><span class="line">    for (int i = left; i &lt;= mid; i++)&#123;</span><br><span class="line">        temp_arr[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = mid + 1; i &lt;= right; i++)&#123;</span><br><span class="line">        temp_arr[i] = arr[right + mid + 1 - i];</span><br><span class="line">    &#125;</span><br><span class="line">    int pa = left, pb = right, p = left;</span><br><span class="line">    while (p &lt;= right)&#123;</span><br><span class="line">        if (temp_arr[pa] &lt;= temp_arr[pb])&#123;</span><br><span class="line">            arr[p++] = temp_arr[pa++];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            arr[p++] = temp_arr[pb--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void merge_sort(int arr[],int temp_arr[], int left, int right)&#123;</span><br><span class="line">    if (left &lt; right)&#123;</span><br><span class="line">        int mid = (left + right) / 2;</span><br><span class="line">        merge_sort(arr,temp_arr,0, mid);</span><br><span class="line">        merge_sort(arr, temp_arr,mid + 1, right);</span><br><span class="line">        merge(arr,temp_arr,left,mid,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void merge_sort(int arr[], int len)&#123;</span><br><span class="line">    int *temp_arr = (int*)malloc(sizeof(int)*len);</span><br><span class="line">    merge_sort(arr,temp_arr, 0, len - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7-堆排序"></a><strong>7-堆排序</strong></h3><p><strong>原理</strong></p>
<p><strong>堆的性质：</strong></p>
<ul>
<li>是一棵完全二叉树</li>
<li>每个节点的值都大于或等于其子节点的值，为最大堆；反之为最小堆。</li>
</ul>
<p><strong>堆排序思想：</strong></p>
<ul>
<li>将待排序的序列构造成一个最大堆，此时序列的最大值为根节点</li>
<li>依次将根节点与待排序序列的最后一个元素交换</li>
<li>再维护从根节点到该元素的前一个节点为最大堆，如此往复，最终得到一个递增序列</li>
</ul>
<p><strong>性能</strong><br>时间复杂度为O(NlogN)，空间复杂度为O(1)，因为利用的排序空间仍然是初始的序列，并未开辟新空间。算法是不稳定的，与初始序列无关。</p>
<p><strong>使用场景</strong><br>想知道最大值或最小值时，比如优先级队列，作业调度等场景。</p>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 将数组arr构建大根堆</span><br><span class="line">     * @param arr 待调整的数组</span><br><span class="line">     * @param i   待调整的数组元素的下标</span><br><span class="line">     * @param len 数组的长度</span><br><span class="line">     */</span><br><span class="line">    void heap_adjust(int arr[], int i, int len)</span><br><span class="line">    &#123;</span><br><span class="line">        int child;</span><br><span class="line">        int temp;</span><br><span class="line">    </span><br><span class="line">        for (; 2 * i + 1 &lt; len; i = child)</span><br><span class="line">        &#123;</span><br><span class="line">            child = 2 * i + 1;  // 子结点的位置 = 2 * 父结点的位置 + 1</span><br><span class="line">            // 得到子结点中键值较大的结点</span><br><span class="line">            if (child &lt; len - 1 &amp;&amp; arr[child + 1] &gt; arr[child])</span><br><span class="line">                child ++;</span><br><span class="line">            // 如果较大的子结点大于父结点那么把较大的子结点往上移动，替换它的父结点</span><br><span class="line">            if (arr[i] &lt; arr[child])</span><br><span class="line">            &#123;</span><br><span class="line">                temp = arr[i];</span><br><span class="line">                arr[i] = arr[child];</span><br><span class="line">                arr[child] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 堆排序算法</span><br><span class="line">     */</span><br><span class="line">    void heap_sort(int arr[], int len)</span><br><span class="line">    &#123;</span><br><span class="line">        int i;</span><br><span class="line">        // 调整序列的前半部分元素，调整完之后第一个元素是序列的最大的元素</span><br><span class="line">        for (int i = len / 2 - 1; i &gt;= 0; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            heap_adjust(arr, i, len);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        for (i = len - 1; i &gt; 0; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            // 将第1个元素与当前最后一个元素交换，保证当前的最后一个位置的元素都是现在的这个序列中最大的</span><br><span class="line">            int temp = arr[0];</span><br><span class="line">            arr[0] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">            // 不断缩小调整heap的范围，每一次调整完毕保证第一个元素是当前序列的最大值</span><br><span class="line">            heap_adjust(arr, 0, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-python/python基础" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/05/03/python/python%E5%9F%BA%E7%A1%80/" class="article-date">
  	<time datetime="2020-05-03T11:17:48.000Z" itemprop="datePublished">2020-05-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/03/python/python%E5%9F%BA%E7%A1%80/">
        python基础总结
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>最近需要用<code>python</code>做数据分析，决定开始学<code>python</code>，总结一些基础笔记</p>
</blockquote>
<h2 id="一、导语"><a href="#一、导语" class="headerlink" title="一、导语"></a>一、导语</h2><ul>
<li><p><code>python</code>是解析性语言</p>
</li>
<li><p>&#96;&#96;&#96;<br>python</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  能做什么</span><br><span class="line"></span><br><span class="line">  - 大数据分析</span><br><span class="line">  - 自动化运维与自动化测试</span><br><span class="line">  - web开发：`flask`、`jdango`</span><br><span class="line">  - 机器学习 `TensorFlow`</span><br><span class="line">  - 胶水语言：如混合c++、java编程，能够把其他语法编写的模块连接在一起</span><br><span class="line"></span><br><span class="line">**Python语言的特点**</span><br><span class="line"></span><br><span class="line">- 语法简洁</span><br><span class="line">- 可跨平台</span><br><span class="line">- 应用广泛</span><br><span class="line">- 支持中文</span><br><span class="line">- 强制可读：通过强制缩进体现语句间的逻辑关系提高了程序的可读性</span><br><span class="line">- 模式多样：语法层面同时支持面向过程和面向对象两种编程方式</span><br><span class="line">- 粘性扩展：通过接口和函数集成其他语言编写的代码</span><br><span class="line">- 开源理念</span><br><span class="line">- 库类丰富</span><br><span class="line"></span><br><span class="line">**Python语言开发环境配置**</span><br><span class="line"></span><br><span class="line">- `Python`解释器</span><br><span class="line">- `IDLE`开发环境</span><br><span class="line">- 交互式启动</span><br><span class="line">- 文件式启动</span><br><span class="line">- `Python`语言集成开发环境——`PyCharm`</span><br><span class="line"></span><br><span class="line">## 二、基本知识</span><br><span class="line"></span><br><span class="line">### 注释</span><br><span class="line"></span><br><span class="line">- 注释是辅助性文字，不被执行</span><br><span class="line">- 单行注释：以`#`开头</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>#这是注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 多行注释：以`&#x27;&#x27;&#x27;`(3个单引号)开头和结尾</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>‘’’<br>这是注释<br>这也是注释<br>这还是注释<br>‘’’</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 命名</span><br><span class="line"></span><br><span class="line">- 命名是为变量关联标识符的过程，用于确保程序元素的唯一性</span><br><span class="line">- 标识符由字母、数字、下划线（和汉字）等字符及其组合构成</span><br><span class="line">- 标识符的首字符不能是数字 ，且中间不能出现空格</span><br><span class="line">- 标识符对大小写敏感</span><br><span class="line"></span><br><span class="line">### 保留字</span><br><span class="line"></span><br><span class="line">- 保留字（`Keyword`）也被称为关键字，是被编程语言内部定义并保留使用的标识符</span><br><span class="line">- `Python` 的标准库提供了一个 `keyword` 模块，可以输出当前版本的所有关键字：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>import keyword<br>ls&#x3D;keyword.kwlist<br>ls<br>len(ls)<br>33</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**Python 3 有33个保留字**</span><br><span class="line"></span><br><span class="line">- `True`</span><br><span class="line">- `False`</span><br><span class="line">- `None`</span><br><span class="line">- `and`</span><br><span class="line">- `as`</span><br><span class="line">- `assert`</span><br><span class="line">- `break`</span><br><span class="line">- `class`</span><br><span class="line">- `continue`</span><br><span class="line">- `def`</span><br><span class="line">- `del`</span><br><span class="line">- `elif`</span><br><span class="line">- `else`</span><br><span class="line">- `except`</span><br><span class="line">- `finally`</span><br><span class="line">- `for`</span><br><span class="line">- `from`</span><br><span class="line">- `global`</span><br><span class="line">- `if`</span><br><span class="line">- `import`</span><br><span class="line">- `in`</span><br><span class="line">- `is`</span><br><span class="line">- `lambda`</span><br><span class="line">- `nonlocal`</span><br><span class="line">- `not`</span><br><span class="line">- `or`</span><br><span class="line">- `pass`</span><br><span class="line">- `raise`</span><br><span class="line">- `return`</span><br><span class="line">- `try`</span><br><span class="line">- `while`</span><br><span class="line">- `with`</span><br><span class="line">- `yield`</span><br><span class="line"></span><br><span class="line">### input()函数</span><br><span class="line"></span><br><span class="line">- 使用`input()`函数从控制台获得用户输入</span><br><span class="line">- `input()`函数以字符串类型返回结果</span><br><span class="line"></span><br><span class="line">### eval()函数</span><br><span class="line"></span><br><span class="line">- `eval(&lt;字符串&gt;)`函数的作用是间输入的字符串变成Python语句并执行</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>x&#x3D;eval(input(“请输入：”))</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### print()函数</span><br><span class="line"></span><br><span class="line">- `print()`函数可以输出字符信息，也可以用字符的形式输出变量</span><br><span class="line">- 输出字符信息时，可以直接将待输出内容传递给`print()`函数</span><br><span class="line">- 输出变量值时，`print()`函数用槽格式和过`format()`方法将变量和字符串结合到一起输出</span><br><span class="line"></span><br><span class="line">### 函数</span><br><span class="line"></span><br><span class="line">- 函数可以理解为对一组表达特定功能表达式的封装，将特定功能代码编写在一个函数里，使程序模块化更好，便于阅读和复用</span><br><span class="line">- 可通过保留字`def`自定义函数</span><br><span class="line"></span><br><span class="line">### 文件操作</span><br><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/12/107.png)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="使用with操作文件"><a href="#使用with操作文件" class="headerlink" title="使用with操作文件"></a>使用with操作文件</h1><p>with open(os.path.dirname(<strong>file</strong>) + ‘&#x2F;blog.text’,’w’) as f:<br>    f.write(json.dumps(data))</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![路径操作模块](https://poetries1.gitee.io/img-repo/2019/12/131.png)</span><br><span class="line">![图片](https://poetries1.gitee.io/img-repo/2019/12/132.png)</span><br><span class="line">![Excel](https://poetries1.gitee.io/img-repo/2019/12/133.png)</span><br><span class="line">![文本其他](https://poetries1.gitee.io/img-repo/2019/12/134.png)</span><br><span class="line"></span><br><span class="line">## 三、基本类型</span><br><span class="line"></span><br><span class="line">![python基本数据类型](https://poetries1.gitee.io/img-repo/2019/12/112.png)</span><br><span class="line"></span><br><span class="line">**类型判断两个方式**</span><br><span class="line"></span><br><span class="line">- `type` 判断基本类型 如 `type(10) == int` 不推荐</span><br><span class="line"></span><br><span class="line">- `isinstance(值,类型)` 或者 `isinstance(值,(int,float,str))` 三种中任意一种</span><br><span class="line"></span><br><span class="line">  - 例 `isinstance(1,int)`</span><br><span class="line"></span><br><span class="line">- `Number`</span><br><span class="line"></span><br><span class="line">  - `int`</span><br><span class="line"></span><br><span class="line">  - `float`</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    complex</span><br></pre></td></tr></table></figure>

<pre><code>复数

- 如`36j`
</code></pre>
<ul>
<li>&#96;&#96;&#96;<br>Bool<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - `bool(&#x27;&#x27;)/bool([])/bool(&#123;&#125;)/bool(0)/bool(None)`</span><br><span class="line">  - 都是转化为`False`</span><br><span class="line"></span><br><span class="line">- 字符串</span><br><span class="line"></span><br></pre></td></tr></table></figure>
str<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  （序列）</span><br><span class="line"></span><br><span class="line">  - 单引号</span><br><span class="line">  - 双引号</span><br><span class="line">  - 三引号(可以换行写多个字符串和ES6的反引号类似)</span><br><span class="line">  - 在字符串前面加一个`r`，这个字符串就不是一个普通字符串，而是一个原始字符串会原样输出 `print(r&#x27;\n88fafa&#x27;)` 此时`\n`不会转译</span><br><span class="line"></span><br><span class="line">- `list` 列表 （序列）</span><br><span class="line"></span><br><span class="line">- `tuple` 元组 （序列）</span><br><span class="line"></span><br><span class="line">- 集合</span><br><span class="line"></span><br></pre></td></tr></table></figure>
set<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(无序，没有索引，不能切片，元素唯一，不能重复,只有</span><br><span class="line"></span><br></pre></td></tr></table></figure>
value<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">，没</span><br><span class="line"></span><br></pre></td></tr></table></figure>
key<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
{}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">如</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
{1,2,3,4}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - `1 in &#123;1,2,3&#125;`</span><br><span class="line">  - `1 not in &#123;1,2,3,4&#125;`</span><br><span class="line">  - 两个集合插集`&#123;1,2,3&#125; - &#123;4,5&#125;`</span><br><span class="line">  - 两个集合求交集 `&#123;1,2,3,4&#125; &amp; &#123;2,3&#125;`</span><br><span class="line">  - 并集 `&#123;1,2,3,4,5,6&#125; | &#123;3,4,7&#125;`</span><br><span class="line">  - 定义一个空的集合 `set()`</span><br><span class="line"></span><br><span class="line">- 字典</span><br><span class="line"></span><br></pre></td></tr></table></figure>
dict<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（有</span><br><span class="line"></span><br></pre></td></tr></table></figure>
key<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">无</span><br><span class="line"></span><br></pre></td></tr></table></figure>
value<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">，不同于集合只有</span><br><span class="line"></span><br></pre></td></tr></table></figure>
value<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ）</span><br><span class="line"></span><br><span class="line">  - 很多`key-value`组成,不能够有相同的键，</span><br><span class="line">  - `key`键不可变类型，可以是`int/str/tuple`</span><br><span class="line">  - `value`可以是：`int/str/float/list/set/dict`</span><br><span class="line">  - 定义一个空的字典 `&#123;&#125;`</span><br><span class="line"></span><br><span class="line">&gt; 两个整型相除得到整型 type(1//2) ==&gt;int 整除会保留整数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
&#x2F;&#x2F; 二进制<br>0b10012</li>
</ul>
<p>&#x2F;&#x2F; 八进制<br>0o101</p>
<p>&#x2F;&#x2F; 16进制<br>0x10</p>
<p>&#x2F;&#x2F; 10进制转二进制<br>bin(10)</p>
<p>&#x2F;&#x2F; 八进制转二进制<br>bin(o09012)</p>
<p>&#x2F;&#x2F; 八进制、二进制转十进制<br>int(0b1000)</p>
<p>&#x2F;&#x2F; 十进制转16进制<br>hex(88891)</p>
<p>&#x2F;&#x2F; 八进制转化<br>oct(0b100)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**转译字符**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>\n 换行<br>\t 横向制表符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**内置的字符串处理函数**</span><br><span class="line"></span><br><span class="line">| 函数       | 描述                                                  |</span><br><span class="line">| :--------- | :---------------------------------------------------- |</span><br><span class="line">| `len(&#x27;x&#x27;)` | 返回字符串`x`的长度，也可返回其他组合数据类型元素个数 |</span><br><span class="line">| `str(&#x27;x&#x27;)` | 返回任意类型`x`所对应的字符串形式                     |</span><br><span class="line">| `chr(x)`   | 返回`Unicode`编码`x`对应的单字符                      |</span><br><span class="line">| `ord(&#x27;x&#x27;)` | 返回单字符表示的`Unicode`编码                         |</span><br><span class="line">| `hex(x)`   | 返回整数`x`对应十六进制数的小写形式字符串             |</span><br><span class="line">| `oct(x)`   | 返回整数`x`对应八进制数的小写形式字符串               |</span><br><span class="line"></span><br><span class="line">**内置的字符串处理方法（共43个，常用16个）**</span><br><span class="line"></span><br><span class="line">- 在`Python`解释器内部，所有数据类型都采用面向对象的方式实现，封装为一个类</span><br><span class="line">- 字符串是一个类，具有类似`.()`形式的字符串处理函数，称为方法</span><br><span class="line"></span><br><span class="line">| 方法                                   | 描述                                                         |</span><br><span class="line">| :------------------------------------- | :----------------------------------------------------------- |</span><br><span class="line">| `str.lower()`                          | 返回字符串`str`的副本，全部字符小写                          |</span><br><span class="line">| `str.upper()`                          | 返回字符串`str`的副本，全部字符大写                          |</span><br><span class="line">| `str.islower()`                        | 当str所有字符都是小写时，返回`Ture`，否则返回`False`         |</span><br><span class="line">| `str.isprintable()`                    | 当str所有字符都是可打印的，返回`Ture`，否则返回`False`       |</span><br><span class="line">| `str.isnumeric()`                      | 当str所有字符都是数字时，返回`Ture`，否则返回`False`         |</span><br><span class="line">| `str.isspace()`                        | 当str所有字符都是空格，返回`Ture`，否则返回`Flase`           |</span><br><span class="line">| `str.endswith(suffix[,start[,end]])`   | `str[start:end]`以`suffix`结尾返回`Ture`，否则返回`Flase`    |</span><br><span class="line">| `str.srartswith(prefix[,start[,end]])` | `str[start:end]`以`prefix`开始返回`Ture`，否则返回`Flase`    |</span><br><span class="line">| `str.split(sep=None,maxsplit=-1)`      | 返回一个列表，由`str`根据`sep`被分割的部分构成               |</span><br><span class="line">| `str.count(sub[,start[,end]]`          | 返回`str[start:end]`中`sub`子串出现的次数                    |</span><br><span class="line">| `str.replace(old,new[,count])`         | 返回字符串`str`的副本，所有`old`子串被替换为`new`，如果`count`给出，则前`count`次`old`出现被替换 |</span><br><span class="line">| `str.center(width[,fillchar])`         | 字符串居中函数                                               |</span><br><span class="line">| `str.strip([chars])`                   | 返回字符串`str`的副本，在其左侧和右侧去掉`chars`中列出的字符 |</span><br><span class="line">| `str.zfill(width)`                     | 返回字符串`str`副本，长度为`width`。不足部分在其左侧添加`0`  |</span><br><span class="line">| `str.format()`                         | 返回字符串`str`的一种排版格式                                |</span><br><span class="line">| `str.join(iterable)`                   | 返回一个新字符串，由组合数据类型`iterable`变量的每个元素组成，元素间用`str`分隔 |</span><br><span class="line"></span><br><span class="line">## 四、序列-元组、字符串、列表</span><br><span class="line"></span><br><span class="line">**序列共性**</span><br><span class="line"></span><br><span class="line">- 切片</span><br><span class="line">- 序号</span><br><span class="line">- `in`判断符 `2 in [1,2,3]` `2 not in [1,2,3]`</span><br><span class="line">- `len()`</span><br><span class="line">- `max(list)`</span><br><span class="line">- `min(list)`</span><br><span class="line"></span><br><span class="line">![序列](https://poetries1.gitee.io/img-repo/2019/12/109.png)</span><br><span class="line"></span><br><span class="line">![序列基本操作](https://poetries1.gitee.io/img-repo/2019/12/108.png)</span><br><span class="line"></span><br><span class="line">**可变类型**</span><br><span class="line"></span><br><span class="line">- `list` 需要动态改变，就用列表</span><br><span class="line">- `dict`</span><br><span class="line">- `set`</span><br><span class="line"></span><br><span class="line">**不可变类型**</span><br><span class="line"></span><br><span class="line">- `str`</span><br><span class="line">- `tuple` 定义之后不可变，安全性较高</span><br><span class="line">- `int`</span><br><span class="line"></span><br><span class="line">**字符串基本操作**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; +号运算<br>str1 &#x3D; ‘hell’<br>str2 &#x3D; ‘world’<br>str &#x3D; str1 + str2</p>
<p>&#x2F;&#x2F; 乘法运算<br>str1*3 &#x2F;&#x2F; 重复3次</p>
<p>&#x2F;&#x2F; 切片<br>str1[1:2]<br>&#x2F;&#x2F; 赋值操作<br>year,month,day &#x3D; (2019,10,12)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 如果只有一个元素，应该这样表示元组 `(1,)`,一个元素都没有的元组 `type( () )`</span><br><span class="line"></span><br><span class="line">![python类型转换](https://poetries1.gitee.io/img-repo/2019/12/126.png)</span><br><span class="line"></span><br><span class="line">## 五、运算符</span><br><span class="line"></span><br><span class="line">![python运算符](https://poetries1.gitee.io/img-repo/2019/12/113.png)</span><br><span class="line"></span><br><span class="line">**列表元组都可以比较**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(1,2,3) &gt; (1,1,1) &#x2F;&#x2F; 两两比较第一个、第二个…数字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**字典的成员运算符**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 只针对key<br>‘a’ in {‘a’: ‘1’} &#x2F;&#x2F; True</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**身份运算符**</span><br><span class="line"></span><br><span class="line">- `is` 两个取值相等才会返回True `&#x27;1&#x27; is &#x27;1&#x27; // True`</span><br><span class="line">- `is not` 不等</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 关系运算符比较的是两个值是否相等 如<br>1 &#x3D;&#x3D; 1.0 &#x2F;&#x2F; True</p>
<p>&#x2F;&#x2F; is比较的是两个变量内存地址是否相等 id(值) 获取内存地址<br>1 is 1.0 &#x2F;&#x2F; False</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**对象的三个特征**</span><br><span class="line"></span><br><span class="line">- `id`(身份) =&gt; `is`判断</span><br><span class="line">- `value` =&gt; `==` 判断</span><br><span class="line">- `type` =&gt; `isinstance` 判断</span><br><span class="line"></span><br><span class="line">**位运算符**</span><br><span class="line"></span><br><span class="line">&gt; 把数字当二进制进行运算。把非二进制转化为二进制才计算</span><br><span class="line"></span><br><span class="line">- `&amp;` 按位与</span><br><span class="line">- `|` 按位或</span><br><span class="line">- `^` 按位异或</span><br><span class="line">- `~`按位取反</span><br><span class="line">- `&lt;&lt;` 左移动</span><br><span class="line">- `&gt;&gt;` 右移动</span><br><span class="line"></span><br><span class="line">## 六、循环、条件、枚举</span><br><span class="line"></span><br><span class="line">- `if else`</span><br><span class="line">- `while`</span><br><span class="line">- `for in`</span><br><span class="line"></span><br><span class="line">**range**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 等同于<br>for(var i&#x3D;0;i&lt;len;i++){}</p>
<p>&#x2F;&#x2F; range<br>for i in range(0,10)</p>
<p>&#x2F;&#x2F; 2是步长<br>for i in range(0,10,2)</p>
<p>&#x2F;&#x2F; 取出1，3，5，7<br>a &#x3D; [1,2,3,4,5,6,7,8]<br>for i in range(0,len(a),2)</p>
<p>&#x2F;&#x2F;切片写法<br>a[0:len(a):2]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 七、枚举</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>‘’’<br>枚举<br>‘’’ </p>
<p>from enum import Enum</p>
<p>class VIP(Enum):</p>
<h1 id="值可以相同-但是py会把第二个设置别名"><a href="#值可以相同-但是py会把第二个设置别名" class="headerlink" title="值可以相同 但是py会把第二个设置别名"></a>值可以相同 但是py会把第二个设置别名</h1><p>  yellow &#x3D; 1<br>  green &#x3D; 2<br>  red &#x3D; 3<br>  black &#x3D; 4</p>
<h1 id="枚举不能被修改"><a href="#枚举不能被修改" class="headerlink" title="枚举不能被修改"></a>枚举不能被修改</h1><h1 id="VIP-red-x3D-10"><a href="#VIP-red-x3D-10" class="headerlink" title="VIP.red &#x3D; 10"></a>VIP.red &#x3D; 10</h1><p>print(VIP.yellow)</p>
<h1 id="获取枚举值"><a href="#获取枚举值" class="headerlink" title="获取枚举值"></a>获取枚举值</h1><p>print(VIP.yellow.value)</p>
<h1 id="获取枚举标签"><a href="#获取枚举标签" class="headerlink" title="获取枚举标签"></a>获取枚举标签</h1><p>print(VIP.yellow.name)</p>
<h1 id="根据名称获取枚举类"><a href="#根据名称获取枚举类" class="headerlink" title="根据名称获取枚举类"></a>根据名称获取枚举类</h1><p>print(VIP[‘red’]) # VIP.red</p>
<h1 id="枚举遍历-获取每个成员"><a href="#枚举遍历-获取每个成员" class="headerlink" title="枚举遍历 获取每个成员"></a>枚举遍历 获取每个成员</h1><p>for i in VIP:<br>  print(i)</p>
<p>for v in VIP.<strong>members</strong>.items():<br>  print(v)</p>
<p>‘’’<br>(‘yellow’, &lt;VIP.yellow: 1&gt;)<br>(‘green’, &lt;VIP.green: 2&gt;)<br>(‘red’, &lt;VIP.red: 3&gt;)<br>(‘black’, &lt;VIP.black: 4&gt;)<br>‘’’</p>
<h1 id="成员之间进行比较-不持续大小比较"><a href="#成员之间进行比较-不持续大小比较" class="headerlink" title="成员之间进行比较 不持续大小比较"></a>成员之间进行比较 不持续大小比较</h1><p>res &#x3D; VIP.red &#x3D;&#x3D; VIP.black<br>print(res) # False</p>
<h1 id="身份比较"><a href="#身份比较" class="headerlink" title="身份比较"></a>身份比较</h1><p>print(VIP.red is VIP.red)</p>
<h1 id="枚举类型转换"><a href="#枚举类型转换" class="headerlink" title="枚举类型转换"></a>枚举类型转换</h1><p>print(VIP(1)) # VIP.yellow</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 八、闭包、模块、函数、变量作用域</span><br><span class="line"></span><br><span class="line">### 模块</span><br><span class="line"></span><br><span class="line">![模块](https://poetries1.gitee.io/img-repo/2019/12/110.png)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 在文件中写<code>__init__.py</code> 只是标注这是一个包 可以什么都不用写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**导入模块重新命名**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>import test as t</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**函数**</span><br><span class="line"></span><br><span class="line">&gt; 函数内部没有`return` 返回的结果就是`None`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 函数可以返回多个值<br>def test():<br>  return x, y,z</p>
<p>&#x2F;&#x2F; 接收返回的值<br>x,y,z &#x3D; test()  &#x2F;&#x2F; 其实就是返回了一个元组类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 闭包</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>‘’’<br>闭包 &#x3D; 函数+环境变量（在函数外部）<br>‘’’</p>
<p>def test():<br>  num &#x3D; 10<br>  def fun(x):<br>    return num * x<br>  return fun</p>
<p>f &#x3D; test()<br>print(f(10))</p>
<p>origin &#x3D; 0<br>def go(step):<br>  global origin<br>  new_pos &#x3D; step + origin<br>  origin &#x3D; new_pos<br>  return new_pos</p>
<p>print(go(1))<br>print(go(2))<br>print(go(3))</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 匿名函数 lambda</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>‘’’<br>函数式编程：匿名函数 lambda<br>‘’’</p>
<p>def add(x,y):<br>  return x + y </p>
<p>add(1,2)</p>
<h1 id="匿名函数定义"><a href="#匿名函数定义" class="headerlink" title="匿名函数定义"></a>匿名函数定义</h1><p>f &#x3D; lambda x,y: x+y</p>
<p>print(f(1,2))</p>
<p>arr &#x3D; [{‘key’: ‘poetries’,’value’: 100},{‘key’: ‘jing’,’value’: 10}]</p>
<h1 id="处理键值对"><a href="#处理键值对" class="headerlink" title="处理键值对"></a>处理键值对</h1><p>res &#x3D; map(lambda item: {‘name’: item[‘key’],’score’: item[‘value’]}, arr)</p>
<p>print(list(res))</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### map函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>‘’’<br>map函数<br>‘’’</p>
<p>arr &#x3D; [1,2,3,4,5,6]<br>arr2 &#x3D; [10,12,14,16,12,14]</p>
<h1 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h1><p>a &#x3D; [i*i for i in arr ]</p>
<h1 id="print-a"><a href="#print-a" class="headerlink" title="print(a)"></a>print(a)</h1><h1 id="map函数"><a href="#map函数" class="headerlink" title="map函数"></a>map函数</h1><p>b &#x3D; map(lambda x: x*x,arr)<br>print(list(b))</p>
<p>c &#x3D; map(lambda x,y: x*x + y,arr,arr2) # 可以传多个list，个数要相同<br>print(list(c))</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### reduce函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>‘’’<br>reduce函数<br>‘’’</p>
<p>from functools import reduce</p>
<p>arr &#x3D; [1,2,3,4,5,6]</p>
<h1 id="连续调用lambda"><a href="#连续调用lambda" class="headerlink" title="连续调用lambda"></a>连续调用lambda</h1><p>r &#x3D; reduce(lambda x,y:x+y,arr)</p>
<p>print(r)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### filter函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>‘’’<br>filter函数<br>‘’’</p>
<p>arr &#x3D; [1,2,3,4,5,6,7,0,0,False,’’]</p>
<h1 id="过滤空字符串"><a href="#过滤空字符串" class="headerlink" title="过滤空字符串"></a>过滤空字符串</h1><p>res &#x3D; filter(lambda x: not not x,arr)</p>
<p>print(list(res)) # [1,2,3,4,5,6,7]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 九、装饰器</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>‘’’<br>装饰器:特性、注解<br>‘’’</p>
<p>import time </p>
<p>def decorator1(func):<br>  def wrapper(name):<br>    print(time.time())<br>    func(name)<br>  return wrapper</p>
<p>@decorator1<br>def f1(name):<br>  print(‘this is a func’,name)</p>
<h1 id="f1-‘poetries’"><a href="#f1-‘poetries’" class="headerlink" title="f1(‘poetries’)"></a>f1(‘poetries’)</h1><p>def decorator2(func):<br>  def wrapper(*args,**kw):<br>    print(time.time())<br>    print(args,’args’)<br>    print(kw,’kw’)<br>    func(*args,**kw)<br>  return wrapper</p>
<p>@decorator2<br>def f2(p1,p2):<br>  print(‘this is a func’,p1,p2)</p>
<p>f2(‘静观流叶’,’1’)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 十、面向对象</span><br><span class="line"></span><br><span class="line">![类](https://poetries1.gitee.io/img-repo/2019/12/115.png)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>‘’’<br>面向对象<br>类&#x3D;面向对象</p>
<p>行为、特征</p>
<p>类最基本的作用封装代码<br>‘’’</p>
<p><strong>author</strong> &#x3D; ‘poetries’</p>
<p>class Student(Human):</p>
<h1 id="类变量-静态属性"><a href="#类变量-静态属性" class="headerlink" title="类变量 静态属性"></a>类变量 静态属性</h1><p>  author &#x3D; ‘poetry’<br>  SUM &#x3D; 10<br>  num &#x3D; 999<br>  score &#x3D; 98<br>  text &#x3D; ‘小明今年’</p>
<p>  def <strong>init</strong>(self,name,age):<br>    # 构造函数 初始化对象属性<br>    # 成员可见性 __外部不能访问<br>    self.__name &#x3D; name<br>    self.__age &#x3D; age </p>
<h1 id="实例方法-第一个参数默认是self"><a href="#实例方法-第一个参数默认是self" class="headerlink" title="实例方法 第一个参数默认是self"></a>实例方法 第一个参数默认是self</h1><p>  def getAge(self):<br>    # 实例中可调用类变量<br>    # print(self.author)<br>    return self.__getText() + str(self.__age)<br>  def getName(self):<br>    return self.__name<br>  def setName(self,name):<br>    self.__name &#x3D; name</p>
<h1 id="私有方法，外部不可以访问"><a href="#私有方法，外部不可以访问" class="headerlink" title="私有方法，外部不可以访问"></a>私有方法，外部不可以访问</h1><p>  def __getText(self):<br>    return self.text</p>
<h1 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h1><h1 id="没有self"><a href="#没有self" class="headerlink" title="没有self"></a>没有self</h1><h1 id="实例和类都可以调用"><a href="#实例和类都可以调用" class="headerlink" title="实例和类都可以调用"></a>实例和类都可以调用</h1><p>  @staticmethod<br>  def test():<br>    # 内部可以访问类变量<br>    print(‘静态方法’,Student.SUM)</p>
<h1 id="类方法-操作和类相关的"><a href="#类方法-操作和类相关的" class="headerlink" title="类方法 操作和类相关的"></a>类方法 操作和类相关的</h1><h1 id="cls代表student这个类"><a href="#cls代表student这个类" class="headerlink" title="cls代表student这个类"></a>cls代表student这个类</h1><h1 id="使用方式-student-testd"><a href="#使用方式-student-testd" class="headerlink" title="使用方式 student.testd()"></a>使用方式 student.testd()</h1><h1 id="实例和类都可以调用，不要使用实例调用"><a href="#实例和类都可以调用，不要使用实例调用" class="headerlink" title="实例和类都可以调用，不要使用实例调用"></a>实例和类都可以调用，不要使用实例调用</h1><h1 id="推荐使用类方法代替静态方法"><a href="#推荐使用类方法代替静态方法" class="headerlink" title="推荐使用类方法代替静态方法"></a>推荐使用类方法代替静态方法</h1><p>  @classmethod<br>  def testd(cls):<br>    print(‘classMethod’)</p>
<p>stu &#x3D; Student(‘poetries’,22)</p>
<p>print(stu.getAge())</p>
<h1 id="修改内部变量值，通过内部定义一个方法，可以在内部进行判断，起到保护作用"><a href="#修改内部变量值，通过内部定义一个方法，可以在内部进行判断，起到保护作用" class="headerlink" title="修改内部变量值，通过内部定义一个方法，可以在内部进行判断，起到保护作用"></a>修改内部变量值，通过内部定义一个方法，可以在内部进行判断，起到保护作用</h1><p>stu.setName(‘静观流叶’)</p>
<p>print(stu.getName())</p>
<h1 id="print-Student-author"><a href="#print-Student-author" class="headerlink" title="print(Student.author)"></a>print(Student.author)</h1><h1 id="print-Student-dict"><a href="#print-Student-dict" class="headerlink" title="print(Student.dict)"></a>print(Student.<strong>dict</strong>)</h1><h1 id="print-Student-test"><a href="#print-Student-test" class="headerlink" title="print(Student.test())"></a>print(Student.test())</h1><p>‘’’<br>继承<br>‘’’</p>
<p>class Human(object):<br>  num &#x3D;10<br>  def <strong>init</strong>(self,name,age):<br>    self.__name &#x3D; name<br>    self.__age &#x3D; age </p>
<p>  def getName(self):<br>    return self.__name</p>
<h1 id="继承父类Human"><a href="#继承父类Human" class="headerlink" title="继承父类Human"></a>继承父类Human</h1><p>class Student(Human):<br>  def <strong>init</strong>(self,school,name,age):<br>    self.school &#x3D; school<br>    # 子类调用父类构造函数<br>    # 方式1<br>    # Human.<strong>init</strong>(self,name,age)<br>    # 方式2 推荐super<br>    super(Student,self).<strong>init</strong>(name,age)</p>
<p>  def getInfo(self):<br>    return self.getName() + self.school</p>
<p>stu &#x3D; Student(‘中山大学’,’poetry’,22)<br>print(stu.getInfo())</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 十一、正则表达式</span><br><span class="line"></span><br><span class="line">&gt; 是一个特殊的字符序列，一个字符串是否与我们所设定的这样的字符序列相匹配</span><br><span class="line"></span><br><span class="line">库re</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;替换非数字的<br> s &#x3D; re.sub(‘\D’,’’,’9fafjla9dfaldfah-dfal+++)@#–9912’)</p>
<p>&#x2F;&#x2F; 例子 传递函数 根据匹配结果替换操作<br>def convert(value):<br>  match &#x3D; value.group()<br>  return ‘!!’ + match</p>
<p>re.sub(‘#c’, convert, ‘pythonc#fda’)<br>&#x2F;&#x2F; findall 可以加上第三个参数模式re.I忽略大小写<br>&#x2F;&#x2F; re.S 改变.的匹配行为，可以匹配换行符<code>/n</code><br>&#x2F;&#x2F; 返回 [‘99999’]<br>re.findall(‘\d+’,’kfdafd99999fa’,re.I | re.S)</p>
<p>&#x2F;&#x2F; 匹配仅仅是对前面那个字符起作用<br>&#x2F;&#x2F; n匹配0次或者1次<br>re.findall(‘python?’, ‘pythonnn’)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `re.match` 没有找到匹配的，将会返回`None`</span><br><span class="line">- `re.search` 直到搜索到</span><br><span class="line">- `re.sub` 替换</span><br><span class="line">- `re.findall` 推荐 返回一个列表</span><br><span class="line"></span><br><span class="line">## 十二、内建函数</span><br><span class="line"></span><br><span class="line">https://docs.python.org/3/library/functions.html</span><br><span class="line"></span><br><span class="line">![内建函数](https://poetries1.gitee.io/img-repo/2019/12/114.png)</span><br><span class="line"></span><br><span class="line">## 十三、标准库</span><br><span class="line"></span><br><span class="line">常用模块</span><br><span class="line"></span><br><span class="line">- 文字处理 re</span><br><span class="line">- 日期类型 time、datetime</span><br><span class="line">- 随机数、数学类型 math、random</span><br><span class="line">- 文件和目录访问 pathlib os.path</span><br><span class="line">- 数据压缩 tarfile</span><br><span class="line">- 通用操作系统 os、logging、argparse</span><br><span class="line">- 多线程 threading、queue</span><br><span class="line">- 网络数据处理 base64 json urllib</span><br><span class="line">- 结构化标记处理工具 html xml</span><br><span class="line">- 调试工具 timeit</span><br><span class="line">- 软件包发布 venv</span><br><span class="line">- 运行服务的 **main**</span><br><span class="line"></span><br><span class="line">## 十四、异常处理</span><br><span class="line"></span><br><span class="line">![python异常类型](https://poetries1.gitee.io/img-repo/2019/12/127.png)</span><br><span class="line"></span><br><span class="line">&gt; `try-except`语句</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>try:<br>    &lt;语句块1&gt;<br>except &lt;异常类型&gt;:<br>    &lt;语句块2&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; try-except语句可以支持多个except语句</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>try:<br>    &lt;语句块1&gt;<br>except &lt;异常类型1&gt;：<br>    &lt;语句块2&gt;<br>…<br>except &lt;异常类型N&gt;:<br>    &lt;语句块N+1&gt;<br>except &lt;异常类型N+!&gt;:<br>    &lt;语句块N+2&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 十五、JSON操作</span><br><span class="line"></span><br><span class="line">- `json`库主要包括两类函数，操作类函数和解析类函数</span><br><span class="line">- 操作类函数主要完成外部`JSON`格式和程序内部数据类型之间的转换功能</span><br><span class="line">  解析类函数主要用于解析键值对内容</span><br><span class="line">- `json`格式包括对象和数组</span><br><span class="line">- 对象用大括号(`&#123;&#125;`)表示，对应键值对的组合关系（被`json`库解析为字典）</span><br><span class="line">- 数组用中括号(`&#123;&#125;`)表示，对应键值对的对等关系（被`json`库解析为列表）</span><br><span class="line"></span><br><span class="line">**json库解析**</span><br><span class="line"></span><br><span class="line">- `json`库包含编码（`encoding`）和解码（`decoding`）两个过程</span><br><span class="line">  编码将`Python`数据类型变换成JSON格式</span><br><span class="line">- 解码是从`JSON`格式中解析数据对应到`Python`数据类型的过程</span><br><span class="line">  `json`库的操作类函数</span><br><span class="line"></span><br><span class="line">| 函数                                             | 描述                                               |</span><br><span class="line">| :----------------------------------------------- | :------------------------------------------------- |</span><br><span class="line">| `json.dumps(obj,sort_keys=Flase,indent=None)`    | 将Python的数据类型转换为`JSON`格式，编码过程       |</span><br><span class="line">| `json.loads(string)`                             | 将`JSON`格式字符串转换为Python的数据类型，解码过程 |</span><br><span class="line">| `json.dump(obj,fp，sort_keys=Flase,indent=None)` | 与`dumps()`功能一致，输出到文件`fp`                |</span><br><span class="line">| `json.load(fp)`                                  | 与`loads()`功能一致，从文件`fp`读入                |</span><br><span class="line"></span><br><span class="line">- `json.dumps()`中的`obj`可以是`Python`的列表或字典类型，当输入字典类型时，`dumps()`函数将其变为`JSON`格式字符串</span><br><span class="line">- 默认生成的字符串是顺序存放的，`sort_keys`可以对字典元素按照`key`进行排序控制输出结果</span><br><span class="line">- `indent`参数用于增加数据缩进，使得生成的`JSON`格式字符串更具可读性</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>import json</p>
<p>&#x2F;&#x2F; 反序列化<br>str &#x3D; “{‘name’: ‘poetries’}”<br>json.loads(str)</p>
<p>&#x2F;&#x2F; 序列化<br>json.dumps([{name: ‘poetries’])</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; json数据类型和python对比</span><br><span class="line"></span><br><span class="line">| JSON     | python  |</span><br><span class="line">| :------- | :------ |</span><br><span class="line">| `object` | `dict`  |</span><br><span class="line">| `array`  | `list`  |</span><br><span class="line">| `string` | `str`   |</span><br><span class="line">| `number` | `int`   |</span><br><span class="line">| `number` | `float` |</span><br><span class="line">| `true`   | `True`  |</span><br><span class="line">| `false`  | `False` |</span><br><span class="line">| `null`   | `None`  |</span><br><span class="line"></span><br><span class="line">## 十六、爬虫</span><br><span class="line"></span><br><span class="line">![模块](https://poetries1.gitee.io/img-repo/2019/12/111.png)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>‘’’<br>原生爬虫: 分页爬取我的博客文章列表<br>‘’’</p>
<p>from urllib import request<br>import re,json,os</p>
<p>baseUrl &#x3D; ‘<a target="_blank" rel="noopener" href="http://blog.poetries.top&/#39;">http://blog.poetries.top&#39;</a><br>class Spider():<br>  url &#x3D; baseUrl + ‘&#x2F;archives&#x2F;‘<br>  pattern &#x3D; ‘<a class="post-title" href="(.*)">([\w]*?)</a>‘</p>
<p>  def <strong>init</strong>(self,page&#x3D;1):<br>    self.page &#x3D; page </p>
<p>  def __fetch_content(self):<br>    url &#x3D; Spider.url<br>    if self.page !&#x3D; 1:<br>      url &#x3D; Spider.url + ‘page&#x2F;‘ + str(self.page)</p>
<pre><code>r = request.urlopen(url)
#bytes
htmls = str(r.read(), encoding=&#39;utf-8&#39;)
return htmls
</code></pre>
<p>  def _analyse(self, htmls):<br>    res &#x3D; re.findall(Spider.pattern, htmls)</p>
<pre><code>return res
</code></pre>
<p>  def start(self):<br>    htmls &#x3D; self.__fetch_content()<br>    return self._analyse(htmls)</p>
<h1 id="分页获取所有文章标题"><a href="#分页获取所有文章标题" class="headerlink" title="分页获取所有文章标题"></a>分页获取所有文章标题</h1><p>result &#x3D; [] # 保存多页数据 [[],[],[]]<br>for page in range(1,15):<br>  print(‘开始趴取，第(%d&#x2F;%d)页文章…….’%(page,14))<br>  spider &#x3D; Spider(page)<br>  res &#x3D; spider.start()<br>  result.append(res)<br>  if page &#x3D;&#x3D; 14:<br>    print(‘所有页面已趴取完…’)</p>
<p>data &#x3D; [] # 处理后的数据<br>if len(result) !&#x3D; 0:<br>  for i in result:<br>    res &#x3D; list(map(lambda item: {<br>        ‘url’: baseUrl + item[0],<br>        ‘title’: item[1]<br>      },i))<br>    # 合并两个数组 [] + []<br>    data +&#x3D; res</p>
<h1 id="保存到当前文件夹"><a href="#保存到当前文件夹" class="headerlink" title="保存到当前文件夹"></a>保存到当前文件夹</h1><p>  with open(os.path.dirname(<strong>file</strong>) + ‘&#x2F;blog.text’,’w’) as f:<br>    f.write(json.dumps(data))</p>
<p>print(data)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 十七、常用库</span><br><span class="line"></span><br><span class="line">### datetime库</span><br><span class="line"></span><br><span class="line">&gt; `datetime`库可以从系统中获得时间，并以用户选择的格式输出</span><br><span class="line"></span><br><span class="line">&gt; - `datetime`库以格林威治时间为基础，每天由`3600*24`秒精准定义</span><br><span class="line">&gt; - `datetime`库以类的方式提供多种日期和时间</span><br><span class="line"></span><br><span class="line">- `datetime.date`：日期表示类，坑人表示年、月、日等。</span><br><span class="line">- `datetime.time`：时间表示类，可表示小时、分钟、秒、毫秒等。</span><br><span class="line">- `datetime.datetime`：日期和时间表示类，功能覆盖date和time类。</span><br><span class="line">- `datetime.timedelta`：与时间间隔有关的类。</span><br><span class="line">- `datetime.tzinfo`：与时区有关的信息表示类。</span><br><span class="line"></span><br><span class="line">**datetime库解析**</span><br><span class="line"></span><br><span class="line">1. `datetime.now()`：返回一个`datetime`类型，表示当前日期和时间，精确到毫秒</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>from datetime import datetime<br>now&#x3D;datetime.now()<br>now<br>datetime.datetime(2018, 5, 13, 16, 49, 38, 627464)</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. `datetime.utcnow()`：返回一个`datetime`类型，表示当前日期和时间的`UTC`（世界标准时间）表示，精确到毫秒</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>from datetime import datetime<br>utcnow&#x3D;datetime.now()<br>utcnow<br>datetime.datetime(2018, 5, 13, 8, 53, 59, 788612)</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. 直接使用`datetime()`构造一个日期和时间对象：</span><br><span class="line"></span><br><span class="line">&gt; datetime(Y,M,D,hour=0,minute=0,second=0,microsecond=0)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>some&#x3D;datetime(2018,5,13,17,0,0,0)<br>some<br>datetime.datetime(2018, 5, 13, 17, 0)</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**datetime类的常用属性**</span><br><span class="line"></span><br><span class="line">| 属性               | 描述                                                         |</span><br><span class="line">| :----------------- | :----------------------------------------------------------- |</span><br><span class="line">| `some.min`         | 固定返回`datetime`的最小时间对象，`datetime(1,1,1,0,0)`      |</span><br><span class="line">| `some.max`         | 固定返回datetime的最大时间对象，`datetime(9999,12,31,23,59,59,999999)` |</span><br><span class="line">| `some.year`        | 返回`some`包含的年份                                         |</span><br><span class="line">| `some.month`       | 返回`some`包含的月份                                         |</span><br><span class="line">| `some.day`         | 返回`some`包含的日期                                         |</span><br><span class="line">| `some.hour`        | 返回`some`包含的小时                                         |</span><br><span class="line">| `some.minute`      | 返回`some`包含的分钟                                         |</span><br><span class="line">| `some.second`      | 返回`some`包含的秒钟                                         |</span><br><span class="line">| `some.microsecond` | 返回`some`包含的毫秒                                         |</span><br><span class="line"></span><br><span class="line">**datetime类的常用时间格式化方法**</span><br><span class="line"></span><br><span class="line">|属性| 描述|</span><br><span class="line">|`some.isofomat()` |采用`ISO8601`标准显示时间|</span><br><span class="line">|`some.isoweekday()` |根据日期计算星期|</span><br><span class="line">|`some.strftime()` |根据格式化字符串`format`进行格式显示的方法|</span><br><span class="line"></span><br><span class="line">**strftime()方法用于输出特定格式时间**</span><br><span class="line"></span><br><span class="line">| 格式化字符串 | 对象            | 取值范围           |</span><br><span class="line">| :----------- | :-------------- | :----------------- |</span><br><span class="line">| `%Y`         | 年              | `0001~9999`        |</span><br><span class="line">| `%m`         | 月              | `1~12`             |</span><br><span class="line">| `%B`         | 月名            | `January~December` |</span><br><span class="line">| `%b`         | 月名缩写        | `Jan~Dec`          |</span><br><span class="line">| `%d`         | 日期            | `01~31`            |</span><br><span class="line">| `%A`         | 星期            | `Monday~Sunday`    |</span><br><span class="line">| `%a`         | 星期缩写        | `Mon~Sum`          |</span><br><span class="line">| `%H`         | 小时（`24h`制） | `00~23`            |</span><br><span class="line">| `%I`         | 小时（`12h`制） | `01~12`            |</span><br><span class="line">| `%p`         | 上、下午        | `AM/PM`            |</span><br><span class="line">| `%M`         | 分钟            | `00~59`            |</span><br><span class="line">| `%S`         | 秒              | `00~59`            |</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>some&#x3D;datetime(2018,5,13,17,0,0,0)<br>some.strftime(“%Y年%m月%d日，%H时%M分%S秒”)<br>‘2018年05月13日，17时00分00秒’</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>print(‘今天是{0:%Y}年{0:%m}月{0:%d}日’.format(some))<br>今天是2018年05月13日</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### random库</span><br><span class="line"></span><br><span class="line">&gt; random库采用梅森旋转算法生成伪随机数序列，可用于除随机性要求更高的加解密算法外的大多数工程应用</span><br><span class="line"></span><br><span class="line">- `Python`内置的`random`库主要用于产生各种分布的伪随机数序列</span><br><span class="line">- `random`库提供`9`个常用函数</span><br><span class="line"></span><br><span class="line">| 函数                           | 描述                                             |</span><br><span class="line">| :----------------------------- | :----------------------------------------------- |</span><br><span class="line">| `seed(a=None)`                 | 初始化随机数种子，默认值为当前系统时间           |</span><br><span class="line">| `random()`                     | 生成一个`[0.0,1.0]`之间的随机小数                |</span><br><span class="line">| `randint(a,b)`                 | 生成一个`[a,b]`之间的整数                        |</span><br><span class="line">| `getrandbits(k)`               | 生成一个`k`比特长度的随机整数                    |</span><br><span class="line">| `randrange(start,stop[,step])` | 生成一个[start,stop]之间以`step`为步数的随机整数 |</span><br><span class="line">| `uniform(a,b)`                 | 生成一个`[a,b]`之间的随机小数                    |</span><br><span class="line">| `choice(seq)`                  | 从序列类型，例如列表中随机返回一个元素           |</span><br><span class="line">| `shuffle(seq)`                 | 将序列类型中的元素随机排列，返回打乱后的序列     |</span><br><span class="line">| `sample(pok,k)`                | 从`pop`类型中随机选取`k`个元素，以列表类型返回   |</span><br><span class="line"></span><br><span class="line">&gt; 生成随机数之前可通过`seed()`函数指定随机数种子，随机数种子一般是一个整数，只要种子相同，每次生成的随机数序列也相同</span><br><span class="line"></span><br><span class="line">## 十八、技巧</span><br><span class="line"></span><br><span class="line">**查看命令信息**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 例如<br>help(filter)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**列表中取出符合条件的元素**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 取出大于5的元素</p>
<p>arr &#x3D; [1,2,3,4,5,6,7,8]</p>
<p>arr1 &#x3D; filter(lambda x: x&gt;5, arr)</p>
<p>&#x2F;&#x2F; 转化为列表<br>list(arr1)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**列表推导式**</span><br><span class="line"></span><br><span class="line">&gt; 代替for和if嵌套循环。最常用的方式</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; for循环列子<br>list &#x3D; []</p>
<p>for x in range(10):<br> if x % 2 &#x3D;&#x3D; 0:<br>    list.append(x<em>x)<br>&#x2F;&#x2F; 等价于上面写法<br>[x</em>x for x in range(10) if x%2 &#x3D;&#x3D; 0]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**字典推导式**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 一般写法<br>d &#x3D; {}<br>for i in ‘xxx’:<br>  d[i] &#x3D; i</p>
<p>&#x2F;&#x2F; 字典推导写法<br>{i:i for i in ‘xxx’}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**文件读取**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="f-x3D-open-‘test-txt’-encoding-x3D-’utf-8’"><a href="#f-x3D-open-‘test-txt’-encoding-x3D-’utf-8’" class="headerlink" title="f &#x3D; open(‘test.txt’,encoding&#x3D;’utf-8’)"></a>f &#x3D; open(‘test.txt’,encoding&#x3D;’utf-8’)</h1><h1 id="data-x3D-f-readlines"><a href="#data-x3D-f-readlines" class="headerlink" title="data &#x3D; f.readlines()"></a>data &#x3D; f.readlines()</h1><h1 id="for-line-in-data"><a href="#for-line-in-data" class="headerlink" title="for line in data:"></a>for line in data:</h1><h1 id="print-line-strip-‘-n’"><a href="#print-line-strip-‘-n’" class="headerlink" title="print(line.strip(‘\n’))"></a>print(line.strip(‘\n’))</h1><h1 id="f-close"><a href="#f-close" class="headerlink" title="f.close()"></a>f.close()</h1><h1 id="推荐用with处理"><a href="#推荐用with处理" class="headerlink" title="推荐用with处理"></a>推荐用with处理</h1><p>with open(‘test.txt’) as f:<br>  for line in f.readlines():<br>    print(line.strip(‘\n’))</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**函数作用域**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>def test():<br>    global a &#x2F;&#x2F; 定义一个全局变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**装饰器**</span><br><span class="line"></span><br><span class="line">&gt; 本质是返回一个闭包</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>def log(func):<br>    def wrapper():<br>        print(‘start’)<br>        func()<br>        print(‘end’)<br>    return wrapper</p>
<p>@log<br>def test():<br>    print(‘测试’)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**交换两个变量**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>x &#x3D; 10<br>y &#x3D; 20<br>x,y &#x3D; y,x</p>
</blockquote>
</blockquote>
</blockquote>
<p>&#96;&#96;&#96;</p>
<h2 id="十九、Python知识体系"><a href="#十九、Python知识体系" class="headerlink" title="十九、Python知识体系"></a>十九、Python知识体系</h2><p><img src="https://poetries1.gitee.io/img-repo/2019/12/181.png" alt="Python知识体系"></p>
<h2 id="二十、更多参考"><a href="#二十、更多参考" class="headerlink" title="二十、更多参考"></a>二十、更多参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1016959663602400">廖雪峰python3教程</a></li>
<li><a target="_blank" rel="noopener" href="https://jupyter.org/">Jupyter Notebook</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-React/Redux-action异步" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/23/React/Redux-action%E5%BC%82%E6%AD%A5/" class="article-date">
  	<time datetime="2020-04-23T12:07:48.000Z" itemprop="datePublished">2020-04-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/23/React/Redux-action%E5%BC%82%E6%AD%A5/">
        Redux action异步
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、创建同步Action"><a href="#一、创建同步Action" class="headerlink" title="一、创建同步Action"></a>一、创建同步Action</h2><blockquote>
<p><code>Action</code>是数据从应用传递到 <code>store</code>&#x2F;<code>state</code> 的载体，也是开启一次完成数据流的开始</p>
</blockquote>
<p><strong>普通的action对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const action = &#123;</span><br><span class="line">	type:&#x27;ADD_TODO&#x27;,</span><br><span class="line">	name:&#x27;poetries&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch(action)</span><br></pre></td></tr></table></figure>

<p><strong>封装action creator</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function actionCreator(data)&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">    	type:&#x27;ADD_TODO&#x27;,</span><br><span class="line">    	data:data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch(actionCreator(&#x27;poetries&#x27;))</span><br></pre></td></tr></table></figure>

<p><strong>bindActionCreators合并</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function a(name,id)&#123;</span><br><span class="line">	reurn &#123;</span><br><span class="line">		type:&#x27;a&#x27;,</span><br><span class="line">		name,</span><br><span class="line">		id</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">function b(name,id)&#123;</span><br><span class="line">	reurn &#123;</span><br><span class="line">		type:&#x27;b&#x27;,</span><br><span class="line">		name,</span><br><span class="line">		id</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let actions = Redux.bindActionCreators(&#123;a,b&#125;,store.dispatch)</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">actions.a(&#x27;poetries&#x27;,&#x27;id001&#x27;)</span><br><span class="line">actions.b(&#x27;jing&#x27;,&#x27;id002&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>action创建的标准</strong></p>
<blockquote>
<p>在Flux的架构中，一个Action要符合 FSA(Flux Standard Action) 规范，需要满足如下条件</p>
</blockquote>
<ul>
<li>是一个纯文本对象</li>
<li>只具备 <code>type</code> 、<code>payload</code>、<code>error</code> 和 <code>meta</code>中的一个或者多个属性。<code>type</code> 字段不可缺省，其它字段可缺省</li>
<li>若 <code>Action</code> 报错，<code>error</code> 字段不可缺省，切必须为 <code>true</code></li>
</ul>
<blockquote>
<p><code>payload</code> 是一个对象，用作Action携带数据的载体</p>
</blockquote>
<p><strong>标准action示例</strong></p>
<ul>
<li>A basic Flux Standard Action:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &#x27;ADD_TODO&#x27;,</span><br><span class="line">  payload: &#123;</span><br><span class="line">    text: &#x27;Do something.&#x27;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>An FSA that represents an error, analogous to a rejected Promise</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &#x27;ADD_TODO&#x27;,</span><br><span class="line">  payload: new Error(),</span><br><span class="line">  error: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/acdlite/flux-standard-action">https://github.com/acdlite/flux-standard-action</a></p>
</blockquote>
<ul>
<li>可以采用如下一个简单的方式检验一个<code>Action</code>是否符合FSA标准</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// every有一个匹配不到返回false</span><br><span class="line">let isFSA = Object.keys(action).every((item)=&gt;&#123;</span><br><span class="line">   return  [&#x27;payload&#x27;,&#x27;type&#x27;,&#x27;error&#x27;,&#x27;meta&#x27;].indexOf(item) &gt;  -1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="二、创建异步action的多种方式"><a href="#二、创建异步action的多种方式" class="headerlink" title="二、创建异步action的多种方式"></a>二、创建异步action的多种方式</h2><blockquote>
<p>最简单的方式就是使用同步的方式来异步，将原来同步时一个<code>action</code>拆分成多个异步的<code>action</code>的，在异步开始前、异步请求中、异步正常返回（异常）操作分别使用同步的操作，从而模拟出一个异步操作了。这样的方式是比较麻烦的，现在已经有<code>redux-saga</code>等插件来解决这些问题了</p>
</blockquote>
<p><strong>异步action的实现方式一：setTimeout</strong></p>
<blockquote>
<p><code>redux-thunk</code>中间处理解析</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function thunkAction(data) &#123;</span><br><span class="line">    reutrn (dispatch)=&gt;&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">                type:&#x27;ADD_TODO&#x27;,</span><br><span class="line">                data</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,3000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>异步action的实现方式二：promise实现异步action</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redux-promise`中间处理这种`action</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function promiseAction(name)&#123;</span><br><span class="line">    return new Promise((resolve,reject) =&gt; &#123;</span><br><span class="line">        setTimeout((param)=&gt;&#123;</span><br><span class="line">            resolve(&#123;</span><br><span class="line">                type:&#x27;ADD_TODO&#x27;,</span><br><span class="line">                name</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,3000)</span><br><span class="line">    &#125;).then((param)=&gt;&#123;</span><br><span class="line">        dispatch(action(&quot;action2&quot;))</span><br><span class="line">        return;</span><br><span class="line">    &#125;).then((param)=&gt;&#123;</span><br><span class="line">        dispatch(action(&quot;action3&quot;))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、redux异步流程"><a href="#三、redux异步流程" class="headerlink" title="三、redux异步流程"></a>三、redux异步流程</h2><p><img src="https://poetries1.gitee.io/img-repo/2019/10/492.png" alt="img"></p>
<ul>
<li>首先发起一个action，然后通过中间件，这里为什么要用中间件呢，因为这样<code>dispatch</code>的返回值才能是一个函数。</li>
<li>通过<code>store.dispatch</code>，将状态的的改变传给<code>store</code>的小弟<code>reducer</code>，<code>reducer</code>根据<code>action</code>的改变，传递新的状态<code>state</code>。</li>
<li>最后将所有的改变告诉给它的大哥，<code>store</code>。<code>store</code>保存着所有的数据，并将数据注入到组件的顶部，这样组件就可以获得它需要的数据了</li>
</ul>
<h2 id="四、Redux异步方案选型"><a href="#四、Redux异步方案选型" class="headerlink" title="四、Redux异步方案选型"></a>四、Redux异步方案选型</h2><p><strong>redux-thunk</strong></p>
<blockquote>
<p><code>Redux</code>本身只能处理同步的<code>Action</code>，但可以通过中间件来拦截处理其它类型的<code>action</code>，比如函数(<code>Thunk</code>)，再用回调触发普通<code>Action</code>，从而实现异步处理</p>
</blockquote>
<ul>
<li>发送异步的<code>action</code>其实是被中间件捕获的，函数类型的action就被<code>middleware</code>捕获。至于怎么定义异步的<code>action</code>要看你用哪个中间件，根据他们的实例来定义，这样才会正确解析<code>action</code></li>
</ul>
<blockquote>
<p><code>Redux</code> 本身不处理异步行为，需要依赖中间件。结合 <code>redux-actions</code> 使用，<code>Redux</code> 有两个推荐的异步中间件</p>
</blockquote>
<ul>
<li><code>redux-thunk</code></li>
<li><code>redux-promise</code></li>
</ul>
<blockquote>
<p><code>redux-thunk</code> 的源码如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createThunkMiddleware(extraArgument) &#123;</span><br><span class="line">  return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123;</span><br><span class="line">    if (typeof action === &#x27;function&#x27;) &#123;</span><br><span class="line">      return action(dispatch, getState, extraArgument);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return next(action);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const thunk = createThunkMiddleware();</span><br><span class="line">thunk.withExtraArgument = createThunkMiddleware;</span><br><span class="line"></span><br><span class="line">export default thunk;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>源码可知，<code>action creator</code> 需要返回一个函数给 <code>redux-thunk</code> 进行调用，示例如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export let addTodoWithThunk = (val) =&gt; async (dispatch, getState)=&gt;&#123;</span><br><span class="line">    //请求之前的一些处理</span><br><span class="line"></span><br><span class="line">    let value = await Promise.resolve(val + &#x27; thunk&#x27;);</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">        type:CONSTANT.ADD_TO_DO_THUNK,</span><br><span class="line">        payload:&#123;</span><br><span class="line">            value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>而它使用起来最大的问题，就是重复的模板代码太多</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//action types</span><br><span class="line">const GET_DATA = &#x27;GET_DATA&#x27;,</span><br><span class="line">    GET_DATA_SUCCESS = &#x27;GET_DATA_SUCCESS&#x27;,</span><br><span class="line">    GET_DATA_FAILED = &#x27;GET_DATA_FAILED&#x27;;</span><br><span class="line">    </span><br><span class="line">//action creator</span><br><span class="line">const getDataAction = (id) =&gt; (dispatch, getState) =&gt; &#123;</span><br><span class="line">        dispatch(&#123;</span><br><span class="line">            type: GET_DATA, </span><br><span class="line">            payload: id</span><br><span class="line">        &#125;)</span><br><span class="line">        api.getData(id) //注：本文所有示例的api.getData都返回promise对象</span><br><span class="line">            .then(response =&gt; &#123;</span><br><span class="line">                dispatch(&#123;</span><br><span class="line">                    type: GET_DATA_SUCCESS,</span><br><span class="line">                    payload: response</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(error =&gt; &#123;</span><br><span class="line">                dispatch(&#123;</span><br><span class="line">                    type: GET_DATA_FAILED,</span><br><span class="line">                    payload: error</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//reducer</span><br><span class="line">const reducer = (oldState, action) =&gt; &#123;</span><br><span class="line">    switch(action.type) &#123;</span><br><span class="line">    case GET_DATA : </span><br><span class="line">        return oldState;</span><br><span class="line">    case GET_DATA_SUCCESS : </span><br><span class="line">        return successState;</span><br><span class="line">    case GET_DATA_FAILED : </span><br><span class="line">        return errorState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这已经是最简单的场景了，请注意：我们甚至还没写一行业务逻辑，如果每个异步处理都像这样，重复且无意义的工作会变成明显的阻碍</p>
</blockquote>
<ul>
<li>另一方面，像<code>GET_DATA_SUCCESS</code>、<code>GET_DATA_FAILED</code>这样的字符串声明也非常无趣且易错<br>上例中，<code>GET_DATA</code>这个<code>action</code>并不是多数场景需要的</li>
</ul>
<p><strong>redux-promise</strong></p>
<blockquote>
<p>由于<code>redux-thunk</code>写起来实在是太麻烦了，社区当然会有其它轮子出现。<code>redux-promise</code>则是其中比较知名的</p>
</blockquote>
<ul>
<li><p>它自定义了一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">middleware</span><br></pre></td></tr></table></figure>

<p>，当检测到有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action</span><br></pre></td></tr></table></figure>

<p>的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload</span><br></pre></td></tr></table></figure>

<p>属性是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise</span><br></pre></td></tr></table></figure>

<p>对象时，就会</p>
<ul>
<li>若<code>resolve</code>，触发一个此<code>action</code>的拷贝，但<code>payload</code>为<code>promise</code>的<code>value</code>，并设<code>status</code>属性为<code>&quot;success&quot;</code></li>
<li>若<code>reject</code>，触发一个此<code>action</code>的拷贝，但<code>payload</code>为<code>promise</code>的<code>reason</code>，并设<code>status</code>属性为<code>&quot;error&quot;</code></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//action types</span><br><span class="line">const GET_DATA = &#x27;GET_DATA&#x27;;</span><br><span class="line"></span><br><span class="line">//action creator</span><br><span class="line">const getData = function(id) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        type: GET_DATA,</span><br><span class="line">        payload: api.getData(id) //payload为promise对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//reducer</span><br><span class="line">function reducer(oldState, action) &#123;</span><br><span class="line">    switch(action.type) &#123;</span><br><span class="line">        case GET_DATA: </span><br><span class="line">            if (action.status === &#x27;success&#x27;) &#123;</span><br><span class="line">                return successState</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                   return errorState</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>redux-promise</code>为了精简而做出的妥协非常明显：无法处理乐观更新</p>
</blockquote>
<p><strong>场景解析之：乐观更新</strong></p>
<blockquote>
<p>多数异步场景都是悲观更新的，即等到请求成功才渲染数据。而与之相对的乐观更新，则是不等待请求成功，在发送请求的同时立即渲染数据</p>
</blockquote>
<ul>
<li>由于乐观更新发生在用户操作时，要处理它，意味着必须有action表示用户的初始动作</li>
<li>在上面<code>redux-thunk</code>的例子中，我们看到了<code>GET_DATA</code>, <code>GET_DATA_SUCCESS</code>、<code>GET_DATA_FAILED</code>三个<code>action</code>，分别表示初始动作、异步成功和异步失败，其中第一个<code>action</code>使得<code>redux-thunk</code>具备乐观更新的能力</li>
<li>而在<code>redux-promise</code>中，最初触发的action被中间件拦截然后过滤掉了。原因很简单，<code>redux</code>认可的<code>action</code>对象是 <code>plain JavaScript objects</code>，即简单对象，而在<code>redux-promise</code>中，初始<code>action</code>的<code>payload</code>是个<code>Promise</code></li>
</ul>
<p><strong>redux-promise-middleware</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redux-promise-middleware`相比`redux-promise`，采取了更为温和和渐进式的思路，保留了和`redux-thunk`类似的三个`action</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//action types</span><br><span class="line">const GET_DATA = &#x27;GET_DATA&#x27;,</span><br><span class="line">    GET_DATA_PENDING = &#x27;GET_DATA_PENDING&#x27;,</span><br><span class="line">    GET_DATA_FULFILLED = &#x27;GET_DATA_FULFILLED&#x27;,</span><br><span class="line">    GET_DATA_REJECTED = &#x27;GET_DATA_REJECTED&#x27;;</span><br><span class="line">    </span><br><span class="line">//action creator</span><br><span class="line">const getData = function(id) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        type: GET_DATA,</span><br><span class="line">        payload: &#123;</span><br><span class="line">            promise: api.getData(id),</span><br><span class="line">            data: id</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//reducer</span><br><span class="line">const reducer = function(oldState, action) &#123;</span><br><span class="line">    switch(action.type) &#123;</span><br><span class="line">    case GET_DATA_PENDING :</span><br><span class="line">        return oldState; // 可通过action.payload.data获取id</span><br><span class="line">    case GET_DATA_FULFILLED : </span><br><span class="line">        return successState;</span><br><span class="line">    case GET_DATA_REJECTED : </span><br><span class="line">        return errorState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、redux异步操作代码演示"><a href="#五、redux异步操作代码演示" class="headerlink" title="五、redux异步操作代码演示"></a>五、redux异步操作代码演示</h2><ul>
<li>根据官网的async例子分析 <a target="_blank" rel="noopener" href="https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/async">https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/async</a></li>
</ul>
<p><strong>action&#x2F;index.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import fetch from &#x27;isomorphic-fetch&#x27;</span><br><span class="line">export const RECEIVE_POSTS = &#x27;RECEIVE_POSTS&#x27;</span><br><span class="line"></span><br><span class="line">//获取新闻成功的action</span><br><span class="line">function receivePosts(reddit, json) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: RECEIVE_POSTS,</span><br><span class="line">    reddit: reddit,</span><br><span class="line">    posts: json.data.children.map(child =&gt;child.data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fetchPosts(subreddit) &#123;</span><br><span class="line"></span><br><span class="line">  return function (dispatch) &#123;</span><br><span class="line">    </span><br><span class="line">    return fetch(`http://www.subreddit.com/r/$&#123;subreddit&#125;.json`)</span><br><span class="line">      .then(response =&gt; response.json())</span><br><span class="line">      .then(json =&gt;</span><br><span class="line">        dispatch(receivePosts(subreddit, json))</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果需要则开始获取文章</span><br><span class="line">export function fetchPostsIfNeeded(subreddit) &#123;</span><br><span class="line"></span><br><span class="line">  return (dispatch, getState) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">      return dispatch(fetchPosts(subreddit))</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>fetchPostsIfNeeded</code>这里就是一个中间件。<code>redux-thunk</code>会拦截<code>fetchPostsIfNeeded</code>这个<code>action</code>，会先发起数据请求，如果成功，就将数据传给<code>action</code>从而到达<code>reducer</code>那里</p>
</blockquote>
<p><strong>reducers&#x2F;index.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import &#123; combineReducers &#125; from &#x27;redux&#x27;</span><br><span class="line">import &#123;</span><br><span class="line">  RECEIVE_POSTS</span><br><span class="line">&#125; from &#x27;../actions&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function posts(state = &#123;</span><br><span class="line">  items: []</span><br><span class="line">&#125;, action) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line"></span><br><span class="line">    case RECEIVE_POSTS:</span><br><span class="line">      // Object.assign是ES6的一个语法。合并对象，将对象合并为一个，前后相同的话，后者覆盖强者。详情可以看这里</span><br><span class="line">      //  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign</span><br><span class="line">      return Object.assign(&#123;&#125;, state, &#123;</span><br><span class="line">        items: action.posts //数据都存在了这里</span><br><span class="line">      &#125;)</span><br><span class="line">    default:</span><br><span class="line">      return state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 将所有的reducer结合为一个,传给store</span><br><span class="line">const rootReducer = combineReducers(&#123;</span><br><span class="line">  postsByReddit</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default rootReducer</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个跟正常的<code>reducer</code>差不多。判断<code>action</code>的类型，从而根据<code>action</code>的不同类型，返回不同的数据。这里将数据存储在了<code>items</code>这里。这里的<code>reducer</code>只有一个。最后结合成<code>rootReducer</code>,传给<code>store</code></p>
</blockquote>
<p><strong>store&#x2F;configureStore.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore, applyMiddleware &#125; from &#x27;redux&#x27;</span><br><span class="line">import thunkMiddleware from &#x27;redux-thunk&#x27;</span><br><span class="line">import createLogger from &#x27;redux-logger&#x27;</span><br><span class="line">import rootReducer from &#x27;../reducers&#x27;</span><br><span class="line"></span><br><span class="line">const createStoreWithMiddleware = applyMiddleware(</span><br><span class="line">  thunkMiddleware,  </span><br><span class="line">  createLogger()  </span><br><span class="line">)(createStore)</span><br><span class="line"></span><br><span class="line">export default function configureStore(initialState) &#123;</span><br><span class="line">  const store = createStoreWithMiddleware(rootReducer, initialState)</span><br><span class="line"></span><br><span class="line">  if (module.hot) &#123;</span><br><span class="line">    // Enable Webpack hot module replacement for reducers</span><br><span class="line">    module.hot.accept(&#x27;../reducers&#x27;, () =&gt; &#123;</span><br><span class="line">      const nextRootReducer = require(&#x27;../reducers&#x27;)</span><br><span class="line">      store.replaceReducer(nextRootReducer)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return store</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们是如何在 <code>dispatch</code> 机制中引入 <code>Redux Thunk middleware</code> 的呢？<br>我们使用了<code>applyMiddleware()</code></li>
<li>通过使用指定的 <code>middleware</code>，<code>action creator</code> 除了返回 <code>action</code> 对象外还可以返回函数</li>
<li>这时，这个 <code>action creator</code> 就成为了 <code>thunk</code></li>
</ul>
<p><strong>界面上的调用：在containers&#x2F;App.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//初始化渲染后触发</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    const &#123; dispatch&#125; = this.props</span><br><span class="line">    // 这里可以传两个值，一个是 reactjs 一个是 frontend</span><br><span class="line">    dispatch(fetchPostsIfNeeded(&#x27;frontend&#x27;))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>改变状态的时候也是需要通过<code>dispatch</code>来传递的</p>
</blockquote>
<ul>
<li>数据的获取是通过<code>provider</code>,将<code>store</code>里面的数据注入给组件。让顶级组件提供给他们的子孙组件调用。代码如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;babel-core/polyfill&#x27;</span><br><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import &#123; render &#125; from &#x27;react-dom&#x27;</span><br><span class="line">import &#123; Provider &#125; from &#x27;react-redux&#x27;</span><br><span class="line">import App from &#x27;./containers/App&#x27;</span><br><span class="line">import configureStore from &#x27;./store/configureStore&#x27;</span><br><span class="line">const store = configureStore()</span><br><span class="line">render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/Provider&gt;,</span><br><span class="line">  document.getElementById(&#x27;root&#x27;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样就完成了<code>redux</code>的异步操作。其实最主要的区别还是<code>action</code>里面还有中间件的调用，其他的地方基本跟同步的<code>redux</code>差不多的。搞懂了中间件，就基本搞懂了<code>redux</code>的异步操作</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/493.png" alt="img"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redux/" rel="tag">Redux</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-React/React-性能优化" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/20/React/React-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="article-date">
  	<time datetime="2020-04-20T02:38:18.000Z" itemprop="datePublished">2020-04-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/20/React/React-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">
        React性能优化
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、重新认识render"><a href="#一、重新认识render" class="headerlink" title="一、重新认识render"></a>一、重新认识render</h2><blockquote>
<p><code>react</code>的组件渲染分为初始化渲染和更新渲染</p>
</blockquote>
<ul>
<li>在初始化渲染的时候会调用根组件下的所有组件的<code>render</code>方法进行渲染，如下图（绿色表示已渲染，这一层是没有问题的）</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/420.png" alt="img"></p>
<p>但是当我们要更新某个子组件的时候，如下图的绿色组件（从根组件传递下来应用在绿色组件上的数据发生改变）</p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/421.png" alt="img"></p>
<p>我们的理想状态是只调用关键路径上组件的render</p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/422.png" alt="img"></p>
<p>但是<code>react</code>的默认做法是调用所有组件的<code>render</code>，再对生成的虚拟<code>DOM</code>进行对比，如不变则不进行更新。这样的<code>render</code>和虚拟<code>DOM</code>的 对比 明显是在浪费，如下图（黄色表示浪费的<code>render</code>和虚拟<code>DOM</code>对比）</p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/423.png" alt="img"></p>
<p><strong>Tips</strong></p>
<ul>
<li>拆分组件是有利于复用和组件优化的</li>
<li>生成虚拟<code>DOM</code>并进行比对发生在<code>render()</code>后，而不是<code>render()</code>前</li>
</ul>
<h2 id="二、更新阶段的生命周期"><a href="#二、更新阶段的生命周期" class="headerlink" title="二、更新阶段的生命周期"></a>二、更新阶段的生命周期</h2><ul>
<li><code>componentWillReceiveProps(object nextProps)</code> ：当挂载的组件接收到新的<code>props</code>时被调用。此方法应该被用于比较<code>this.props</code> 和 <code>nextProps</code>以用于使用<code>this.setState()</code>执行状态转换。（组件内部数据有变化，使用<code>state</code>，但是在更新阶段又要在<code>props</code>改变的时候改变<code>state</code>，则在这个生命周期里面）</li>
<li><code>shouldComponentUpdate(object nextProps, object nextState)</code> ： -<code>boolean</code> 当组件决定任何改变是否要更新到<code>DOM</code>时被调用。作为一个 优化 实现比较<code>this.props</code> 和 <code>nextProps</code> 、<code>this.state</code> 和 <code>nextState</code> ，如果<code>React</code>应该跳过更新，返回<code>false</code></li>
<li><code>componentWillUpdate(object nextProps, object nextState</code>) ：在更新发生前被立即调用。你不能在此调用 <code>this.setState()</code></li>
<li><code>componentDidUpdate(object prevProps, object prevState</code>) ： 在更新发生后被立即调用。（可以在<code>DOM</code>更新完之后，做一些收尾的工作）</li>
</ul>
<p><strong>Tips</strong></p>
<ul>
<li><code>React</code>的优化是基于 <code>shouldComponentUpdate</code> 的，该生命周期默认返回<code>true</code>，所以一旦<code>prop</code>或<code>state</code>有任何变化，都会引起重新<code>render</code></li>
</ul>
<h2 id="三、shouldComponentUpdate"><a href="#三、shouldComponentUpdate" class="headerlink" title="三、shouldComponentUpdate"></a>三、shouldComponentUpdate</h2><blockquote>
<p><code>react</code>在每个组件生命周期更新的时候都会调用一个<code>shouldComponentUpdate(nextProps, nextState)</code>函数。它的职责就是返回<code>true</code>或<code>false</code>，true表示需要更新，<code>false</code>表示不需要，默认返回为<code>true</code>，即便你没有显示地定义 <code>shouldComponentUpdate</code> 函数。这就不难解释上面发生的资源浪费了</p>
</blockquote>
<p><strong>带坑的写法</strong></p>
<ul>
<li><code>&#123;...this.props&#125;</code> (不要滥用，请只传递<code>component</code>需要的<code>props</code>，传得太多，或者层次传得太深，都会加重<code>shouldComponentUpdate</code>里面的数据比较负担，因此，也请慎用<code>spread attributes（）)</code></li>
<li><code>::this.handleChange()。(请将方法的bind一律置于constructor)</code></li>
<li>复杂的页面不要在一个组件里面写完</li>
<li>请尽量使用<code>const element</code></li>
<li><code>map</code>里面添加<code>key</code>，并且<code>key</code>不要使用<code>index</code>（可变的)</li>
<li>尽量少用<code>setTimeOut</code>或不可控的<code>refs</code>、<code>DOM</code>操作</li>
<li>数据尽可能简单明了，扁平化</li>
</ul>
<h2 id="四、性能检测工具"><a href="#四、性能检测工具" class="headerlink" title="四、性能检测工具"></a>四、性能检测工具</h2><p><strong>React.addons.Perf</strong></p>
<blockquote>
<p><code>react</code>官方提供一个插件 <code>React.addons.Perf</code> 可以帮助我们分析组件的性能，以确定是否需要优化</p>
</blockquote>
<p><code>react16</code>以前需要在项目中配置，<code>react16</code>以后请看这篇文章，直接打开控制台的<code>perf</code>选项测试 <a target="_blank" rel="noopener" href="https://reactjs.org/docs/optimizing-performance.html#profiling-components-with-the-chrome-performance-tab">https://reactjs.org/docs/optimizing-performance.html#profiling-components-with-the-chrome-performance-tab</a></p>
<p><strong>react16之前配置</strong></p>
<ul>
<li>安装 <code>react</code> 性能检测工具 <code>npm i react-addons-perf --save</code>，然后在<code>./app/index.js</code>中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 性能测试</span><br><span class="line">import Perf from &#x27;react-addons-perf&#x27;</span><br><span class="line">if (__DEV__) &#123;</span><br><span class="line">    window.Perf = Perf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>打开<code>console</code>面板，先输入 <code>Perf.start()</code> 执行一些组件操作，引起数据变动，组件更新，然后输入 <code>Perf.stop()</code> 。（建议一次只执行一个操作，好进行分析）</li>
<li>再输入 <code>Perf.printInclusive</code> 查看所有涉及到的组件<code>render</code>，如下图（官方图片）</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/424.png" alt="img"></p>
<blockquote>
<p>或者输入<code>Perf.printWasted()</code>查看下不需要的的浪费组件<code>render</code></p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/425.png" alt="img"></p>
<p>优化前</p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/426.png" alt="img"></p>
<p>优化后</p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/427.png" alt="img"></p>
<h2 id="五、其他优化"><a href="#五、其他优化" class="headerlink" title="五、其他优化"></a>五、其他优化</h2><p>1、<strong>前端通用优化。</strong>这类优化在所有前端框架中都存在，重点就在于如何将这些技巧应用在 React 组件中。</p>
<p>2、<strong>减少不必要的组件更新。</strong>这类优化是在组件状态发生变更后，通过减少不必要的组件更新来实现，对应到 React 中就是：<strong>减少渲染的节点 、降低组件渲染的复杂度、充分利用缓存避免重新渲染</strong>（利用缓存可以考虑使用PureComponent、React.memo、hook函数useCallback、useMemo等方法）</p>
<blockquote>
<p>PureComponent 是对<strong>类组件</strong>的 Props 和 State 进行浅比较；React.memo 是对<strong>函数组件</strong>的 Props 进行浅比较</p>
</blockquote>
<p>3、<strong>提交阶段优化。</strong>这类优化的目的是减少提交阶段耗时。</p>
<h3 id="1、组件按需加载"><a href="#1、组件按需加载" class="headerlink" title="1、组件按需加载"></a>1、组件按需加载</h3><p>组件按需加载优化又可以分为：<strong>懒加载、懒渲染、虚拟列表</strong> 三类。</p>
<p><strong>懒加载</strong></p>
<p>在 SPA 中，懒加载优化一般用于从一个路由跳转到另一个路由。还可用于用户操作后才展示的复杂组件，比如点击按钮后展示的弹窗模块。在这些场景下，可以结合 Code Split 实现。</p>
<p>懒加载的实现主要是通过 Webpack 的动态导入和 <code>React.lazy</code> 方法。注意，实现懒加载优化时，不仅要考虑加载态，还需要对加载失败进行容错处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; lazy, <span class="title class_">Suspense</span>, <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./styles.css&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对加载失败进行容错处理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这里处理出错场景<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Comp</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;模拟网络出错&quot;</span>))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="title function_">import</span>(<span class="string">&quot;./Component&quot;</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginBottom:</span> <span class="attr">20</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        实现懒加载优化时，不仅要考虑加载态，还需要对加载失败进行容错处理。</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&quot;Loading...&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Comp</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>懒渲染</strong></p>
<p>懒渲染指当组件进入或即将进入可视区域时才渲染组件。常见的组件 Modal&#x2F;Drawer 等，当 visible 属性为 true 时才渲染组件内容，也可以认为是懒渲染的一种实现。</p>
<p>懒渲染的使用场景有：</p>
<ol>
<li>页面中出现多次的组件，且组件渲染费时、或者组件中含有接口请求。如果渲染多个带有请求的组件，由于浏览器限制了同域名下并发请求的数量，就可能会阻塞可见区域内的其他组件中的请求，导致可见区域的内容被延迟展示。</li>
<li>需用户操作后才展示的组件。这点和懒加载一样，但懒渲染不用动态加载模块，不用考虑加载态和加载失败的兜底处理，实现上更简单。</li>
</ol>
<p>判断组件是否出现在可视区域内是通过 <a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://www.npmjs.com/package/react-visibility-observer">react-visibility-observer</a> 进行监听。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VisibilityObserver</span>, &#123;</span><br><span class="line">  useVisibilityObserver,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;react-visibility-observer&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">VisibilityObserverChildren</span> = (<span class="params">&#123; callback, children &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; isVisible &#125; = <span class="title function_">useVisibilityObserver</span>()</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">callback</span>(isVisible)</span><br><span class="line">  &#125;, [callback, isVisible])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;children&#125;<span class="tag">&lt;/&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">LazyRender</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [isRendered, setIsRendered] = <span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isRendered) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">VisibilityObserver</span> <span class="attr">rootMargin</span>=<span class="string">&#123;</span>&quot;<span class="attr">0px</span> <span class="attr">0px</span> <span class="attr">0px</span> <span class="attr">0px</span>&quot;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">VisibilityObserverChildren</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">callback</span>=<span class="string">&#123;isVisible</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">            if (isVisible) &#123;</span></span><br><span class="line"><span class="language-xml">              setIsRendered(true)</span></span><br><span class="line"><span class="language-xml">            &#125;</span></span><br><span class="line"><span class="language-xml">          &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        &gt;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">span</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">VisibilityObserverChildren</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">VisibilityObserver</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;滚动到可视区域才渲染&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是 LazyRender 组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">LazyRender</span></span><br></pre></td></tr></table></figure>

<p><strong>虚拟列表</strong></p>
<p>虚拟列表是懒渲染的一种特殊场景。实现虚拟列表的组件有 <a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://react-window.now.sh/%23/examples/list/fixed-size">react-window</a> 和 react-virtualized。react-window 是 react-virtualized 的轻量版本，其 API 和文档更加友好。新项目中推荐使用 react-window。</p>
<p>使用 react-window 很简单，只需要计算每项的高度即可。如果每项的高度是变化的，可给 itemSize 参数传一个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">FixedSizeList</span> <span class="keyword">as</span> <span class="title class_">List</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-window&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Row</span> = (<span class="params">&#123; index, style &#125;</span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span>Row &#123;index&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Example</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">List</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">height</span>=<span class="string">&#123;150&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">itemCount</span>=<span class="string">&#123;1000&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">itemSize</span>=<span class="string">&#123;35&#125;</span> // <span class="attr">每项的高度为</span> <span class="attr">35</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">width</span>=<span class="string">&#123;300&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;Row&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">List</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="2、批量更新"><a href="#2、批量更新" class="headerlink" title="2、批量更新"></a>2、批量更新</h3><h3 id="3、利用防抖、节流-避免重复回调"><a href="#3、利用防抖、节流-避免重复回调" class="headerlink" title="3、利用防抖、节流 避免重复回调"></a>3、利用防抖、节流 避免重复回调</h3><h3 id="4、缓存优化"><a href="#4、缓存优化" class="headerlink" title="4、缓存优化"></a>4、缓存优化</h3><p>缓存优化往往是最简单有效的优化方式，在 React 组件中常用 useMemo 缓存上次计算的结果。当 useMemo 的依赖未发生改变时，就不会触发重新计算。一般用在「计算派生状态的代码」非常耗时的场景中，如：遍历大列表做统计信息。</p>
<ol>
<li>React 官方并不保证 useMemo 一定会进行缓存，所以可能在依赖不改变时，仍然执行重新计算。参考 <a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://reactjs.org/docs/hooks-faq.html%23how-to-memoize-calculations">How to memoize calculations</a></li>
<li>useMemo 只能缓存最近一次函数执行的结果，如果想缓存更多次函数执行的结果，可使用 <a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://www.npmjs.com/package/memoizee">memoizee</a>。</li>
</ol>
<h3 id="5、列表项使用-key-属性"><a href="#5、列表项使用-key-属性" class="headerlink" title="5、列表项使用 key 属性"></a>5、列表项使用 key 属性</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-React/Redux-中间件" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/17/React/Redux-%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="article-date">
  	<time datetime="2020-04-17T09:32:28.000Z" itemprop="datePublished">2020-04-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/17/React/Redux-%E4%B8%AD%E9%97%B4%E4%BB%B6/">
        Redux 中间件
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><ul>
<li>在<code>redux</code>里，<code>middleware</code>是发送<code>action</code>和<code>action</code>到达<code>reducer</code>之间的第三方扩展，也就是中间层。也可以这样说，<code>middleware</code>是架在<code>action</code>和<code>store</code>之间的一座桥梁</li>
<li>在<code>redux</code>里，<code>action</code>仅仅是携带了数据的普通<code>js</code>对象</li>
</ul>
<blockquote>
<p><code>Reducer</code> 拆分可以使组件获取其最小属性(<code>state</code>)，而不需要整个<code>Store</code>。中间件则可以在<code>Action Creator</code> 返回最终可供 <code>dispatch</code> 调用的 <code>action</code> 之前处理各种事情，如异步<code>API</code>调用、日志记录等，是扩展 <code>Redux</code> 功能的一种推荐方式</p>
</blockquote>
<ul>
<li><code>Redux</code> 提供了 <code>applyMiddleware(...middlewares)</code> 来将中间件应用到 <code>createStore</code>。<code>applyMiddleware</code>会返回一个函数，该函数接收原来的 <code>creatStore</code> 作为参数，返回一个应用了 <code>middlewares</code> 的增强后的 <code>creatStore</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">export default function applyMiddleware(...middlewares) &#123;</span><br><span class="line">  return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123;</span><br><span class="line">    //接收createStore参数</span><br><span class="line">    var store = createStore(reducer, preloadedState, enhancer)</span><br><span class="line">    var dispatch = store.dispatch</span><br><span class="line">    var chain = []</span><br><span class="line"></span><br><span class="line">    //传递给中间件的参数</span><br><span class="line">    var middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: (action) =&gt; dispatch(action)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //注册中间件调用链</span><br><span class="line">    chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line"></span><br><span class="line">    //返回经middlewares增强后的createStore</span><br><span class="line">    return &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>未应用中间价之前，创建 <code>store</code> 的方式如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123;createStore&#125; from &#x27;redux&#x27;;</span><br><span class="line">import reducers from &#x27;./reducers/index&#x27;;</span><br><span class="line"></span><br><span class="line">export let store = createStore(reducers);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>应用中间价之后，创建 <code>store</code>的方式如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123;createStore，applyMiddleware&#125; from &#x27;redux&#x27;;</span><br><span class="line">import reducers from &#x27;./reducers/index&#x27;;</span><br><span class="line"></span><br><span class="line">let createStoreWithMiddleware = applyMiddleware(...middleware)(createStore);</span><br><span class="line">export let store = createStoreWithMiddleware(reducers);</span><br></pre></td></tr></table></figure>

<h2 id="二、为什么要引入middleware"><a href="#二、为什么要引入middleware" class="headerlink" title="二、为什么要引入middleware"></a>二、为什么要引入middleware</h2><ul>
<li><code>action creator</code>返回的值是这个<code>action</code>类型的对象。然后通过<code>store.dispatch()</code>进行分发</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action ---&gt; dispatcher ---&gt; reducers</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果遇到异步情况，比如点击一个按钮，希望2秒之后更新视图，显示消息“Hi”。我们可能这么写<code>ActionCreator</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var asyncSayActionCreator = function (message) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            type: &#x27;SAY&#x27;,</span><br><span class="line">            message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这会报错，因为这个<code>asyncSayActionCreator</code>返回的不是一个<code>action</code>，而是一个<code>function</code>。这个返回值无法被<code>reducer</code>识别</p>
</blockquote>
<ul>
<li>也就是说，正常来说，<code>action</code>返回的是一个对象，而不是一个函数。如果返回函数，会出现错误</li>
<li>　而异步操作呢，需要<code>action</code>的返回值是一个函数。那么咋办呢，所以需要引入中间件<code>middleware</code>,它在中间起到了桥梁的作用，让<code>action</code>的返回值可以是一个函数，从而传到<code>reducer</code>那里。也就是说，中间件是用在<code>action</code>发起之后，<code>reducer</code>接收到之前的这个时间段</li>
<li>也可以这么说，<code>Middleware</code> 主要是负责改变<code>Store</code>中的<code>dispatch</code>方法，从而能处理不同类型的 <code>action</code> 输入，得到最终的 <code>Javascript Plain Object</code> 形式的 <code>action</code> 对象</li>
</ul>
<blockquote>
<p>因此，上面那个<code>ActionCreator</code>就可以改写为这样：因为<code>action</code>的返回值是一个函数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var asyncSayActionCreator = function (message) &#123;</span><br><span class="line">    return function (dispatch) &#123;</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">                type: &#x27;SAY&#x27;,</span><br><span class="line">                message</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, 2000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://poetries1.gitee.io/img-repo/2019/10/466.png" alt="img"></p>
<ul>
<li>上图表达的是 <code>redux</code> 中一个简单的同步数据流动的场景，点击<code>button</code> 后，在回调中 <code>dispatch</code> 一个 <code>action</code>，<code>reducer</code> 收到<code>action</code> 后，更新 <code>state</code> 并通知 <code>view</code> 重新渲染</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/467.png" alt="img"></p>
<ul>
<li><p>上面这张图展示了应用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">middleware</span><br></pre></td></tr></table></figure>

<p>后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redux</span><br></pre></td></tr></table></figure>

<p>处理事件的逻辑，每一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">middleware</span><br></pre></td></tr></table></figure>

<p>处理一个相对独立的业务需求，通过串联不同的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">middleware</span><br></pre></td></tr></table></figure>

<p>，实现变化多样的的功能。那么问题来了：</p>
<ul>
<li><code>middleware</code> 怎么写？</li>
<li><code>redux</code>是如何让 <code>middlewares</code> 串联并跑起来的？</li>
</ul>
</li>
</ul>
<h2 id="三、中间件是如何工作的"><a href="#三、中间件是如何工作的" class="headerlink" title="三、中间件是如何工作的"></a>三、中间件是如何工作的</h2><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Middleware`的中间件有很多，不过我的这个案例只引用了其中的一个，那就是`redux-thunk</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>redux-thunk</code>源码如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export default function thunkMiddleware(&#123; dispatch, getState &#125;) &#123;</span><br><span class="line">  return next =&gt; action =&gt;</span><br><span class="line">    typeof action === &#x27;function&#x27; ?</span><br><span class="line">      action(dispatch, getState) :</span><br><span class="line">      next(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>意思是如果<code>action</code>是一个函数，执行这个<code>action</code>函数，如果不是函数，执行<code>next</code>函数</p>
</blockquote>
<h2 id="四、自定义中间件"><a href="#四、自定义中间件" class="headerlink" title="四、自定义中间件"></a>四、自定义中间件</h2><blockquote>
<p>中间件的签名如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#123; getState, dispatch &#125;) =&gt; next =&gt; action</span><br></pre></td></tr></table></figure>

<blockquote>
<p>根据<code>applyMiddleware</code> 源码，每个中间件接收 <code>getState &amp; dispatch</code>作为参数，并返回一个函数，该函数会被传入下一个中间件的 dispatch 方法，并返回一个接收 <code>action</code> 的新函数</p>
</blockquote>
<ul>
<li>应用多个中间件时，中间件调用链中任何一个缺少 <code>next(action)</code> 的调用，都会导致<code>action</code> 执行失败</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function callTraceMiddleware (&#123;dispatch,getState&#125;)&#123;</span><br><span class="line">    return next=&gt; action =&gt;&#123;</span><br><span class="line">        console.trace();</span><br><span class="line">        return next(action);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>然后在调用中间件部分添加中间件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const createStoreWithMiddleware = applyMiddleware(</span><br><span class="line">  thunkMiddleware,</span><br><span class="line">  loggerMiddleware,</span><br><span class="line">  callTraceMiddleware</span><br><span class="line">)(createStore);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>redux</code>的<code>middleware</code>是对<code>action</code>进行扩展处理，这样丰富了应用需求</p>
</blockquote>
<h2 id="五、常用的中间件"><a href="#五、常用的中间件" class="headerlink" title="五、常用的中间件"></a>五、常用的中间件</h2><p>有很多优秀的<code>redux</code>中间件，如：</p>
<ul>
<li>redux-thunk：用于异步操作</li>
<li>redux-logger：用于日志记录</li>
</ul>
<p>上述的中间件都需要通过<code>applyMiddlewares</code>进行注册，作用是将所有的中间件组成一个数组，依次执行</p>
<p>然后作为第二个参数传入到<code>createStore</code>中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(</span><br><span class="line">  reducer,</span><br><span class="line">  <span class="title function_">applyMiddleware</span>(thunk, logger)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h3><p><code>redux-thunk</code>是官网推荐的异步处理中间件</p>
<p>默认情况下的<code>dispatch(action)</code>，<code>action</code>需要是一个<code>JavaScript</code>的对象</p>
<p><code>redux-thunk</code>中间件会判断你当前传进来的数据类型，如果是一个函数，将会给函数传入参数值（dispatch，getState）</p>
<ul>
<li>dispatch函数用于我们之后再次派发action</li>
<li>getState函数考虑到我们之后的一些操作需要依赖原来的状态，用于让我们可以获取之前的一些状态</li>
</ul>
<p>所以<code>dispatch</code>可以写成下述函数的形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getHomeMultidataAction</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&quot;http://xxx.xx.xx.xx/test&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> data = res.<span class="property">data</span>.<span class="property">data</span>;</span><br><span class="line">      <span class="title function_">dispatch</span>(<span class="title function_">changeBannersAction</span>(data.<span class="property">banner</span>.<span class="property">list</span>));</span><br><span class="line">      <span class="title function_">dispatch</span>(<span class="title function_">changeRecommendsAction</span>(data.<span class="property">recommend</span>.<span class="property">list</span>));</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="redux-logger"><a href="#redux-logger" class="headerlink" title="redux-logger"></a>redux-logger</h3><p>如果想要实现一个日志功能，则可以使用现成的<code>redux-logger</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; applyMiddleware, createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> createLogger <span class="keyword">from</span> <span class="string">&#x27;redux-logger&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> logger = <span class="title function_">createLogger</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(</span><br><span class="line">  reducer,</span><br><span class="line">  <span class="title function_">applyMiddleware</span>(logger)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这样我们就能简单通过中间件函数实现日志记录的信息</p>
<h2 id="六、实现原理"><a href="#六、实现原理" class="headerlink" title="六、实现原理"></a>六、实现原理</h2><p>首先看看<code>applyMiddlewares</code>的源码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">applyMiddleware</span>(<span class="params">...middlewares</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">createStore</span>) =&gt;</span> <span class="function">(<span class="params">reducer, preloadedState, enhancer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> store = <span class="title function_">createStore</span>(reducer, preloadedState, enhancer);</span><br><span class="line">    <span class="keyword">var</span> dispatch = store.<span class="property">dispatch</span>;</span><br><span class="line">    <span class="keyword">var</span> chain = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> middlewareAPI = &#123;</span><br><span class="line">      <span class="attr">getState</span>: store.<span class="property">getState</span>,</span><br><span class="line">      <span class="attr">dispatch</span>: <span class="function">(<span class="params">action</span>) =&gt;</span> <span class="title function_">dispatch</span>(action)</span><br><span class="line">    &#125;;</span><br><span class="line">    chain = middlewares.<span class="title function_">map</span>(<span class="function"><span class="params">middleware</span> =&gt;</span> <span class="title function_">middleware</span>(middlewareAPI));</span><br><span class="line">    dispatch = <span class="title function_">compose</span>(...chain)(store.<span class="property">dispatch</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;...store, dispatch&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有中间件被放进了一个数组<code>chain</code>，然后嵌套执行，最后执行<code>store.dispatch</code>。可以看到，中间件内部（<code>middlewareAPI</code>）可以拿到<code>getState</code>和<code>dispatch</code>这两个方法</p>
<p>在上面的学习中，我们了解到了<code>redux-thunk</code>的基本使用</p>
<p>内部会将<code>dispatch</code>进行一个判断，然后执行对应操作，原理如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchThunk</span>(<span class="params">store</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = store.<span class="property">dispatch</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dispatchAndThunk</span>(<span class="params">action</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">            <span class="title function_">action</span>(store.<span class="property">dispatch</span>, store.<span class="property">getState</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">next</span>(action);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    store.<span class="property">dispatch</span> = dispatchAndThunk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>实现一个日志输出的原理也非常简单，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> next = store.<span class="property">dispatch</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dispatchAndLog</span>(<span class="params">action</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;dispatching:&quot;</span>, <span class="title function_">addAction</span>(<span class="number">10</span>));</span><br><span class="line">  <span class="title function_">next</span>(<span class="title function_">addAction</span>(<span class="number">5</span>));</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;新的state:&quot;</span>, store.<span class="title function_">getState</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.<span class="property">dispatch</span> = dispatchAndLog;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redux/" rel="tag">Redux</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-React/React-事件绑定方式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/13/React/React-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F/" class="article-date">
  	<time datetime="2020-04-13T01:33:27.000Z" itemprop="datePublished">2020-04-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/13/React/React-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F/">
        React-事件绑定方式
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>在<code>react</code>应用中，事件名都是用小驼峰格式进行书写，例如<code>onclick</code>要改写成<code>onClick</code></p>
<p>最简单的事件绑定如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShowAlert</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">showAlert</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.showAlert&#125;</span>&gt;</span>show<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，事件绑定的方法需要使用<code>&#123;&#125;</code>包住</p>
<p>上述的代码看似没有问题，但是当将处理函数输出代码换成<code>console.log(this)</code>的时候，点击按钮，则会发现控制台输出<code>undefined</code></p>
<h2 id="二、如何绑定"><a href="#二、如何绑定" class="headerlink" title="二、如何绑定"></a>二、如何绑定</h2><p>为了解决上面正确输出<code>this</code>的问题，常见的绑定方式有如下：</p>
<ul>
<li>render方法中使用bind</li>
<li>render方法中使用箭头函数</li>
<li>constructor中bind</li>
<li>定义阶段使用箭头函数绑定</li>
</ul>
<h3 id="render方法中使用bind"><a href="#render方法中使用bind" class="headerlink" title="render方法中使用bind"></a>render方法中使用bind</h3><p>如果使用一个类组件，在其中给某个组件&#x2F;元素一个<code>onClick</code>属性，它现在并会自定绑定其<code>this</code>到当前组件，解决这个问题的方法是在事件函数后使用<code>.bind(this)</code>将<code>this</code>绑定到当前组件中</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this &gt; &#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick.bind(this)&#125;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式在组件每次<code>render</code>渲染的时候，都会重新进行<code>bind</code>的操作，影响性能</p>
<h3 id="render方法中使用箭头函数"><a href="#render方法中使用箭头函数" class="headerlink" title="render方法中使用箭头函数"></a>render方法中使用箭头函数</h3><p>通过<code>ES6</code>的上下文来将<code>this</code>的指向绑定给当前组件，同样再每一次<code>render</code>的时候都会生成新的方法，影响性能</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this &gt; &#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;e</span> =&gt;</span> this.handleClick(e)&#125;&gt;test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="constructor中bind"><a href="#constructor中bind" class="headerlink" title="constructor中bind"></a>constructor中bind</h2><p>在<code>constructor</code>中预先<code>bind</code>当前组件，可以避免在<code>render</code>操作中重复绑定</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this &gt; &#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义阶段使用箭头函数绑定"><a href="#定义阶段使用箭头函数绑定" class="headerlink" title="定义阶段使用箭头函数绑定"></a>定义阶段使用箭头函数绑定</h3><p>跟上述方式三一样，能够避免在<code>render</code>操作中重复绑定，实现也非常的简单，如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this &gt; &#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><p>上述四种方法的方式，区别主要如下：</p>
<ul>
<li>编写方面：方式一、方式二写法简单，方式三的编写过于冗杂</li>
<li>性能方面：方式一和方式二在每次组件render的时候都会生成新的方法实例，性能问题欠缺。若该函数作为属性值传给子组件的时候，都会导致额外的渲染。而方式三、方式四只会生成一个方法实例</li>
</ul>
<p>综合上述，方式四是最优的事件绑定方式</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-React/React-设计模式和最佳实践总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/08/React/React-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/" class="article-date">
  	<time datetime="2020-04-08T05:26:02.000Z" itemprop="datePublished">2020-04-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/08/React/React-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/">
        React设计模式和最佳实践总结（底层总结）
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、组件实践"><a href="#一、组件实践" class="headerlink" title="一、组件实践"></a>一、组件实践</h2><h3 id="1-1-设计原则"><a href="#1-1-设计原则" class="headerlink" title="1.1 设计原则"></a>1.1 设计原则</h3><ul>
<li>保持接口小，<code>props</code> 数量要少</li>
<li>根据数据边界来划分组件，充分利用组合</li>
<li>把 state 往上层组件提取，让下层组件只需要实现为纯函数</li>
</ul>
<h3 id="1-2-组件划分"><a href="#1-2-组件划分" class="headerlink" title="1.2 组件划分"></a>1.2 组件划分</h3><blockquote>
<p>任何一个复杂组件都是从简单组件开始的，一开始我们在 render 函数里写的代码不多，但是随着逻辑的复杂，JSX 代码越来越多，于是，就需要拆分函数中的内容</p>
</blockquote>
<ul>
<li>在 React 中，有一个误区，就是把 render 中的代码分拆到多个 renderXXXX 函数中去，比如下面这样</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class StopWatch extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const majorClock = this.renderMajorClock();</span><br><span class="line">    const controlButtons = this.renderControlButtons();</span><br><span class="line">    const splitTimes = this.renderSplitTimes();</span><br><span class="line">    </span><br><span class="line">    return (</span><br><span class="line">       &lt;div&gt;</span><br><span class="line">          &#123;majorClock&#125;</span><br><span class="line">          &#123;controlButtons&#125;</span><br><span class="line">          &#123;splitTimes&#125;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  renderMajorClock() &#123;</span><br><span class="line">     //TODO: 返回数字时钟的JSX</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  renderControlButtons() &#123;</span><br><span class="line">     //TODO: 返回两个按钮的JSX</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  renderSplitTimes() &#123;</span><br><span class="line">     //TODO: 返回所有计次时间的JSX</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用上面的方法组织代码，当然比写一个巨大的 render 函数要强，但是，实现这么多 renderXXXX 函数并不是一个明智之举，因为这些 renderXXXX 函数访问的是同样的 props 和 state，这样代码依然耦合在了一起。更好的方法，是把这些 renderXXXX 重构成各自独立的 React 组件，像下面这样</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class StopWatch extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">       &lt;div&gt;</span><br><span class="line">          &lt;MajorClock&gt;</span><br><span class="line">          &lt;ControlButtons&gt;</span><br><span class="line">          &lt;SplitTimes&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const MajorClock = (props) =&gt; &#123;</span><br><span class="line">  //TODO: 返回数字时钟的JSX</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const ControlButtons = (props) =&gt; &#123;</span><br><span class="line">  //TODO: 返回两个按钮的JSX</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line">const SplitTimes = (props) =&gt; &#123;</span><br><span class="line">  //TODO: 返回所有计次时间的JSX</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们创造了 <code>MajorClock</code>、<code>ControlButtons</code> 和 <code>SplitTimes</code> 这三个组件，目前，我们并不知道它们是否应该有自己的 <code>state</code>，但是从简单开始，首先假设它们没有自己的 <code>state</code>，定义为函数形式的无状态组件</p>
</blockquote>
<p><strong>组件 props 的设计</strong></p>
<blockquote>
<p>使用 propTypes 来定义组件的 props</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const ControlButtons = (props) =&gt; &#123;</span><br><span class="line">  //TODO: 返回两个按钮的JSX</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ControlButtons.propTypes = &#123;</span><br><span class="line">  activated: PropTypes.bool,</span><br><span class="line">  onStart: PropTypes.func.isRquired,</span><br><span class="line">  onPause: PropTypes.func.isRquired,</span><br><span class="line">  onSplit: PropTypes.func.isRquired,</span><br><span class="line">  onReset: PropTypes.func.isRquired,</span><br><span class="line">  splits: PropTypes.arrayOf(PropTypes.number)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-组件内部实现"><a href="#1-3-组件内部实现" class="headerlink" title="1.3 组件内部实现"></a>1.3 组件内部实现</h3><ul>
<li>尽量每个组件都有自己专属的源代码文件</li>
<li>用解构赋值（destructuring assignment）的方法获取参数 props 的每个属性值</li>
<li>利用属性初始化（property initializer）来定义 state 和成员函数</li>
</ul>
<p><strong>属性初始化方法</strong></p>
<blockquote>
<p>尽量不要在 JSX 中写内联函数（inline function），比如这样写，是很不恰当的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ControlButtons</span><br><span class="line">  activated=&#123;this.state.isStarted&#125;</span><br><span class="line">  onStart=&#123;() =&gt; &#123; /* TODO */&#125;&#125;</span><br><span class="line">  onPause=&#123;() =&gt; &#123; /* TODO */&#125;&#125;</span><br><span class="line">  onReset=&#123;() =&gt; &#123; /* TODO */&#125;&#125;</span><br><span class="line">  onSplit=&#123;() =&gt; &#123; /* TODO */&#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然，按照上面那种写法，也可以完成程序的功能，但是，会带来性能的代价。首先，每一次渲染这段 <code>JSX</code>，都会产生全新的函数对象，这是一种浪费；其次，因为每一次传给 <code>ControlButtons</code> 的都是新的 <code>props</code>，这样 <code>ControlButtons</code> 也无法通过 <code>shouldComponentUpdate</code> 对 <code>props</code> 的检查来避免重复渲染</p>
</blockquote>
<h2 id="二、组件设计模式"><a href="#二、组件设计模式" class="headerlink" title="二、组件设计模式"></a>二、组件设计模式</h2><h3 id="2-1-高阶组件"><a href="#2-1-高阶组件" class="headerlink" title="2.1 高阶组件"></a>2.1 高阶组件</h3><ul>
<li>在开发 React 组件过程中，很容易发现这样一种现象，某些功能是多个组件通用的，如果每个组件都重复实现这样的逻辑，肯定十分浪费，而且违反了“不要重复自己”（DRY，Don’t Repeat Yourself)的编码原则，我们肯定想要把这部分共用逻辑提取出来重用</li>
<li>我们说过，在 React 的世界里，组件是第一公民，首先想到的是当然是把共用逻辑提取为一个 React 组件。不过，有些情况下，这些共用逻辑还没法成为一个独立组件，换句话说，这些共用逻辑单独无法使用，它们只是对其他组件的功能加强</li>
</ul>
<p><strong>高阶组件的基本形式</strong></p>
<blockquote>
<p>“高阶组件”名为“组件”，其实并不是一个组件，而是一个函数，只不过这个函数比较特殊，它接受至少一个 React 组件为参数，并且能够返回一个全新的 React 组件作为结果，当然，这个新产生的 React 组件是对作为参数的组件的包装，所以，有机会赋予新组件一些增强的“神力”</p>
</blockquote>
<p>一个最简单的高阶组件是这样的形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const withDoNothing = (Component) =&gt; &#123;</span><br><span class="line">  const NewComponent = (props) =&gt; &#123;</span><br><span class="line">    return &lt;Component &#123;...props&#125; /&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">  return NewComponent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的函数 withDoNothing 就是一个高阶组件，作为一项业界通用的代码规范，高阶组件的命名一般都带 with 前缀，命名中后面的部分代表这个高阶组件的功能</li>
</ul>
<blockquote>
<p>就如同 withDoNothing 这个名字所说的一样，这个高阶组件什么都没做，但是从中可以看出高阶组件的基本代码套路</p>
</blockquote>
<ul>
<li>高阶组件不能去修改作为参数的组件，高阶组件必须是一个纯函数，不应该有任何副作用。</li>
<li>高阶组件返回的结果必须是一个新的 React 组件，这个新的组件的 JSX 部分肯定会包含作为参数的组件</li>
<li>高阶组件一般需要把传给自己的 props 转手传递给作为参数的组件</li>
</ul>
<p><strong>用高阶组件抽取共同逻辑</strong></p>
<blockquote>
<p>接下来，我们对 withDoNothing 进行一些改进，让它实现“只有在登录时才显示”这个功能</p>
</blockquote>
<p>假设我们已经有一个函数 getUserId 能够从 cookies 中读取登录用户的 ID，如果用户未登录，这个 getUserId 就返回空，那么“退出登录按钮“就需要这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const LogoutButton = () =&gt; &#123;</span><br><span class="line">  if (getUserId()) &#123;</span><br><span class="line">    return ...; // 显示”退出登录“的JSX</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同样，购物车的代码就是这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const ShoppintCart = () =&gt; &#123;</span><br><span class="line">  if (getUserId()) &#123;</span><br><span class="line">    return ...; // 显示”购物车“的JSX</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面两个组件明显有重复的代码，我们可以把重复代码抽取出来，形成 withLogin 这个高阶组件，代码如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const withLogin = (Component) =&gt; &#123;</span><br><span class="line">  const NewComponent = (props) =&gt; &#123;</span><br><span class="line">    if (getUserId()) &#123;</span><br><span class="line">      return &lt;Component &#123;...props&#125; /&gt;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return NewComponent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如此一来，我们就只需要这样定义 LogoutButton 和 ShoppintCart：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const LogoutButton = withLogin((props) =&gt; &#123;</span><br><span class="line">  return ...; // 显示”退出登录“的JSX</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const ShoppingCart = withLogin(() =&gt; &#123;</span><br><span class="line">  return ...; // 显示”购物车“的JSX</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们避免了重复代码，以后如果要修改对用户是否登录的判断逻辑，也只需要修改 <code>withLogin</code>，而不用修改每个 React 组件</p>
</blockquote>
<p><strong>高阶组件的高级用法</strong></p>
<ul>
<li>高阶组件只需要返回一个 React 组件即可，没人规定高阶组件只能接受一个 React 组件作为参数，完全可以传入多个 React 组件给高阶组件</li>
<li>比如，我们可以改进上面的 withLogin，让它接受两个 React 组件，根据用户是否登录选择渲染合适的组件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const withLoginAndLogout = (ComponentForLogin, ComponentForLogout) =&gt; &#123;</span><br><span class="line">  const NewComponent = (props) =&gt; &#123;</span><br><span class="line">    if (getUserId()) &#123;</span><br><span class="line">      return &lt;ComponentForLogin &#123;...props&#125; /&gt;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return &lt;ComponentForLogout&#123;...props&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return NewComponent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有了上面的 withLoginAndLogout，就可以产生根据用户登录状态显示不同的内容</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const TopButtons = withLoginAndLogout(</span><br><span class="line">  LogoutButton,</span><br><span class="line">  LoginButton</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>链式调用高阶组件</strong></p>
<ul>
<li>高阶组件最巧妙的一点，是可以链式调用。</li>
<li>假设，你有三个高阶组件分别是 withOne、withTwo 和 withThree，那么，如果要赋予一个组件 X 某个高阶组件的超能力，那么，你要做的就是挨个使用高阶组件包装，代码如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const X1 = withOne(X);</span><br><span class="line">const X2 = withTwo(X1);</span><br><span class="line">const X3 = withThree(X2);</span><br><span class="line">const SuperX = X3; //最终的SuperX具备三个高阶组件的超能力</span><br></pre></td></tr></table></figure>

<p>很自然，我们可以避免使用中间变量 X1 和 X2，直接连续调用高阶组件，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const SuperX = withThree(withTwo(withOne(X)));</span><br></pre></td></tr></table></figure>

<p>对于 X 而言，它被高阶组件包装了，至于被一个高阶组件包装，还是被 N 个高阶组件包装，没有什么差别。而高阶组件本身就是一个纯函数，纯函数是可以组合使用的，所以，我们其实可以把多个高阶组件组合为一个高阶组件，然后用这一个高阶组件去包装X，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const hoc = compose(withThree, withTwo, withOne);</span><br><span class="line">const SuperX = hoc(X);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码中使用的 compose，是函数式编程中很基础的一种方法，作用就是把多个函数组合为一个函数，在很多开源的代码库中都可以看到，下面是一个参考实现</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export default function compose(...funcs) &#123;</span><br><span class="line">  if (funcs.length === 0) &#123;</span><br><span class="line">    return arg =&gt; arg</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (funcs.length === 1) &#123;</span><br><span class="line">    return funcs[0]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>React 组件可以当做积木一样组合使用，现在有了 compose，我们就可以把高阶组件也当做积木一样组合，进一步重用代码。</li>
<li>假如一个应用中多个组件都需要同样的多个高阶组件包装，那就可以用 compose 组合这些高阶组件为一个高阶组件，这样在使用多个高阶组件的地方实际上就只需要使用一个高阶组件了</li>
</ul>
<p><strong>不要滥用高阶组件</strong></p>
<blockquote>
<p>高阶组件虽然可以用一种可重用的方式扩充现有 React 组件的功能，但高阶组件并不是绝对完美的</p>
</blockquote>
<p>首先，高阶组件不得不处理 displayName，不然 debug 会很痛苦。当 React 渲染出错的时候，靠组件的 displayName 静态属性来判断出错的组件类，而高阶组件总是创造一个新的 React 组件类，所以，每个高阶组件都需要处理一下 displayName</p>
<p>如果要做一个最简单的什么增强功能都没有的高阶组件，也必须要写下面这样的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const withExample = (Component) =&gt; &#123;</span><br><span class="line">  const NewComponent = (props) =&gt; &#123;</span><br><span class="line">    return &lt;Component &#123;...props&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  NewComponent.displayName = `withExample($&#123;Component.displayName || Component.name || &#x27;Component&#x27;&#125;)`;</span><br><span class="line">  </span><br><span class="line">  return NewCompoennt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个高阶组件都这么写，就会非常的麻烦</p>
<p>对于 React 生命周期函数，高阶组件不用怎么特殊处理，但是，如果内层组件包含定制的静态函数，这些静态函数的调用在 React 生命周期之外，那么高阶组件就必须要在新产生的组件中增加这些静态函数的支持，这更加麻烦</p>
<blockquote>
<p>其次，高阶组件支持嵌套调用，这是它的优势。但是如果真的一大长串高阶组件被应用的话，当组件出错，你看到的会是一个超深的 stack trace，十分痛苦</p>
</blockquote>
<blockquote>
<p>最后，使用高阶组件，一定要非常小心，要避免重复产生 React 组件，比如，下面的代码是有问题的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const Example = () =&gt; &#123;</span><br><span class="line">  const EnhancedFoo = withExample(Foo);</span><br><span class="line">  return &lt;EnhancedFoo /&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像上面这样写，每一次渲染 Example，都会用高阶组件产生一个新的组件，虽然都叫做 EnhancedFoo，但是对 React 来说是一个全新的东西，在重新渲染的时候不会重用之前的虚拟 DOM，会造成极大的浪费</p>
<p>正确的写法是下面这样，自始至终只有一个 EnhancedFoo 组件类被创建</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const EnhancedFoo = withExample(Foo);</span><br><span class="line"></span><br><span class="line">const Example = () =&gt; &#123;</span><br><span class="line">  return &lt;EnhancedFoo /&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="render-props-模式"><a href="#render-props-模式" class="headerlink" title="render props 模式"></a>render props 模式</h3><blockquote>
<p>所谓 render props，指的是让 React 组件的 props 支持函数这种模式。因为作为 props 传入的函数往往被用来渲染一部分界面，所以这种模式被称为 render props</p>
</blockquote>
<p>一个最简单的 render props 组件 RenderAll，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const RenderAll = (props) =&gt; &#123;</span><br><span class="line">  return(</span><br><span class="line">     &lt;React.Fragment&gt;</span><br><span class="line">     	&#123;props.children(props)&#125;</span><br><span class="line">     &lt;/React.Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个 <code>RenderAll</code> 预期子组件是一个函数，它所做的事情就是把子组件当做函数调用，调用参数就是传入的 <code>props</code>，然后把返回结果渲染出来，除此之外什么事情都没有做</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;RenderAll&gt;</span><br><span class="line">&#123;() =&gt; &lt;h1&gt;hello world&lt;/h1&gt;&#125;</span><br><span class="line">&lt;/RenderAll&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到，RenderAll 的子组件，也就是夹在 RenderAll 标签之间的部分，其实是一个函数。这个函数渲染出 <code>hello world</code>，这就是上面使用 RenderAll 渲染出来的结果。</p>
<p>当然，这个 RenderAll 没做任何实际工作，接下来我们看 render props 真正强悍的使用方法。</p>
<p><strong>传递 props</strong></p>
<blockquote>
<p>和高阶组件一样，render props 可以做很多的定制功能，我们还是以根据是否登录状态来显示一些界面元素为例，来实现一个 render props</p>
</blockquote>
<p>下面是实现 <code>render props</code> 的 <code>Login</code> 组件，可以看到，<code>render props</code> 和高阶组件的第一个区别，就是 <code>render props</code> 是真正的 <code>React</code> 组件，而不是一个返回 React 组件的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const Login = (props) =&gt; &#123;</span><br><span class="line">  const userName = getUserName();</span><br><span class="line"></span><br><span class="line">  if (userName) &#123;</span><br><span class="line">    const allProps = &#123;userName, ...props&#125;;</span><br><span class="line">    return (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &#123;props.children(allProps)&#125;</span><br><span class="line">      &lt;/React.Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当用户处于登录状态，getUserName 返回当前用户名，否则返回空，然后我们根据这个结果决定是否渲染 props.children 返回的结果。</p>
<p>当然，render props 完全可以决定哪些 props 可以传递给 props.children，在 Login 中，我们把 userName 作为增加的 props 传递给下去，这样就是 Login 的增强功能。</p>
<p>一个使用上面 Login 的 JSX 代码示例如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Login&gt;</span><br><span class="line">&#123;(&#123;userName&#125;) =&gt; &lt;h1&gt;Hello &#123;userName&#125;&lt;/h1&gt;&#125;</span><br><span class="line">&lt;/Login&gt;</span><br></pre></td></tr></table></figure>

<p><strong>不局限于 children</strong></p>
<p>实际上，render props 这个模式不必局限于 children 这一个 props，任何一个 props 都可以作为函数，也可以利用多个 props 来作为函数。</p>
<p>我们来扩展 Login，不光在用户登录时显示一些东西，也可以定制用户没有登录时显示的东西，我们把这个组件叫做 Auth，对应代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const Auth= (props) =&gt; &#123;</span><br><span class="line">  const userName = getUserName();</span><br><span class="line"></span><br><span class="line">  if (userName) &#123;</span><br><span class="line">    const allProps = &#123;userName, ...props&#125;;</span><br><span class="line">    return (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &#123;props.login(allProps)&#125;</span><br><span class="line">      &lt;/React.Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      &#123;props.nologin(props)&#125;</span><br><span class="line">    &lt;/React.Fragment&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用 Auth 的话，可以分别通过 login 和 nologin 两个 props 来指定用户登录或者没登录时显示什么，用法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Auth</span><br><span class="line">    login=&#123;(&#123;userName&#125;) =&gt; &lt;h1&gt;Hello &#123;userName&#125;&lt;/h1&gt;&#125;</span><br><span class="line">    nologin=&#123;() =&gt; &lt;h1&gt;Please login&lt;/h1&gt;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p><strong>依赖注入</strong></p>
<ul>
<li>render props 其实就是 React 世界中的“依赖注入”</li>
<li>所谓依赖注入，指的是解决这样一个问题：逻辑 A 依赖于逻辑 B，如果让 A 直接依赖于 B，当然可行，但是 A 就没法做得通用了。依赖注入就是把 B 的逻辑以函数形式传递给 A，A 和 B 之间只需要对这个函数接口达成一致就行，如此一来，再来一个逻辑 C，也可以用一样的方法重用逻辑 A</li>
<li>在上面的代码示例中，Login 和 Auth 组件就是上面所说的逻辑 A，而传递给组件的函数类型 props，就是逻辑 B 和 C</li>
</ul>
<p><strong>render props 和高阶组件的比较</strong></p>
<ul>
<li>首先，render props 模式的应用，就是做一个 React 组件，而高阶组件，虽然名为“组件”，其实只是一个产生 React 组件的函数</li>
<li>render props 相对于高阶组件还有一个显著优势，就是对于新增的 props 更加灵活。还是以登录状态为例，假如我们扩展 withLogin 的功能，让它给被包裹的组件传递用户名这个 props，代码如</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const withLogin = (Component) =&gt; &#123;</span><br><span class="line">  const NewComponent = (props) =&gt; &#123;</span><br><span class="line">    const userName= getUserName();</span><br><span class="line">    if (userName) &#123;</span><br><span class="line">      return &lt;Component &#123;...props&#125; userName=&#123;userName&#125;/&gt;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return NewComponent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这就要求被 withLogin 包住的组件要接受 userName 这个props。可是，假如有一个现成的 React 组件不接受 userName，却接受名为 name 的 props 作为用户名，这就麻烦了。我们就不能直接用 withLogin 包住这个 React 组件，还要再造一个组件来做 userName 到 name 的映射，十分费事</p>
<p>对于应用 render props 的 Login，就不存在这个问题，接受 name 不接受 userName 是吗？这样写就好了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Login&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    (props) =&gt; &#123;</span><br><span class="line">      const &#123;userName&#125; = props;</span><br><span class="line">      return &lt;TheComponent &#123;...props&#125; name=&#123;userName&#125; /&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/Login&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以，当需要重用 React 组件的逻辑时，建议首先看这个功能是否可以抽象为一个简单的组件；如果行不通的话，考虑是否可以应用 render props 模式；再不行的话，才考虑应用高阶组件模式。<br>这并不表示高阶组件无用武之地，在后续章节，我们会对 render props 和高阶组件分别讲解具体的实例</p>
</blockquote>
<h3 id="2-2-提供者模式"><a href="#2-2-提供者模式" class="headerlink" title="2.2 提供者模式"></a>2.2 提供者模式</h3><p><strong>问题场景</strong></p>
<blockquote>
<p>在 React 中，props 是组件之间通讯的主要手段，但是，有一种场景单纯靠 props 来通讯是不恰当的，那就是两个组件之间间隔着多层其他组件，下面是一个简单的组件树示例图图</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/30/16627df7e8c08232" alt="img"></p>
<p>在上图中，组件 A 需要传递信息给组件 X，如果通过 props 的话，那么从顶部的组件 A 开始，要把 props 传递给组件 B，然后组件 B 传递给组件 D，最后组件 D 再传递给组件 X。</p>
<p>其实组件 B 和组件 D 完全用不上这些 props，但是又被迫传递这些 props，这明显不合理，要知道组件树的结构会变化的，将来如果组件 B 和组件 D 之间再插入一层新的组件，这个组件也需要传递这个 props，这就麻烦无比。</p>
<p>可见，对于跨级的信息传递，我们需要一个更好的方法。</p>
<p>在 React 中，解决这个问题应用的就是“提供者模式”</p>
<p><strong>提供者模式</strong></p>
<ul>
<li>虽然这个模式叫做“提供者模式”，但是其实有两个角色，一个叫“提供者”（Provider），另一个叫“消费者”（Consumer），这两个角色都是 React 组件。其中“提供者”在组件树上居于比较靠上的位置，“消费者”处于靠下的位置。在上面的组件树中，组件 A 可以作为提供者，组件 X 就是消费者</li>
<li>既然名为“提供者”，它可以提供一些信息，而且这些信息在它之下的所有组件，无论隔了多少层，都可以直接访问到，而不需要通过 props 层层传递。</li>
<li>避免 <code>props</code> 逐级传递，即是提供者的用途。</li>
</ul>
<p><strong>如何实现提供者模式</strong></p>
<ul>
<li>实现提供者模式，需要 React 的 Context 功能，可以说，提供者模式只不过是让 Context 功能更好用一些而已</li>
<li>所谓 Context 功能，就是能够创造一个“上下文”，在这个上下文笼罩之下的所有组件都可以访问同样的数据</li>
<li>在 React v16.3.0 之前，React 虽然提供了 Context 功能，但是官方文档上都建议尽量不要使用，因为对应的 API 他们并不满意，觉得迟早要废弃掉。即使如此，依然有很多库和应用使用 Context 功能，可见对这个需求的呼声有多大</li>
<li>当 React 发布 v16.3.0 时，终于提供了“正式版本”的 Context 功能 API，和之前的有很大不同，</li>
<li>提供者模式的一个典型用例就是实现“样式主题”（Theme），由顶层的提供者确定一个主题，下面的样式就可以直接使用对应主题里的样式。这样，当需要切换样式时，只需要修改提供者就行，其他组件不用修改。</li>
</ul>
<blockquote>
<p>为了方便比对，这里会介绍提供者模式用不同 Context API 的实现方法。不过，你如果完全不在意老版本 React 如何实现的，可以略过下面一段。</p>
</blockquote>
<p><strong>React v16.3.0 之前的提供者模式</strong></p>
<blockquote>
<p>在 React v16.3.0 之前，要实现提供者，就要实现一个 React 组件，不过这个组件要做两个特殊处理</p>
</blockquote>
<ul>
<li>需要实现 getChildContext 方法，用于返回“上下文”的数据</li>
<li>需要定义 childContextTypes 属性，声明“上下文”的结构。</li>
</ul>
<p>下面就是一个实现“提供者”的例子，组件名为 ThemeProvider：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class ThemeProvider extends React.Component &#123;</span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      theme: this.props.value</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &#123;this.props.children&#125;</span><br><span class="line">      &lt;/React.Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThemeProvider.childContextTypes = &#123;</span><br><span class="line">  theme: PropTypes.object</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，getChildContext 只是简单返回名为 value 的 props 值，但是，因为 getChildContext 是一个函数，它可以有更加复杂的操作，比如可以从 state 或者其他数据源获得数据。</p>
<p>对于 ThemeProvider，我们创造了一个上下文，这个上下文就是一个对象，结构是这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  theme: &#123;</span><br><span class="line">    //一个对象</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们来做两个消费（也就是使用）这个“上下文”的组件，第一个是 Subject，代表标题；第二个是 Paragraph，代表章节。</p>
<p>我们把 Subject 实现为一个类，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Subject extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123;mainColor&#125; = this.context.theme;</span><br><span class="line">    return (</span><br><span class="line">      &lt;h1 style=&#123;&#123;color: mainColor&#125;&#125;&gt;</span><br><span class="line">        &#123;this.props.children&#125;</span><br><span class="line">      &lt;/h1&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Subject.contextTypes = &#123;</span><br><span class="line">  theme: PropTypes.object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Subject 的 render 函数中，可以通过 this.context 访问到“上下文”数据，因为 ThemeProvider 提供的“上下文”包含 theme 字段，所以可以直接访问 this.context.theme。</p>
<p>千万不要忘了 Subject 必须增加 contextTypes 属性，必须和 ThemeProvider 的 childContextTypes 属性一致，不然，this.context 就不会得到任何值。</p>
<p>读者可能会问了，为什么这么麻烦呢？为什么要求“提供者”用 childContextTypes 定义一次上下文结构，又要求“消费者”再用 contextTypes 再重复定义一次呢？这不是很浪费吗？</p>
<p>React 这么要求，是考虑到“上下文”可能会嵌套，就是一个“提供者”套着另一个“提供者”，这时候，底层的消费者组件到底消费哪一个“提供者”呢？通过这种显示的方式指定。</p>
<p>不过，实话实说，这样的 API 设计的确麻烦了一点，难怪 React 官方在最初就不建议使用。</p>
<p>上面的 Subject 是一个类，其实也可以把消费者实现为一个纯函数组件，只不过访问“上下文”的方式有些不同，我们用纯函数的方式实现另一个消费者 Paragraph，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const Paragraph = (props, context) =&gt; &#123;</span><br><span class="line">  const &#123;textColor&#125; = context.theme;</span><br><span class="line">  return (</span><br><span class="line">    &lt;p style=&#123;&#123;color: textColor&#125;&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Paragraph.contextTypes = &#123;</span><br><span class="line">  theme: PropTypes.object</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看到，因为 Paragraph 是一个函数形式，所以不可能访问 this.context，但是函数的第二个参数其实就是 context。</p>
<p>当然，也不要忘了设定 Paragraph 的 contextTypes，不然参数 context 也不会是上下文。</p>
<p>最后，我们看如何结合”提供者“和”消费者“。</p>
<p>我们做一个组件来使用 Subject 和 Paragraph，这个组件不需要帮助传递任何 props，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Page = () =&gt; (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Subject&gt;这是标题&lt;/Subject&gt;</span><br><span class="line">    &lt;Paragraph&gt;</span><br><span class="line">      这是正文</span><br><span class="line">    &lt;/Paragraph&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面的组件 Page 使用了 Subject 和 Paragraph，现在我们想要定制样式主题，只需要在 Page 或者任何需要应用这个主题的组件外面包上 ThemeProvider，对应的 JSX 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ThemeProvider value=&#123;&#123;mainColor: &#x27;green&#x27;, textColor: &#x27;red&#x27;&#125;&#125; &gt;</span><br><span class="line">  &lt;Page /&gt;</span><br><span class="line">&lt;/ThemeProvider&gt;</span><br></pre></td></tr></table></figure>

<p>当我们需要改变一个样式主题的时候，改变传给 ThemeProvider的 value 值就搞定了</p>
<p><strong>React v16.3.0 之后的提供者模式</strong></p>
<ul>
<li>到了 React v16.3.0 的时候，新的 Context API 出来了，这套 API 毫不掩饰自己就是“提供者模式”的实现，命名上就带 “Provider” 和 “Consumer”。</li>
<li>还是上面的样式主题的例子，首先，要用新提供的 createContext 函数创造一个“上下文”对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const ThemeContext = React.createContext();</span><br></pre></td></tr></table></figure>

<p>这个“上下文”对象 ThemeContext 有两个属性，分别就是——对，你没猜错——Provider 和 Consumer。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const ThemeProvider = ThemeContext.Provider;</span><br><span class="line">const ThemeConsumer = ThemeContext.Consumer;</span><br></pre></td></tr></table></figure>

<p>创造“提供者”极大简化了，都不需要我们创造一个 React 组件类。</p>
<p>使用“消费者”也同样简单，而且应用了上一节我们介绍的 render props 模式，比如，Subject 的代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Subject extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;ThemeConsumer&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          (theme) =&gt; (</span><br><span class="line">            &lt;h1 style=&#123;&#123;color: theme.mainColor&#125;&#125;&gt;</span><br><span class="line">              &#123;this.props.children&#125;</span><br><span class="line">            &lt;/h1&gt;</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;/ThemeConsumer&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 ThemeConsumer 其实就是一个应用了 render props 模式的组件，它要求子组件是一个函数，会把“上下文”的数据作为参数传递给这个函数，而这个函数里就可以通过参数访问“上下文”对象。</p>
<p>在新的 API 里，不需要设定组件的 childContextTypes 或者 contextTypes 属性，这省了不少事。</p>
<p>可以注意到，Subject 没有自己的状态，没必要实现为类，我们用纯函数的形式实现 Paragraph，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const Paragraph = (props, context) =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;ThemeConsumer&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        (theme) =&gt; (</span><br><span class="line">          &lt;p style=&#123;&#123;color: theme.textColor&#125;&#125;&gt;</span><br><span class="line">            &#123;props.children&#125;</span><br><span class="line">          &lt;/p&gt;</span><br><span class="line">          )</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/ThemeConsumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现 Page 的方式并没有变化，而应用 ThemeProvider 的代码和之前也完全一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ThemeProvider value=&#123;&#123;mainColor: &#x27;green&#x27;, textColor: &#x27;red&#x27;&#125;&#125; &gt;</span><br><span class="line">  &lt;Page /&gt;</span><br><span class="line">&lt;/ThemeProvider&gt;</span><br></pre></td></tr></table></figure>

<p><strong>两种提供者模式实现方式的比较</strong></p>
<ul>
<li>通过上面的代码，可以很清楚地看到，新的 Context API 更简洁，但是，也并不是十全十美。</li>
<li>在老版 Context API 中，“上下文”只是一个概念，并不对应一个代码，两个组件之间达成一个协议，就诞生了“上下文”。</li>
<li>在新版 Context API 中，需要一个“上下文”对象（上面的例子中就是 ThemeContext)，使用“提供者”的代码和“消费者”的代码往往分布在不同的代码文件中，那么，这个 ThemeContext 对象放在哪个代码文件中呢？</li>
<li>最好是放在一个独立的文件中，这么一来，就多出一个代码文件，而且所有和这个“上下文”相关的代码，都要依赖于这个“上下文”代码文件，虽然这没什么大不了的，但是的确多了一层依赖关系。</li>
<li>为了避免依赖关系复杂，每个应用都不要滥用“上下文”，应该限制“上下文”的使用个数。</li>
<li>不管怎么说，新版本的 Context API 才是未来，在 React v17 中，可能就会删除对老版 Context API 的支持，所以，现在大家都应该使用第二种实现方式。</li>
</ul>
<h3 id="2-3-组合组件"><a href="#2-3-组合组件" class="headerlink" title="2.3 组合组件"></a>2.3 组合组件</h3><p><strong>问题描述</strong></p>
<p>为了让问题更加具体，我们来解决一个实例。</p>
<p>很多界面都有 Tab 这样的元件，我们需要一个 Tabs 组件和 TabItem 组件，Tabs 是容器，TabItem 是一个一个单独的 Tab，因为一个时刻只有一个 TabItem 被选中，很自然希望被选中的 TabItem 样式会和其他 TabItem 不同。</p>
<p>这并不是一个很难的功能，首先我们想到的就是，用 Tabs 中一个 state 记录当前被选中的 Tabitem 序号，然后根据这个 state 传递 props 给 TabItem，当然，还要传递一个 onClick 事件进去，捕获点击选择事件。</p>
<p>按照这样的设计，Tabs 中如果要显示 One、Two、Three 三个 TabItem，JSX 代码大致这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;TabItem active=&#123;true&#125; onClick=&#123;this.onClick&#125;&gt;One&lt;/TabItem&gt;</span><br><span class="line">&lt;TabItem active=&#123;false&#125; onClick=&#123;this.onClick&#125;&gt;Two&lt;/TabItem&gt;</span><br><span class="line">&lt;TabItem active=&#123;false&#125; onClick=&#123;this.onClick&#125;&gt;Three&lt;/TabItem&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的 TabItem 组件接受 active 这个 props，如果 true 代表当前是选中状态，当然可以工作，但是，也存在大问题</p>
</blockquote>
<ul>
<li>每次使用 TabItem 都要传递一堆 props，好麻烦；</li>
<li>每增加一个新的 TabItem，都要增加对应的 props，更麻烦；</li>
<li>如果要增加 TabItem，就要去修改 Tabs 的 JSX 代码，超麻烦。</li>
</ul>
<p>我们不想要这么麻烦，理想情况下，我们希望可以随意增加减少 TabItem 实例，不用传递一堆 props，也不用去修改 Tabs 的代码，最好代码就这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Tabs&gt;</span><br><span class="line">  &lt;TabItem&gt;One&lt;/TabItem&gt;</span><br><span class="line">  &lt;TabItem&gt;Two&lt;/TabItem&gt;</span><br><span class="line">  &lt;TabItem&gt;Three&lt;/TabItem&gt;</span><br><span class="line">&lt;/Tabs&gt;</span><br></pre></td></tr></table></figure>

<p>如果能像上面一样写代码，那就达到目的了。</p>
<blockquote>
<p>像上面这样，Tabs 和 TabItem 不通过表面的 props 传递也能心有灵犀，二者之间有某种神秘的“组合”，就是我们所说的“组合组件”。</p>
</blockquote>
<p><strong>实现方式</strong></p>
<p>上面我们说过，利用 Context API，可以实现组合组件，但是那样 TabItem 需要应用 render props，至于如何实现，读者可以参照上一节的介绍自己尝试。</p>
<p>在这里，我们用一种更巧妙的方式来实现组合组件，可以避免 TabItem 的复杂化。</p>
<p>我们先写出 TabItem 的代码，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const TabItem = (props) =&gt; &#123;</span><br><span class="line">  const &#123;active, onClick&#125; = props;</span><br><span class="line">  const tabStyle = &#123;</span><br><span class="line">    &#x27;max-width&#x27;: &#x27;150px&#x27;,</span><br><span class="line">    color: active ? &#x27;red&#x27; : &#x27;green&#x27;,</span><br><span class="line">    border: active ? &#x27;1px red solid&#x27; : &#x27;0px&#x27;,</span><br><span class="line">  &#125;;</span><br><span class="line">  return (</span><br><span class="line">    &lt;h1 style=&#123;tabStyle&#125; onClick=&#123;onClick&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>TabItem 有两个重要的 props：active 代表自己是否被激活，onClick 是自己被点击时应该调用的回调函数，这就足够了。TabItem 所做的就是根据这两个 props 渲染出 props.children，没有任何复杂逻辑，是一个活脱脱的“傻瓜组件”，所以，用一个纯函数实现就可以了。</p>
<p>接下来要做的，就看 Tabs 如何把 active 和 onClick 传递给 TabItem。</p>
<p>我们再来看一下使用组合组件的 JSX 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Tabs&gt;</span><br><span class="line">  &lt;TabItem&gt;One&lt;/TabItem&gt;</span><br><span class="line">  &lt;TabItem&gt;Two&lt;/TabItem&gt;</span><br><span class="line">  &lt;TabItem&gt;Three&lt;/TabItem&gt;</span><br><span class="line">&lt;/Tabs&gt;</span><br></pre></td></tr></table></figure>

<p>没有 props 的传递啊，怎么悄无声息地把 active 和 onClick 传递给 TabItem 呢？</p>
<p>Tabs 虽然可以访问到作为 props 的 children，但是到手的 children 已经是创造好的元素，而且是不可改变的，Tabs 是不可能把创造好的元素再强塞给 children 的。</p>
<p>怎么办？</p>
<p>办法还是有的，如果 Tabs 并不去渲染 children，而是把 children 拷贝一份，就有机会去篡改这份拷贝，最后渲染这份拷贝就好了。</p>
<p>我们来看 Tabs 的实现代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Tabs extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    activeIndex:  0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const newChildren = React.Children.map(this.props.children, (child, index) =&gt; &#123;</span><br><span class="line">      if (child.type) &#123;</span><br><span class="line">        return React.cloneElement(child, &#123;</span><br><span class="line">          active: this.state.activeIndex === index,</span><br><span class="line">          onClick: () =&gt; this.setState(&#123;activeIndex: index&#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return child;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &#123;newChildren&#125;</span><br><span class="line">      &lt;/Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在 render 函数中，我们用了 React 中不常用的两个 API：</p>
<ul>
<li><code>React.Children.map</code></li>
<li><code>React.cloneElement</code></li>
</ul>
<p>使用 React.Children.map，可以遍历 children 中所有的元素，因为 children 可能是一个数组嘛。</p>
<p>使用 React.cloneElement 可以复制某个元素。这个函数第一个参数就是被复制的元素，第二个参数可以增加新产生元素的 props，我们就是利用这个机会，把 active 和 onClick 添加了进去。</p>
<p>这两个 API 双剑合璧，就能实现不通过表面的 props 传递，完成两个组件的“组合”</p>
<p><strong>实际应用</strong></p>
<ul>
<li>从上面的代码可以看出来，对于组合组件这种实现方式，TabItem 非常简化；Tabs 稍微麻烦了一点，但是好处就是把复杂度都封装起来了，从使用者角度，连 props 都看不见。</li>
<li>所以，应用组合组件的往往是共享组件库，把一些常用的功能封装在组件里，让应用层直接用就行。在 antd 和 bootstrap 这样的共享库中，都使用了组合组件这种模式。</li>
<li>如果你的某两个组件并不需要重用，那么就要谨慎使用组合组件模式，毕竟这让代码复杂了一些。</li>
</ul>
<h2 id="三、React-单元测试"><a href="#三、React-单元测试" class="headerlink" title="三、React 单元测试"></a>三、React 单元测试</h2><h3 id="3-1-测试的目的"><a href="#3-1-测试的目的" class="headerlink" title="3.1 测试的目的"></a>3.1 测试的目的</h3><p>测试对于软件开发非常重要，简单来说，测试就是尽力发现软件中的缺陷（俗称 bug），当我们发现不了更多的 bug 时，说明这个软件质量可以接受了。</p>
<p>然而，没有 bug 的软件我还没见过呢。</p>
<p>在互联网时代，我们更是不可能等到所有 bug 都修复了才上线，那样黄花菜都凉了，稍微有一些工作经验的人都会有这样的体会。</p>
<p>所以，事实上，测试是尽力发现软件中的 bug。当我们发现 bug 数量和严重程度呈稳定的下降趋势，直到低于一个门槛（无须降低为 0，只需要降低到可接受的程度），没有更多更严重的 bug 出现，就说明这个软件的质量可以接受，可以上线了。</p>
<p>这样当然要比达到“零 bug 软件”要容易多了，但是，不要因此以为这就是一件没有困难的任务。为了让 bug 的数量和严重程度足够低，我们开发者必须严格要求自己，只有保证我们写的每一小块代码都经受住测试的考验，这些小块代码集合在一起的时候才可能（只是有可能）不会出很多 bug，如果我们写的小块代码质量都无法保证，那大项目的代码根本无法保证</p>
<h2 id="四、单元测试"><a href="#四、单元测试" class="headerlink" title="四、单元测试"></a>四、单元测试</h2><p><strong>Jest</strong></p>
<p>在 JavaScript 的世界里，单元测试的框架很多，品牌最老名气最响的是 Mocha ，不过，不要纠结于名气，请使用 Jest 。你不会后悔的，接下来我告诉你为什么。</p>
<p>我们先假设，作为开发者，你是在团队中工作。所谓团队，就是有很多人一起工作，而且随着业务和团队的发展，人会越来越多，潜台词就是——不确定因素越来越多。</p>
<p>人和人之间交流会出现偏差，人的水平有高低之分，人也会犯错，总之，你不能指望所有人都把事情做得尽善尽美。</p>
<p>具体到单元测试这件事上来，“测试驱动”是开发喊了这么多年，为什么真正做到这一点的团队依然不多呢？因为，当团队变大之后，很多问题也就出现了</p>
<p>1、单元测试用例庞大，执行时间过长。</p>
<p>想象一下，一个代码库里假设有一千个单元测试用例，即使每个单元测试用例平均只需要 10 毫秒，那总时间也就需要 10 秒钟。好，假设代码库进一步扩大，有了一万个单元测试用例，那就跑一遍就需要 100 秒，已经超过了一分钟。这还只是保守估计，实际上单元测试用例的运行时间只会比这长。开发者如果每次修改都需要等待这么漫长的单元测试运行时间，肯定会三心二意上网去看其他东西。</p>
<p>2、 单元测试用例之间相互影响。</p>
<p>你可能也有这样的体验，代码库中的单元测试突然失败了，但是你修改的代码根本不会取影响失败的那个单元测试用例，怎么回事？这往往是因为某个成员以前的代码写得不好，影响了一个全局变量。当然，谁都知道单元测试应该在 setup 时创建环境，在 teardown 时恢复环境，可是，总会有人有马虎大意的情况，这时候你怎么办？要么你只好去修复一个本不是你改坏的代码，要么你干脆删掉那段不可靠的单元测试代码，不管怎样，这都会打击你支持“测试驱动开发”的决心。</p>
<p>Jest 较好地解决了上面说的问题，因为 Jest 最重要的一个特性，就是支持并行执行</p>
<p>Mocha 之类老牌单元测试框架，把所有的单元测试都放在一个环境中执行，这就使所有单元测试访问的是同样一个全局变量空间，所以只要测试代码没写好，就会互相影响。而且，为了保证执行正常，所有的单元测试必须一个接一个地执行，这是体系架构决定的，没有办法。</p>
<p>Jest 不同，Jest 为每一个单元测试文件创造一个独立的运行环境，换句话说，Jest 会启动一个进程执行一个单元测试文件，运行结束之后，就把这个执行进程废弃了，这个单元测试文件即使写得比较差，把全局变量污染得一团糟，也不会影响其他单元测试文件，因为其他单元测试文件是用另一个进程来执行</p>
<p>更妙的是，因为每个单元测试文件之间再无纠葛，Jest 可以启动多个进程同时运行不同的文件，这样就充分利用了电脑的多 CPU 多核，单进程 100 秒才完成的测试执行过程，8 核只需要 12.5 秒，速度快了很多。</p>
<p>Jest 还有很多其他友好的特性，大家可以自己去发掘，这里废话不多说，只想安利各位，测试 React 或者 JavaScript 代码，用 Jest！</p>
<p>使用 create-react-app 产生的项目自带 Jest 作为测试框架，不奇怪，因为 Jest 和 React 一样都是出自 Facebook。</p>
<p>运行下面的命令，就可以进入交互式的”测试驱动开发“模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm test</span><br></pre></td></tr></table></figure>

<p><strong>Enzyme</strong></p>
<p>虽然最好的 React 测试框架出自 Facebook 家，最受欢迎的 React 测试工具库却出自 Airbnb，这个工具库叫做 Enzyme。Enzyme 这个单词的含义是“酶”，至于命名原因已经无法考据，可能寓意着快速分解。</p>
<p>不过因为 Enzyme 不是 Facebook 家出品，所以使用 Enzyme 还真稍微有些麻烦——在 create-react-app 产生的应用中并不包含 Enzyme，需要我们自己来添加。</p>
<p>在项目目录下，通过下面的命令来安装 enzyme</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev enzyme enzyme-adapter-react-16</span><br></pre></td></tr></table></figure>

<p>可以注意到，我们不光要安装 enzyme，还要安装 enzyme-adapter-react-16，这个库是用来作为适配器的。因为不同 React 版本有各自特点，所用的适配器也会不同，我们的项目中使用的是 16.4 之后的版本，所以用 enzyme-adapter-react-16；如果用 16.3 版本，需要用 enzyme-adapter-react-16.3；如果用 16.2 版本，需要用 enzyme-adapter-react-16.2；如果用更老的版本 15.5，需要用 enzyme-adapter-react-15。具体各个 React 版本对应什么样的 Adapter，请参考 enzyme官方文档。</p>
<p>现在，可以在测试代码中使用 enzyme 了。我们以之前秒表应用中的 ControlButtons 组件为例，来说明如何做单元测试。</p>
<p>我们创造一个 ControlButtons.test.js，来容纳对应的测试用例，因为所有后缀为 .test.js 的文件都会被 Jest 认作是测试用例文件。</p>
<p>在代码中，需要使用 Adapter，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123;configure&#125; from &#x27;enzyme&#x27;;</span><br><span class="line">import Adapter from &#x27;enzyme-adapter-react-16&#x27;;</span><br><span class="line">configure(&#123;adapter: new Adapter()&#125;);</span><br></pre></td></tr></table></figure>

<p>我们对 ControlButtons 组件的测试，就是要渲染它一次，看看渲染结果如何，enzyme 就能帮助我们做这件事。</p>
<p>比如，我们想要保证渲染出来的内容必须包含两个按钮，其中一个按钮的 class 名是 left-btn，另一个是 right-btn，那么我们就需要下面的单元测试用例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123;shallow&#125; from &#x27;enzyme&#x27;;</span><br><span class="line"></span><br><span class="line">it(&#x27;renders without crashing&#x27;, () =&gt; &#123;</span><br><span class="line">  const wrapper = shallow(&lt;ControlButtons /&gt;);</span><br><span class="line">  expect(wrapper.find(&#x27;.left-btn&#x27;)).toHaveLength(1);</span><br><span class="line">  expect(wrapper.find(&#x27;.right-btn&#x27;)).toHaveLength(1);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这里我们使用了 shallow，其实也可以使用 mount。</p>
<p>shallow 和 mount 的区别，就是 shallow 只会渲染被测试的 React 组件这一层，不会渲染子组件；而 mount 则是完整地渲染 React 组件包括其所有子组件，包括触发 componentDidMount 生命周期函数。</p>
<p>原则上，能用 shallow 就尽量用 shallow，首先是为了测试性能考虑，其次是可以减少组件之间的影响，比如，一个组件 Foo 有子组件 Bar，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const Foo = () =&gt; ()</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">       &#123;/* other logic */</span><br><span class="line">       &lt;Bar /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果用 mount 去渲染 Foo，会连带 Bar 一起完全渲染，如果 Bar 出了什么毛病，那 Foo 的单元测试也过不了；如果用 shallow，只知道 Bar 曾经被用，即使 Bar 哪里出了问题，也不影响 Foo 的单元测试。</p>
<p>这并不是说我们就不管 Bar，Bar 的质量会由它自己的单元测试来检验，这就引出下一个话题——代码覆盖率。</p>
<p><strong>代码覆盖率</strong></p>
<p>你不能给自己的程序随便写几个单元测试，就说自己的代码已经测试好了，就像上面我只给 ControlButtons 组件写了一个测试用例，我并不能说整个秒表应用已经通过了测试。</p>
<p>你的代码测试覆盖率只有达到一定程度，才好说自己的代码已经被测试了。</p>
<p>剩下来就是一个纠结的问题：代码测试的覆盖率应该达到多少才算够？</p>
<p>以我个人的经验，代码覆盖率必须达到 100%，也就是说，一个应用不光所有的单元测试都要通过，而且所有单元测试都必须覆盖到代码 100% 的角落。</p>
<p>如果对覆盖率的要求低于 100%，时间一长，质量必定会越来越下滑。</p>
<p>遇到一个不好测试的代码，开发者倾向于不去考虑如何重构代码提高可测试性，而是直接忽略这部分代码不去测试，反正不要求 100% 嘛；遇到工期比较紧的时候，甚至会进一步降低代码覆盖率要求，用牺牲质量来加快开发速度，反正不要求 100% 嘛。</p>
<p>所以，如果你真的对代码质量认真负责的话，请坚守 100% 代码覆盖率的底线！</p>
<p>在 create-react-app 创造的应用中，已经自带了代码覆盖率的支持，运行下面的命令，不光会运行所有单元测试，也会得到覆盖率汇报</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm test -- --coverage</span><br></pre></td></tr></table></figure>

<blockquote>
<p>代码覆盖率包含四个方面：</p>
</blockquote>
<ul>
<li>语句覆盖率</li>
<li>逻辑分支覆盖率</li>
<li>函数覆盖率</li>
<li>代码行覆盖率</li>
</ul>
<p>只有四个方面都是 100%，才算真的 100%。</p>
<h2 id="五、React-状态管理"><a href="#五、React-状态管理" class="headerlink" title="五、React 状态管理"></a>五、React 状态管理</h2><h3 id="5-1-组件状态"><a href="#5-1-组件状态" class="headerlink" title="5.1 组件状态"></a>5.1 组件状态</h3><p>React 其实就是这样一个公式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UI = f(data)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>f 的参数 data，除了 props，就是 state。props 是组件外传递进来的数据，state 代表的就是 React 组件的内部状</p>
</blockquote>
<p><strong>为什么要了解 React 组件自身状态管理</strong></p>
<ul>
<li>因为 React 组件自身的状态管理是基础，其他第三方工具都是在这个基础上构筑的，连基础都不了解，无法真正理解第三方工具</li>
<li>对于很多应用场景，React 组件自身的状态管理就足够解决问题，犯不上动用 Redux 和 MobX 这样的大杀器，简单问题简单处理，可以让代码更容易维护</li>
</ul>
<p><strong>组件自身状态 state</strong></p>
<p>什么数据放在 state 中</p>
<p>对于 React 组件而言，数据分为两种</p>
<ul>
<li><code>props</code></li>
<li><code>state</code></li>
</ul>
<p>二者的区别显而易见，简单说就是，props 是外部传给组件的数据，而 state 是组件自己维护的数据，对外部是不可见的。</p>
<p>所以，判断某个数据以 props 方式存在，还是以 state 方式存在，并不难，只需要判断这个状态是否是组件内部状态。</p>
<p>一个经常被问到的问题，就是为什么不把组件的数据直接存放在组件类的成员变量中？比如像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Foo extends React.Component &#123;</span><br><span class="line">  foo = &#x27;foo&#x27;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;React.Fragment&gt;&#123;this.foo&#125;&lt;/React.Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>像上面，数据存在 this.foo 中，而不是存在 this.state.foo 中，当这个组件渲染的时候，当然 this.foo 的值也就被渲染出来了，问题是，更新 this.foo 并不会引发组件的重新渲染，这很可能不是我们想要的。</p>
</blockquote>
<p>所以，判断一个数据应该放在哪里，用下面的原则</p>
<ul>
<li>如果数据由外部传入，放在 props 中</li>
<li>如果是组件内部状态，是否这个状态更改应该立刻引发一次组件重新渲染？如果是，放在 state 中；不是，放在成员变量中</li>
</ul>
<p><strong>修改 state 的正确方式</strong></p>
<p>组件自身的状态可以通过 this.state 读到，this.state 本身就是一个对象，但是修改状态不应该通过直接修改 this.state 对象来完成。因为，我们修改 state，当然不只是想修改这个对象的值，而是想引发 React 组件的重新渲染。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.state.foo = &#x27;bar&#x27;; //错误的方式</span><br><span class="line"></span><br><span class="line">this.setState(&#123;foo:&#x27;bar&#x27;&#125;); //正确的方式</span><br></pre></td></tr></table></figure>

<p>如上面代码所示，如果只是修改 this.state，那改了也就只是改了这个对象，其他的什么都不会发生；如果使用 setState 函数，那不光修改 state，还能引发组件的重新渲染，在重新渲染中就会使用修改后的 state，这也就是达到根据 state 改变公式左侧 UI 的目的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UI = f(state)</span><br></pre></td></tr></table></figure>

<p>state 改变引发重新渲染的时机</p>
<p>现在我们知道应该用 setState 函数来修改组件 state，而且可以引发组件重新渲染，有意思的是，并不是一次 setState 调用肯定会引发一次重新渲染。</p>
<p>这是 React 的一种性能优化策略，如果 React 对每一次 setState 都立刻做一次组件重新渲染，那代价有点大，比如下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;count: 1&#125;);</span><br><span class="line">this.setState(&#123;caption: &#x27;foo&#x27;&#125;);</span><br><span class="line">this.setState(&#123;count: 2&#125;);</span><br></pre></td></tr></table></figure>

<p>连续的同步调用 setState，第三次还覆盖了第一次调用的效果，但是效果只相当于调用了下面这样一次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;count: 2, caption: &#x27;foo&#x27;&#125;);</span><br></pre></td></tr></table></figure>

<p>虽然明智的开发者不会故意连续写三个 setState 调用，但是代码一旦写得复杂，可能有多个 setState 分布在一次执行的不同代码片段中，还是会同步连续调用 setState，这时候，如果真的每个 setState 都引发一次重新渲染，实在太浪费了。</p>
<p>React 非常巧妙地用任务队列解决了这个问题，可以理解为每次 setState 函数调用都会往 React 的任务队列里放一个任务，多次 setState 调用自然会往队列里放多个任务。React 会选择时机去批量处理队列里执行任务，当批量处理开始时，React 会合并多个 setState 的操作，比如上面的三个 setState 就被合并为只更新 state 一次，也只引发一次重新渲染。</p>
<p>因为这个任务队列的存在，React 并不会同步更新 state，所以，在 React 中，setState 也不保证同步更新 state 中的数据。</p>
<p><strong>state 不会被同步修改</strong></p>
<p>简单说来，调用 setState 之后的下一行代码，读取 this.state 并不是修改之后的结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(this.state.count);// 修改之前this.state.count为0</span><br><span class="line">this.setState(&#123;count: 1&#125;)</span><br><span class="line">console.log(this.state.count);// 在这里this.state.count依然为0</span><br></pre></td></tr></table></figure>

<p>这乍看是很让人费解的结果，但是如果你理解了上面 React 任务队列的设计，一切也不难理解。</p>
<p>setState 只是给任务队列里增加了一个修改 this.state 的任务，这个任务并没有立即执行，所以 this.state 并不会立刻改变。</p>
<p>好吧，其实问题也没有那么简单，上面我所举的例子中，都假设 setState 是由 React 的生命周期函数或者事件处理函数中同步调用，这种情况下 setState 不会立即同步更新 state 和重新渲染，但是，如果调用 setState 由其他条件引发，就不是这样了。</p>
<p>看下面的代码，结果可能会出乎你的所料：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  this.setState(&#123;count: 2&#125;); //这会立刻引发重新渲染</span><br><span class="line">  console.log(this.state.count); //这里读取的count就是2</span><br><span class="line">&#125;, 0);</span><br></pre></td></tr></table></figure>

<p>为什么 setTimeout 能够强迫 setState 同步更新 state 呢？</p>
<p>可以这么理解，当 React 调用某个组件的生命周期函数或者事件处理函数时，React 会想：“嗯，这一次函数可能调用多次 setState，我会先打开一个标记，只要这个标记是打开的，所有的 setState 调用都是往任务队列里放任务，当这一次函数调用结束的时候，我再去批量处理任务队列，然后把这个标记关闭。”</p>
<p>因为 setTimeout 是一个 JavaScript 函数，和 React 无关，对于 setTimeout 的第一个函数参数，这个函数参数的执行时机，已经不是 React 能够控制的了，换句话说，React 不知道什么时候这个函数参数会被执行，所以那个“标记”也没有打开。</p>
<p>当那个“标记”没有打开时，setState 就不会给任务列表里增加任务，而是强行立刻更新 state 和引发重新渲染。这种情况下，React 认为：“这个 setState 发生在自己控制能力之外，也许开发者就是想要强行同步更新呢，宁滥勿缺，那就同步更新了吧。”</p>
<p>知道这个“技巧”之后，可能会有开发者说：好啊，那么以后我就用 setTimeout 来调用 setState 吧，能够立刻更新 state，多好！</p>
<p>我劝你不要这么做。</p>
<p>就像上面所说，React 选择不同步更新 state，是一种性能优化，如果你用上 setTimeout，就没机会让 React 优化了。</p>
<p>而且，每当你觉得需要同步更新 state 的时候，往往说明你的代码设计存在问题，绝大部分情况下，你所需要的，并不是“state 立刻更新”，而是，“确定 state 更新之后我要做什么”，这就引出了 setState 另一个功能</p>
<p><strong>setState 的第二个参数</strong></p>
<blockquote>
<p>setState 的第二个参数可以是一个回调函数，当 state 真的被修改时，这个回调函数会被调用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(this.state.count); // 0</span><br><span class="line">this.setState(&#123;count: 1&#125;, () =&gt; &#123;</span><br><span class="line">    console.log(this.state.count); // 这里就是1了</span><br><span class="line">&#125;)</span><br><span class="line">console.log(this.state.count); // 依然为0</span><br></pre></td></tr></table></figure>

<p>当 setState 的第二个参数被调用时，React 已经处理完了任务列表，所以 this.state 就是更新后的数据。</p>
<p>如果需要在 state 更新之后做点什么，请利用第二个参数。</p>
<p><strong>函数式 setState</strong></p>
<p>不管怎么说，setState 不能同步更新的确会带来一些麻烦，尤其是多个 setState 调用之间有依赖关系的时候，很容易写错代码。</p>
<p>一个很典型的例子，当我们不断增加一个 state 的值时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;count: this.state.count + 1&#125;);</span><br><span class="line">this.setState(&#123;count: this.state.count + 1&#125;);</span><br><span class="line">this.setState(&#123;count: this.state.count + 1&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的代码表面上看会让 this.state.count 增加 3，实际上只增加了 1，因为 setState 没有同步更新 this.state 啊，所以给任务队列加的三个任务都是给 this.state.count 同一个值而已。</p>
<p>面对这种情况，我们很自然地想到，如果任务列表中的任务不只是给 state 一个固定数据，如果任务列表里的“任务”是一个函数，能够根据当前 state 计算新的状态，那该多好！</p>
<p>实际上，setState 已经支持这种功能，到现在为止我们给 setState 的第一个参数都是对象，其实也可以传入一个函数。</p>
<p>当 setState 的第一个参数为函数时，任务列表上增加的就是一个可执行的任务函数了，React 每处理完一个任务，都会更新 this.state，然后把新的 state 传递给这个任务函数。</p>
<p>setState 第一个参数的形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function increment(state, props) &#123;</span><br><span class="line">  return &#123;count: state.count + 1&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这是一个纯函数，不光接受当前的 state，还接受组件的 props，在这个函数中可以根据 state 和 props 任意计算，返回的结果会用于修改 this.state。</p>
<p>如此一来，我们就可以这样连续调用 setState：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState(increment);</span><br><span class="line">this.setState(increment);</span><br><span class="line">this.setState(increment);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用这种函数式方式连续调用 setState，就真的能够让 this.state.count 增加 3，而不只是增加 1。</p>
</blockquote>
<h3 id="5-2-Mobx-使用模式"><a href="#5-2-Mobx-使用模式" class="headerlink" title="5.2 Mobx 使用模式"></a>5.2 Mobx 使用模式</h3><p><strong>理解 Mobx</strong></p>
<blockquote>
<p>虽然 Mobx 和 Redux 有很大不同，但是至少还有一个共同点——这两个工具都和 React 没有任何直接关系，只不过凑巧 React 社区大量使用它们罢了。从技术上说，Mobx 和 Redux 都是中立的状态管理工具，他们能够应用于 React，也可以用于其他需要状态管理的场景</p>
</blockquote>
<p>我们用 Mobx 来实现一个很简单的计数工具，首先，需要有一个对象来记录计数值，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123;observable&#125; from &#x27;mobx&#x27;;</span><br><span class="line"></span><br><span class="line">const counter = observable(&#123;</span><br><span class="line">  count: 0</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，counter 是一个对象，其实就是用 observable 函数包住一个普通 JavaScript 对象，但是 observable 的介入，让 counter 对象拥有了神力。</p>
<p>我们用最简单的代码来展示这种“神力”，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123;autorun&#125; from &#x27;mobx&#x27;;</span><br><span class="line"></span><br><span class="line">window.counter = counter;</span><br><span class="line"></span><br><span class="line">autorun(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;#count&#x27;, counter.count);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>把 counter 赋值给 window.counter，是为了让我们在 Chrome 的开发者界面可以访问。用 autorun 包住了一个函数，这个函数输出 counter.count 的值，这段代码的作用，我们很快就能看到。</p>
<p>在 Chrome 的开发者界面，我们可以直接访问 window.counter.count，神奇之处是，如果我们直接修改 window.counter.count 的值，可以直接触发 autorun 的函数参数！</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/29/166bf8e6c419c97e" alt="img"></p>
<p>这个现象说明，mobx 的 observable 拥有某种“神力”，任何对这个对象的修改，都会立刻引发某些函数被调用。和 observable 这个名字一样，被包装的对象变成了“被观察者”，而被调用的函数就是“观察者”，在上面的例子中，autorun 的函数参数就是“观察者”。</p>
<p>Mobx 这样的功能，等于实现了设计模式中的“观察者模式”（Observer Pattern），通过建立 observer 和 observable 之间的关联，达到数据联动。不过，传统的“观察者模式”要求我们写代码建立两者的关联，也就是写类似下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observable.register(observer);</span><br></pre></td></tr></table></figure>

<p>Mobx 最了不起之处，在于不需要开发者写上面的关联代码，Mobx自己通过解析代码就能够自动发现 observer 和 observable 之间的关系。</p>
<p>我们很自然想到，如果让我们的数据拥有这样的“神力”，那我们就不用在修改完数据之后，再费心去调用某些函数使用这些数据了，数据管理会变得十分轻松。</p>
<p><strong>decorator</strong></p>
<p>因为 Mobx 的作用就是把简单的对象赋予神力，总要有一种方法能够在不改变对象代码的前提，去改变对象的行为，这就用得上“装饰者模式”（Decorator Pattern）。</p>
<p>单独说“装饰者模式”，这只是面向对象编程思想下的一种模式，不过对 JavaScript 语言而言，就不只是一种模式，而是一种语言特性，它在语法上对这种模式提供了强大的支持，所谓强大，就是指使用起来代码极其简洁。</p>
<p>根据 JavaScript 语法，我们可以这样创造一个 decorator，叫做 log：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function log(target, name, descriptor) &#123;</span><br><span class="line">  console.log(&#x27;#target&#x27;, target);</span><br><span class="line">  console.log(&#x27;#name&#x27;, name);</span><br><span class="line">  console.log(&#x27;#descriptor&#x27;, descriptor);</span><br><span class="line">  return descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，很明显这个 decorator 什么实质的事情都没做，只是用 console.log 输出了三个参数秀了一下存在感，最后返回的 descriptor，就是被这个『装饰者』所『装饰』的对象。</p>
<p>下面是使用这个 decorator 的代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@log</span><br><span class="line">class Bar &#123;</span><br><span class="line">  @log</span><br><span class="line">  bar() &#123;</span><br><span class="line">    console.log(&#x27;bar&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，@ 符号就是使用 decorator 的标志，将 @log 作用于一个类 Bar，那么最后得到的 Bar 其实是调用 log 函数返回的结果；将 @log 作用于一个类成员 @bar，最后得到的 bar 同样是调用 log 函数之后得到的结果。可见，如果我们巧妙地编写 log 函数，控制返回的结果，就可以操纵被『装饰』的类或者成员。</p>
<p>编写 decorator 是一个复杂的过程，也超出了这本小册的范围，有兴趣的读者可以自行研究。在这里，读者只需要知道，虽然使用 Mobx 并不是必须使用 decorator，但是使用 decorator 会让 Mobx 的应用代码简洁易读很多</p>
<p><strong>用 decorator 来使用 Mobx</strong></p>
<p>还是以 Counter 为例，看如何用 decorator 使用 Mobx，我们先看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import &#123;observable&#125; from &#x27;mobx&#x27;;</span><br><span class="line">import &#123;observer&#125; from &#x27;mobx-react&#x27;;</span><br><span class="line"></span><br><span class="line">@observer</span><br><span class="line">class Counter extends React.Component &#123;</span><br><span class="line">  @observable count = 0;</span><br><span class="line"></span><br><span class="line">  onIncrement = () =&gt; &#123;</span><br><span class="line">    this.count ++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onDecrement = () =&gt; &#123;</span><br><span class="line">    this.count --;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate() &#123;</span><br><span class="line">    console.log(&#x27;#enter componentWillUpdate&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return(</span><br><span class="line">      &lt;CounterView</span><br><span class="line">        caption=&quot;With decorator&quot;</span><br><span class="line">        count=&#123;this.count&#125;</span><br><span class="line">        onIncrement=&#123;this.onIncrement&#125;</span><br><span class="line">        onDecrement=&#123;this.onDecrement&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，Counter 这个 React 组件自身是一个 observer，而 observable 是 Counter 的一个成员变量 count。</p>
<p>注意 observer 这 个decorator 来自于 mobx-react，它是 Mobx 世界和 React 的桥梁，被它“装饰”的组件，只要用到某个被 Mobx 的 observable “装饰”过的数据，自然会对这样的数据产生反应。所以，只要 Counter 的 count 成员变量一变化，就会引发 Counter 组件的重新渲染。</p>
<p>可以注意到，Counter 的代码中并没有自己的 state，其实，被 observer 修饰过之后，Counter 被强行”注入”了 state，只不过我们看不见而已。</p>
<p><strong>独立的 Store</strong></p>
<p>虽然把 observer 和 observable 集中在一个 React 组件中可行，但是，这也让 observable 的状态被封存在了 React 组件内，那我们直接用 React 自身的 state 管理也能解决问题，所以，这样使用 Mobx 意义不大。</p>
<p>更多适用于 Mobx 的场合，就和适用于 Redux 的场合一样，是一个状态需要多个组件共享，所以 observable 一般是在 React 组件之外。</p>
<p>我们重写一遍 Counter 组件，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const store = observable(&#123;</span><br><span class="line">  count: 0</span><br><span class="line">&#125;);</span><br><span class="line">store.increment = function() &#123;</span><br><span class="line">  this.count ++;</span><br><span class="line">&#125;;</span><br><span class="line">store.decrement = function() &#123;</span><br><span class="line">  this.count --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@observer // this decorator is must</span><br><span class="line">class Counter extends React.Component &#123;</span><br><span class="line">  onIncrement = () =&gt; &#123;</span><br><span class="line">    store.increment();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onDecrement = () =&gt; &#123;</span><br><span class="line">    store.decrement();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return(</span><br><span class="line">      &lt;CounterView</span><br><span class="line">        caption=&quot;With external state&quot;</span><br><span class="line">        count=&#123;store.count&#125;</span><br><span class="line">        onIncrement=&#123;this.onIncrement&#125;</span><br><span class="line">        onDecrement=&#123;this.onDecrement&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到，我们把 count 提到组件之外，甚至就把它叫做 store，这延续的是 Redux 的命名方法</p>
</blockquote>
<p><strong>总结</strong></p>
<ul>
<li>Mobx 的基本功能就是“观察者模式”</li>
<li>decorator 是“装饰者模式”在 JavaScript 语言中的实现</li>
<li>Mobx 通常利用 decorator 来使用</li>
</ul>
<h3 id="5-3-不同方式对比"><a href="#5-3-不同方式对比" class="headerlink" title="5.3 不同方式对比"></a>5.3 不同方式对比</h3><p><strong>Mobx 和 Redux 的比较</strong></p>
<p>Mobx 和 Redux 的目标都是管理好应用状态，但是最根本的区别在于对数据的处理方式不同。</p>
<p>Redux 认为，数据的一致性很重要，为了保持数据的一致性，要求Store 中的数据尽量范式化，也就是减少一切不必要的冗余，为了限制对数据的修改，要求 Store 中数据是不可改的（Immutable），只能通过 action 触发 reducer 来更新 Store。</p>
<p>Mobx 也认为数据的一致性很重要，但是它认为解决问题的根本方法不是让数据范式化，而是不要给机会让数据变得不一致。所以，Mobx 鼓励数据干脆就“反范式化”，有冗余没问题，只要所有数据之间保持联动，改了一处，对应依赖这处的数据自动更新，那就不会发生数据不一致的问题。</p>
<p>值得一提的是，虽然 Mobx 最初的一个卖点就是直接修改数据，但是实践中大家还是发现这样无组织无纪律不好，所以后来 Mobx 还是提供了 action 的概念。和 Redux 的 action 有点不同，Mobx 中的 action 其实就是一个函数，不需要做 dispatch，调用就修改对应数据，在上面的代码中，increment 和 decrement 就是 action。</p>
<p>如果想强制要求使用 action，禁止直接修改 observable 数据，使用 Mobx 的 configure，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123;configure&#125; from &#x27;mobx&#x27;;</span><br><span class="line"></span><br><span class="line">configure(&#123;enforceActions: true&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>总结一下 Redux 和 Mobx 的区别，包括这些方面：</strong></p>
<ul>
<li>Redux 鼓励一个应用只用一个 Store，Mobx 鼓励使用多个 Store；</li>
<li>Redux 使用“拉”的方式使用数据，这一点和 React是一致的，但 Mobx 使用“推”的方式使用数据，和 RxJS 这样的工具走得更近；</li>
<li>Redux 鼓励数据范式化，减少冗余，Mobx 容许数据冗余，但同样能保持数据一致。</li>
</ul>
<h2 id="六、React-Router"><a href="#六、React-Router" class="headerlink" title="六、React Router"></a>六、React Router</h2><p>随着 AJAX 技术的成熟，现在单页应用（Single Page Application）已经是前端网页界的标配，名为“单页”，其实在设计概念上依然是多页的界面，只不过从技术层面上页之间的切换是没有整体网页刷新的，只需要做局部更新。</p>
<p>要实现“单页应用”，一个最要紧的问题就是做好“路由”（Routing)，也就是处理好下面两件事：</p>
<ul>
<li>把 URL 映射到对应的页面来处理；</li>
<li>页面之间切换做到只需局部更新。</li>
</ul>
<p><strong>react router v4 的动态路由</strong></p>
<ul>
<li>我们现在说到 react-router，基本上都是在说 react-router 的第 4 版，也就是 v4。这个 v4 很有意思，它完全推翻了之前 v3 的做法。可以说，react-router 的 v3 和 v4 版完完全全是不同的两个工具，两者差距实在太大。</li>
<li>其实当初 v3 也已经很优秀很热门了，但是 react-router 的开发者不满意，他们认为 v3 还是落入了“静态路由”的窠臼，所以在 v4 中 react-router 做到了“动态路由”的功能。</li>
<li>所谓“静态路由”，就是说路由规则是固定的，无论 express、Angular 还是 Rails 等业界响当当的框架，都用的是静态路由。以 express 为例，路由规则差不多是这么写的：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#x27;/&#x27;, Home);</span><br><span class="line">app.get(&#x27;/product/:id&#x27;, Product);</span><br><span class="line">app.get(&#x27;/about&#x27;, About);</span><br></pre></td></tr></table></figure>

<p>对于大部分应用，支持这样的路由规则真的是足够了，但是，react-router 的开发者觉得这样还不够好，要支持“动态路由”才是最好。</p>
<p>所谓动态路由，指的是路由规则不是预先确定的，而是在渲染过程中确定的。因为 react-router 的定位就是专供 React 应用服务，而 React 的世界中一切皆为组件，所以 react-router v4 就完全用 React 组件来实现路由功能。</p>
<p>不得不承认，虽然 react-router 的开发者是挺折腾的，但是他们的确是领悟了 React 的精髓，而且在 react-router 中把 React 的哲学发挥到了极致。</p>
<p>接下来，我们通过一个很简单的例子来说明 react-router v4 如何工作的，然后在这个例子的基础上介绍“动态路由”。</p>
<p><strong>React Router 实例</strong></p>
<p>安装包 react-router-dom</p>
<p>create-react-app 产生的应用默认为不支持多个页面，但还是在 README 文件中友情推荐了一下 react-router 来增强功能，可见 react-router 影响力之大。</p>
<p>不过，我们并不需要安装 react-router 这个 npm 包，因为 react-router 为了支持 Web 和 React Native 出了两个包—— react-router-dom 和 react-router-native ，我们只关心 Web，所以只需要安装 react-router-dom 。这个 react-router-dom 依赖于 react-router ，所以 react-router 也会被自动安装上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-router-dom</span><br></pre></td></tr></table></figure>

<p><strong>HashRouter 还是 BrowserRouter</strong></p>
<p>react-router 的工作方式，是在组件树顶层放一个 Router 组件，然后在组件树中散落着很多 Route 组件（注意比 Router 少一个“r”），顶层的 Router 组件负责分析监听 URL 的变化，在它保护伞之下的 Route 组件可以直接读取这些信息。</p>
<p>很明显，Router 和 Route 的配合，就是之前我们介绍过的“提供者模式”，Router 是“提供者”，Route是“消费者”。</p>
<p>更进一步，Router 其实也是一层抽象，让下面的 Route 无需各种不同 URL 设计的细节，不要以为 URL 就一种设计方法，至少可以分为两种。</p>
<p>第一种很自然，比如 &#x2F; 对应 Home 页，&#x2F;about 对应 About 页，但是这样的设计需要服务器端渲染，因为用户可能直接访问任何一个 URL，服务器端必须能对 &#x2F;的访问返回 HTML，也要对 &#x2F;about 的访问返回 HTML。</p>
<p>第二种看起来不自然，但是实现更简单。只有一个路径 &#x2F;，通过 URL 后面的 # 部分来决定路由，&#x2F;#&#x2F; 对应 Home 页，&#x2F;#&#x2F;about 对应 About 页。因为 URL 中#之后的部分是不会发送给服务器的，所以，无论哪个 URL，最后都是访问服务器的 &#x2F; 路径，服务器也只需要返回同样一份 HTML 就可以，然后由浏览器端解析 # 后的部分，完成浏览器端渲染。</p>
<p>在 react-router，有 BrowserRouter 支持第一种 URL，有 HashRouter 支持第二种 URL。</p>
<p>因为 create-react-app 产生的应用默认不支持服务器端渲染，为了简单起见，我们在下面的例子中使用 HashRouter，在实际产品中，其实最好还是用 BrowserRouter，这样用户体验更好。</p>
<p>修改index.js文件，增加下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123;HashRouter&#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;HashRouter&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/HashRouter&gt;,</span><br><span class="line">  document.getElementById(&#x27;root&#x27;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>把 Router 用在 React 组件树的最顶层，这是最佳实践。因为将来我们如果想把 HashRouter 换成 BrowserRouter，组件 App 以下几乎不用任何改变。</p>
<p><strong>使用 Link</strong></p>
<p>对于单页应用，需要在不同“页面”之间切换，往往需要一个“导航栏”，我们在这里也实现一个简单的导航栏。</p>
<p>在App.js中，我们让网页由两个组件 Navigation 和 Content 组成， Navigation 就是导航栏，而 Content 是具体内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">        &lt;Navigation /&gt;</span><br><span class="line">        &lt;Content /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们计划只增加两个页面，在 Navigation 中就应该有两个链接，但是，如果我们简单使用 HTML 的 标签那就错了，用户点击 标签缺省行为是网页跳转，这违背了“单页应用”的原则。虽然对于 HashRouter 使用的是没有网页跳转的 #，但是为了将来可以无缝切换为 BrowserRouter ，我们也不能使用 <code>[</code>](#about) 这样的标签。</li>
<li>正确的解法是用 react-router 提供的 Link 组件，虽然 Link 最终还是渲染为 标签，但这是有神力的 标签，用户点击时，react-router 可以知晓这是一个单页应用的链接，不用网页跳转只做局部页面更新。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const ulStyle = &#123;</span><br><span class="line">  &#x27;list-style-type&#x27;: &#x27;none&#x27;,</span><br><span class="line">  margin: 0,</span><br><span class="line">  padding: 0,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const liStyle = &#123;</span><br><span class="line">  display: &#x27;inline-block&#x27;,</span><br><span class="line">  width: &#x27;60px&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const Navigation = () =&gt; (</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;nav&gt;</span><br><span class="line">      &lt;ul style=&#123;ulStyle&#125;&gt;</span><br><span class="line">        &lt;li style=&#123;liStyle&#125;&gt;&lt;Link to=&#x27;/&#x27;&gt;Home&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li style=&#123;liStyle&#125;&gt;&lt;Link to=&#x27;/about&#x27;&gt;About&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/nav&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>使用 Route 和 Switch</strong></p>
<p>我们来看 Content 这个组件，这里会用到 react-router 最常用的两个组件 Route 和 Switch。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Content = () =&gt; (</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">      &lt;Route exact path=&#x27;/&#x27; component=&#123;Home&#125;/&gt;</span><br><span class="line">      &lt;Route path=&#x27;/about&#x27; component=&#123;About&#125;/&gt;</span><br><span class="line">    &lt;/Switch&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>Route 组件的 path 属性用于匹配路径，因为我们需要匹配 &#x2F; 到 Home，匹配 &#x2F;about 到 About，所以肯定需要两个 Route，但是，我们不能这么写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&#x27;/&#x27; component=&#123;Home&#125;/&gt;</span><br><span class="line">&lt;Route path=&#x27;/about&#x27; component=&#123;About&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p>如果按照上面这么写，当访问 &#x2F;about 页面时，不光匹配 &#x2F;about，也配中 &#x2F;，界面上会把 Home 和 About 都渲染出来的。</p>
<p>解决方法，可以在想要精确匹配的 Route 上加一个属性 exact，或者使用 Switch 组件。</p>
<p>可以把 Switch 组件看做是 JavaScript 的 switch 语句，像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">switch (条件) &#123;</span><br><span class="line">  case 1: 渲染1; break;</span><br><span class="line">  case 2: 渲染2; break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上往下找第一个匹配的 Route，匹配中了之后，立刻就 break，不继续这个 Switch 下其他的 Route 匹配了。</p>
<p>可以看到，react-router 巧妙地用 React 组件实现了路由的所有逻辑，印证了那句话：React 世界里一切都是组件。</p>
<p><strong>动态路由</strong></p>
<p>在了解了 react-router的基本路由功能之后，再来理解“动态路由”就容易了。</p>
<p>假设，我们增加一个新的页面叫 Product，对应路径为 &#x2F;product，但是只有用户登录了之后才显示。如果用静态路由，我们在渲染之前就确定这条路由规则，这样即使用户没有登录，也可以访问 product，我们还不得不在 Product 组件中做用户是否登录的检查。</p>
<p>如果用动态路由，则只需要在代码中的一处涉及这个逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route exact path=&#x27;/&#x27; component=&#123;Home&#125;/&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    isUserLogin() &amp;&amp;</span><br><span class="line">    &lt;Route exact path=&#x27;/product&#x27; component=&#123;Product&#125;/&gt;,</span><br><span class="line">  &#125;  </span><br><span class="line">  &lt;Route path=&#x27;/about&#x27; component=&#123;About&#125;/&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以用任何条件决定 <code>Route</code> 组件实例是否渲染，比如，可以根据页面宽度、设备类型决定路由规则，动态路由有了最大的自由度</p>
</blockquote>
<h2 id="七、服务器端渲染"><a href="#七、服务器端渲染" class="headerlink" title="七、服务器端渲染"></a>七、服务器端渲染</h2><h3 id="7-1-基本套路"><a href="#7-1-基本套路" class="headerlink" title="7.1 基本套路"></a>7.1 基本套路</h3><p><strong>为什么要服务器端渲染</strong></p>
<p>最近几年浏览器端框架很繁荣，以至于很多新入行的开发者只知道浏览器端渲染框架，都不知道存在服务器端渲染这回事，其实，网站应用最初全都是服务器端渲染，由服务器端用 PHP、Java 或者 Python 等其他语言产生 HTML 来给浏览器端解析。</p>
<p>相比于浏览器端渲染，服务器端渲染的好处是：</p>
<p>1、可以缩短“第一有意义渲染时间”（First-Meaningful-Paint-Time）。</p>
<p>如果完全依赖于浏览器端渲染，那么服务器端返回的 HTML 就是一个空荡荡的框架和对 JavaScript 的应用，然后浏览器下载 JavaScript，再根据 JavaScript 中的 AJAX 调用获取服务器端数据，再渲染出 DOM 来填充网页内容，总共需要三个 HTTP 或 HTTPS 请求。</p>
<p>如果使用服务器端渲染，第一个 HTTP&#x2F;HTTPS 请求返回的 HTML 里就包含可以渲染的内容了，这样用户第一时间就会感觉到“有东西画出来了”，这样的感知性能更好。</p>
<p>2、更好的搜索引擎优化（Search-Engine-Optimization，SEO）</p>
<p>大部分网站都希望自己能够出现在搜索引擎的搜索页前列，这个前提就是网页内容要能够被搜索引擎的爬虫正确抓取到。虽然 Google 这样的搜索引擎已经可以检索浏览器端渲染的网页，但毕竟不是全部搜索引擎都能做到，如果搜索引擎的爬虫只能拿到服务器端渲染的内容，完全浏览器端渲染就行不通了。</p>
<p>即使对于 Google，网页性能也是搜索排名的重要指标，如果通过服务器端渲染提高网页性能，网页的排名更可能靠前。</p>
<p>上面两点，就是服务器端渲染的主要意义。</p>
<p><strong>React 对服务器端渲染的支持</strong></p>
<p>因为 React 是声明式框架，所以，在渲染上对服务器端渲染非常友好。</p>
<p>假设我们我们要渲染一个以 App 为最根节点的组件树，浏览器端渲染的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<p>现在我们想要在服务器端渲染 App，如果使用 React v16 之前的版本，代码是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOMServer from &#x27;react-dom/server&#x27;;</span><br><span class="line"></span><br><span class="line">// 把产生html返回给浏览器端</span><br><span class="line">const html = ReactDOMServer.renderToString(&lt;Hello /&gt;);</span><br></pre></td></tr></table></figure>

<p>从 React v16 开始，上面的服务器端代码依然可以使用，但是也可以把 renderToString 替换为 renderToNodeStream，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOMServer from &#x27;react-dom/server&#x27;;</span><br><span class="line"></span><br><span class="line">// 把渲染内容以流的形式塞给response</span><br><span class="line">ReactDOMServer.renderToNodeStream(&lt;Hello /&gt;).pipe(response);</span><br></pre></td></tr></table></figure>

<p>此外，浏览器端代码也有一点变化，ReactDOM.render 依然可以使用，但是官方建议替换为 ReactDOM.hydrate，原来的 ReactDOM.render 将来会被废弃掉。</p>
<p>renderToString 的功能是一口气同步产生最终 HTML，如果 React 组件树很庞大，这样一个同步过程可能比较耗时。假设渲染完整 HTML 需要 500 毫秒，那么一个 HTTP&#x2F;HTTPS 请求过来，500 毫秒之后才返回 HTML，显得不大合适，这也是为什么 v16 提供了 renderToNodeStream 这个新 API 的原因。</p>
<p>renderToNodeStream 把渲染结果以“流”的形式塞给 response 对象（这里的 response 是 express 或者 koa 的概念），这意味着不用等到所有 HTML 都渲染出来了才给浏览器端返回结果，也许 10 毫秒内就渲染出来了网页头部，那就没必要等到 500 毫秒全部网页都出来了才推给浏览器，“流”的作用就是有多少内容给多少内容，这样用户只需要 10 毫秒多一点的延迟就可以看到网页内容，进一步改进了“第一有意义渲染时间”</p>
<p><strong>服务器端渲染的难点</strong></p>
<p>看到这里，你可能觉得服务器端渲染也太简单了，的确，因为 React 组件可以不必关心自己是在哪个端渲染，可以做到代码一次编写，到处都可以执行。但是，真的这么简单吗？</p>
<p>为了简化问题，上面的代码示例有意忽略了一个事实，那就是，应用往往需要外部服务器获取数据啊！</p>
<p>除非你的网页应用根本没有动态内容，不然你必须要考虑在服务器端怎么给 React 组件获取数据。</p>
<p>比如，你现在看到的掘金小册，为了渲染你所看到的页面，需要调用掘金小册的服务器 API 来获取这篇文章的内容。对于浏览器端渲染，在 componentDidMount 里调用 AJAX 就好了；对于服务器端渲染，要想产生 HTML 的包含内容，必须事先把数据准备好，也就是说，代码要是这样才行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOMServer from &#x27;react-dom/server&#x27;;</span><br><span class="line"></span><br><span class="line">callAPI().then(result =&gt; &#123;</span><br><span class="line">  const props = result;</span><br><span class="line">  ReactDOMServer.renderToNodeStream(&lt;Hello &#123;...props&#125;/&gt;).pipe(response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>最大的问题来了，如何给组件获取和提供数据呢？</p>
<p>解决了这个问题，才算真的解决了服务器端渲染的问题。</p>
<p><strong>“脱水”和“注水”8</strong></p>
<p>React 有一个特点，就是把内容展示和动态功能集中在一个组件中。比如，一个 Counter 组件既负责怎么画出内容，也要负责怎么响应按键点击，这当然符合软件高内聚性的原则，但是也给服务器端渲染带来更多的工作。</p>
<p>设想一下，如果只使用服务器端渲染，那么产生的只有 HTML，虽然能够让浏览器端画出内容，但是，没有 JavaScript 的辅助是无法响应用户交互事件的。对应 Counter 的例子，一个 Counter 组件在浏览器中也就渲染出一个数字两个按钮，用户点击 + 按钮或者 - 按钮，什么都不会发生。</p>
<p>很显然我们必须要在浏览器端赋予 Counter 组件一些“神力”，让它能够响应事件。那么怎么赋予 Counter 组件“神力”呢？其实我们已经做过这件事了，Counter 组件里面已经有对按钮事件的处理，我们所要做的只是让 Counter 组件在浏览器端重新执行一遍，也就是 mount 一遍就可以了。</p>
<blockquote>
<p>也就是说，如果想要动态交互效果，使用 React 服务器端渲染，必须也配合使用浏览器端渲染。</p>
</blockquote>
<p>现在问题变得更加有趣了，在服务器端我们给 Counter 一个初始值（这个值可以不是缺省的 0），让 Counter 渲染产生 HTML，这些 HTML 要传递给浏览器端，为了让 Counter 的 HTML“活”起来点击相应事件，必须要在浏览器端重新渲染一遍 Counter 组件。在浏览器端渲染 Counter 之前，用户就可以看见 Counter 组件的内容，但是无法点击交互，要想点击交互，就必须要等到浏览器端也渲染一次 Counter 之后。</p>
<p>接下来的一个问题，如果服务器端塞给 Counter 的数据和浏览器端塞给 Counter 的数据不一样呢？</p>
<p>在 React v16 之前，React 在浏览器端渲染之后，会把内容和服务器端给的 HTML 做一个比对。如果完全一样，那最好，接着用服务器端 HTML 就好了；如果有一丁点不一样，就会立刻丢掉服务器端的 HTML，重新渲染浏览器端产生的内容，结果就是用户可以看到界面闪烁。因为 React 抛弃的是整个服务器端渲染内容，组件树越大，这个闪烁效果越明显。</p>
<p>React 在 v16 之后，做了一些改进，不再要求整个组件树两端渲染结果分毫不差，但是如果发生不一致，依然会抛弃局部服务器端渲染结果。</p>
<blockquote>
<p>总之，如果用服务器端渲染，一定要让服务器端塞给 React 组件的数据和浏览器端一致。</p>
</blockquote>
<p>为了达到这一目的，必须把传给 React 组件的数据给保留住，随着 HTML 一起传递给浏览器网页，这个过程，叫做“脱水”（Dehydrate）；在浏览器端，就直接拿这个“脱水”数据来初始化 React 组件，这个过程叫“注水”（Hydrate）。</p>
<p>前面提到过 React v16 之后用 React.hydrate 替换 React.render，这个 hydrate 就是“注水”。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/2/166d20bf04d0775d" alt="img"></p>
<blockquote>
<p>总之，为了实现React的服务器端渲染，必须要处理好这两个问题：</p>
</blockquote>
<ul>
<li>脱水</li>
<li>注水</li>
</ul>
<p><strong>Facebook 未使用服务器端渲染</strong></p>
<p>值得一提的是，虽然 React 从最初版本就支持“服务器端渲染”，并且 React 的创建者 Facebook 也全力在自己的网站产品中使用 React，但他们自己却没有使用 React 的服务器端渲染功能。理由是，Facebook 已经在 PHP 上投入了很多资源，不打算放弃这些投入。</p>
<p>这里我当然不是批评 Facebook，实际上，Facebook 对 React 的支持是真心的，它在自己的网站上大范围使用 React，而不只是做出来后让外部使用者当小白鼠，这种全力投入也给了 React 使用者很大信心。但另一方面，因为 Facebook 自己不用 React 的服务器端渲染，如何利用这个功能，就缺乏一个官方参考标准了。</p>
<p>也许就是因为缺乏 Facebook 的官方标准，业界对服务器端渲染的解决方法层出不穷，不过，到目前看来，next.js 还是最佳方案</p>
<h3 id="7-2-理解-Next-js"><a href="#7-2-理解-Next-js" class="headerlink" title="7.2 理解 Next.js"></a>7.2 理解 Next.js</h3><p>我们已经知道了服务器端渲染的原理，你只需要搭建一个 Express 服务器，在服务器端手工打造『脱水』，在浏览器端做『注水』，完成某个页面的服务器端渲染并不难。</p>
<p>不过，服务器端渲染的问题并不这么简单，一个最直接的问题，就是怎么处理多个页面的『单页应用』（Single-Page-Application）？</p>
<p>所以单页应用，就是虽然用户感觉有多个页面，但是实现上只有一个页面，用户感觉到页面可以来回切换，但其实只是一个页面并没有完全刷新，只是局部界面更新而已。</p>
<p>假设一个单页应用有三个页面 Home、Prodcut 和 About，分别对应的的路径是 &#x2F;home、&#x2F;product 和 &#x2F;about，而且三个页面都依赖于 API 调用来获取外部数据。</p>
<p>现在我们要做服务器端渲染，如果只考虑用户直接在地址栏输入 &#x2F;home、&#x2F;product 和 &#x2F;about 的场景，很容易满足，按照上面说的套路做就是了。但是，这是一个单页应用，用户可以在 Home 页面点击链接无缝切换到 Product，这时候 Product 要做完全的浏览器端渲染。换句话说，每个页面都需要既支持服务器端渲染，又支持完全的浏览器端渲染，更重要的是，对于开发者来说，肯定不希望为了这个页面实现两套程序，所以必须有同时满足服务器端渲染和浏览器端渲染的代码表示方式。</p>
<p>读者可以思考一下什么样的代码表示合适，也可以直接往下，看看业界公认最科学的实现方式 Next.js 是如何做的。</p>
<p><strong>快速创建 Next.js 项目</strong></p>
<p>在说明 Next.js 的工作原理之前，我们先看怎么快速创建 Next.js 项目，这个问题用代码来说明会更顺畅。</p>
<p>我们也可以手工创建 Next.js 项目，不过更简单的方式是用自动化工具 create-next-app，这个 create-next-app 类似于 create-react-app，一个命令就创建一个可以运行的应用。</p>
<p>首先安装 create-next-app。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-next-app</span><br></pre></td></tr></table></figure>

<p>然后，就可以在你专门存放项目的目录下执行 create-next-app，产生一个使用 Next.js 的 React 应用，下面的命令创建一个叫 next_demo 的应用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-next-app next_demo</span><br></pre></td></tr></table></figure>

<p>进入新生成的项目目录 next_demo 里检查一下，可以看到文件结构非常简洁，pages 目录下是页面文件，package.json 中差不是下面这样，没有繁冗的 webpack 和 babel 依赖包，因为一切都被 Next.js 封装起来了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;create-next-example-app&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;next&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;next build&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;next start&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;next&quot;: &quot;^6.0.3&quot;,</span><br><span class="line">    &quot;react&quot;: &quot;^16.5.2&quot;,</span><br><span class="line">    &quot;react-dom&quot;: &quot;^16.5.2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然有不少框架都表示自己的功能很强大，但其中有很多框架的设计并不中立，用这些框架去开发某些特定应用或许还行，如果放到一个更大范围的应用类型中，就会发现无法满足要求，这样的框架通用性不足，开发者一定要谨慎使用。</p>
<p>讲良心话，Next.js 真的是一个通用性非常高的框架，因为 Next.js 完全遵从了 React 的技术哲学：一切皆为组件。</p>
<p>在 Next.js 中，创造一个页面，其实就是创造一个 React 组件，接下来我们看看如何创建一个页面。</p>
<p><strong>编写页面</strong></p>
<p>使用下面的命令启动 Next.js 应用，进入的是开发者模式，这时候对代码的改变，会立刻体现在网页上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p>请注意，这一点上 Next.js 的习惯用法和 create-react-app 产生的应用不一样。在 create-react-app 产生的应用中， npm run start 启动是开发者模式，但在 Next.js 应用中，习惯上 npm run start 以产品模式启动，所以要先运行 npm run build 然后才能运行 npm run start。</p>
<p>Next.js 遵从『协定优于配置』（convention over configuration）的设计原则，根据『协定』，在 pages 中每个文件对应一个网页文件，文件名对应的就是网页的路径名，比如 pages&#x2F;home.js 文件对应的就是 &#x2F;home 路径的页面，当然 pages&#x2F;index.js 比较特殊，对应的是默认根路径 &#x2F; 的页面。</p>
<p>我们修改 pages&#x2F;index.js，让它更简单一些，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line"></span><br><span class="line">const Home = (props) =&gt; (</span><br><span class="line">  &lt;h1&gt;</span><br><span class="line">    Hello World</span><br><span class="line">  &lt;/h1&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">export default Home</span><br></pre></td></tr></table></figure>

<p>这样会在页面上显示出一个 Hello World，而这个页面代码就是一个普通的 React 组件而已。</p>
<p>页面都是 React 组件，这就是 Next.js 的哲学。</p>
<p><strong>getInitialProps</strong></p>
<p>我们还是要回到本来的话题，如何优雅地实现服务器端渲染，上面的 Home 页面虽然能够渲染出完整包含 Hello World 的 HTML，但是并没有调用任何外部 API 资源，所以也没有异步操作，并不能体现服务器端渲染的难度。</p>
<p>我们用一个函数来实现异步操作，以此模拟调用 API 的延迟效果，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const timeout = (ms, result) =&gt; &#123;</span><br><span class="line">  return new Promise(resolve =&gt; setTimeout(() =&gt; resolve(result), ms));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>然后，我们利用这个 timeout 来获得展示网页所需的数据。比如说，获取用户名，那么我们的 Home 组件就要换一个写法，像下面那样，增加 getInitialProps 的定义：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const Home = (props) =&gt; (</span><br><span class="line">  &lt;h1&gt;</span><br><span class="line">    Hello &#123;props.userName&#125;</span><br><span class="line">  &lt;/h1&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Home.getInitialProps = async () =&gt; &#123;</span><br><span class="line">  return await timeout(200, &#123;userName: &#x27;Morgan&#x27;&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个 getiInitialProps 是 Next.js 最伟大的发明，它确定了一个规范，一个页面组件只要把访问 API 外部资源的代码放在 getInitialProps 中就足够，其余的不用管，Next.js 自然会在服务器端或者浏览器端调用 getInitialProps 来获取外部资源，并把外部资源以 props 的方式传递给页面组件。</p>
<p>注意 getInitialProps 是页面组件的静态成员函数，可以用下面的方法定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Home.getInitialProps = async () = &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以在组件类中加上 static 关键字定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Home extends React.Component &#123;</span><br><span class="line">  static async getInitialProps() &#123;</span><br><span class="line">     ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码，我么也可以注意到，getInitialProps 是一个 async 函数，所以，在 getInitialProps 函数中可以使用 await 关键字，用同步的方式编写异步逻辑。</p>
<p>我们可以这样来看待 getInitialProps，它就是 Next.js 对代表页面的 React 组件生命周期的扩充。React 组件的生命周期函数缺乏对异步操作的支持，所以 Next.js 干脆定义出一个新的生命周期函数 getInitialProps，在调用 React 原生的所有生命周期函数之前，Next.js 会调用 getInitialProps 来获取数据，然后把获得数据作为 props 来启动 React 组件的原生生命周期过程。</p>
<p><strong>这个生命周期函数的扩充十分巧妙，因为：</strong></p>
<ul>
<li>没有侵入 React 原生生命周期函数，以前的 React 组件该怎么写还是怎么写；</li>
<li>getInitialProps 只负责获取数据的过程，开发者不用操心什么时候调用 getInitialProps，依然是 React 哲学的声明式编程方式；</li>
<li>getInitialProps 是 async 函数，可以利用 JavaScript 语言的新特性，用同步的方式实现异步功能。</li>
</ul>
<p><strong>Next.js 的“脱水”和“注水”</strong></p>
<p>我们说过服务器端渲染的关键是如何“脱水”和“注水”，如果你对 Next.js 如何实现这两个关键点好奇（实际上你确实应该感到好奇），那么在浏览器中使用“显示网页源代码”就可以让你一目了然。</p>
<p>在网页的 HTML 中，可以看到类似下面的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  __NEXT_DATA__ = &#123;</span><br><span class="line">    &quot;props&quot;:&#123;</span><br><span class="line">      &quot;pageProps&quot;: &#123;&quot;userName&quot;:&quot;Morgan&quot;&#125;&#125;,</span><br><span class="line">      &quot;page&quot;:&quot;/&quot;,&quot;pathname&quot;:&quot;/&quot;,&quot;query&quot;:&#123;&#125;,&quot;buildId&quot;:&quot;-&quot;,&quot;assetPrefix&quot;:&quot;&quot;,&quot;nextExport&quot;:false,&quot;err&quot;:null,&quot;chunks&quot;:[]&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>Next.js 在做服务器端渲染的时候，页面对应的 React 组件的 getInitialProps 函数被调用，异步结果就是“脱水”数据的重要部分，除了传给页面 React 组件完成渲染，还放在内嵌 script 的 <strong>NEXT_DATA</strong> 中，这样，在浏览器端渲染的时候，是不会去调用 getInitialProps 的，直接通过 <strong>NEXT_DATA</strong> 中的“脱水”数据来启动页面 React 组件的渲染。</p>
<p>这样一来，如果 getInitialProps 中有调用 API 的异步操作，只在服务器端做一次，浏览器端就不用做了。</p>
<p>那么，getInitialProps 什么时候会在浏览器端调用呢？</p>
<p>当在单页应用中做页面切换的时候，比如从 Home 页切换到 Product 页，这时候完全和服务器端没关系，只能靠浏览器端自己了，Product页面的 getInitialProps 函数就会在浏览器端被调用，得到的数据用来开启页面的 React 原生生命周期过程。</p>
<p>关键点是，浏览器可能会直接访问 &#x2F;home 或者 &#x2F;product，也可能通过网页切换访问这两个页面，也就是说 Home 或者 Product 都可能被服务器端渲染，也可能完全只有浏览器端渲染，不过，这对应用开发者来说无所谓，应用开发者只要写好 getInitialProps，至于调用 getInitialProps 的时机，交给 Next.js 处理就好了。</p>
<p>你可以发明自己的服务器端框架，但很可能最后你发现，如果要做得通用性好，最后都会做到和 Next.js 一样的模式上来。</p>
<p>值得一提的是，getInitialProps 返回的应该是“纯数据”，也就是不要返回一个定制类的实例。比如，有一个类 Foo 有一个成员函数 bar，不要在 getInitialProps 返回一个 Foo 实例。不然，经过“脱水”和“注水”过程，网页组件获得的那个“Foo 实例”不再是你想的那个 Foo 实例了，它变成了一个纯粹的数据，不会包含成员函数 bar的。</p>
<h2 id="八、React-的未来（1）：-拥抱异步渲染"><a href="#八、React-的未来（1）：-拥抱异步渲染" class="headerlink" title="八、React 的未来（1）： 拥抱异步渲染"></a>八、React 的未来（1）： 拥抱异步渲染</h2><p><strong>同步渲染的问题</strong></p>
<p>长期以来，React 一直用的是同步渲染，这样对 React 实现非常直观方便，但是会带来性能问题。</p>
<p>假设有一个超大的 React 组件树结构，有 1000 个组件，每个组件平均使用 1 毫秒，那么，要做一次完整的渲染就要花费 1000 毫秒也就是 1 秒钟，然而 JavaScript 运行环境是单线程的，也就是说，React 用同步渲染方式，渲染最根部组件的时候，会同步引发渲染子组件，再同步渲染子组件的子组件……最后完成整个组件树。在这 1 秒钟内，同步渲染霸占 JavaScript 唯一的线程，其他的操作什么都做不了，在这 1 秒钟内，如果用户要点击什么按钮，或者在某个输入框里面按键，都不会看到立即的界面反应，这也就是俗话说的“卡顿”。</p>
<p>在同步渲染下，要解决“卡顿”的问题，只能是尽量缩小组件树的大小，以此缩短渲染时间，但是，应用的规模总是在增大的，不是说缩小就能缩小的，虽然我们利用定义 shouldComponentUpdate 的方法可以减少不必要的渲染，但是这也无法从根本上解决大量同步渲染带来的“卡顿”问题。</p>
<p><strong>异步渲染：两阶段渲染</strong></p>
<p>React Fiber 引入了异步渲染，有了异步渲染之后，React 组件的渲染过程是分时间片的，不是一口气从头到尾把子组件全部渲染完，而是每个时间片渲染一点，然后每个时间片的间隔都可去看看有没有更紧急的任务（比如用户按键），如果有，就去处理紧急任务，如果没有那就继续照常渲染。</p>
<p>根据 React Fiber 的设计，一个组件的渲染被分为两个阶段：第一个阶段（也叫做 render 阶段）是可以被 React 打断的，一旦被打断，这阶段所做的所有事情都被废弃，当 React 处理完紧急的事情回来，依然会重新渲染这个组件，这时候第一阶段的工作会重做一遍；第二个阶段叫做 commit 阶段，一旦开始就不能中断，也就是说第二个阶段的工作会稳稳当当地做到这个组件的渲染结束。</p>
<p>两个阶段的分界点，就是 render 函数。render 函数之前的所有生命周期函数（包括 render)都属于第一阶段，之后的都属于第二阶段。</p>
<p>开启异步渲染，虽然我们获得了更好的感知性能，但是考虑到第一阶段的的生命周期函数可能会被重复调用，不得不对历史代码做一些调整。</p>
<blockquote>
<p>在 React v16.3 之前，render 之前的生命周期函数（也就是第一阶段生命周期函数）包括这些：</p>
</blockquote>
<ul>
<li><code>componentWillReceiveProps</code></li>
<li><code>shouldComponentUpdate</code></li>
<li><code>componentWillUpdate</code></li>
<li><code>componentWillMount</code></li>
<li><code>render</code></li>
</ul>
<blockquote>
<p>下图是 React v16.3 之前的完整的生命周期函数图：</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/14/1670f0f2d4d06575" alt="img"></p>
<p>React 官方告诫开发者，虽然目前所有的代码都可以照常使用，但是未来版本中会废弃掉，为了将来，使用 React 的程序应该快点去掉这些在第一阶段生命函数中有副作用的功能。不得不说 React 真的很够意思，提前这么久告诉大家这个事情，让大家有足够的时间去修改自己的代码。</p>
<p>一个典型的错误用例，也是我被问到做多的问题之一：为什么不在 componentWillMount 里去做AJAX？componentWillMount 可是比 componentDidMount 更早调用啊，更早调用意味着更早返回结果，那样性能不是更高吗？</p>
<p>首先，一个组件的 componentWillMount 比 componentDidMount 也早调用不了几微秒，性能没啥提高；而且，等到异步渲染开启的时候，componentWillMount 就可能被中途打断，中断之后渲染又要重做一遍，想一想，在 componentWillMount 中做 AJAX 调用，代码里看到只有调用一次，但是实际上可能调用 N 多次，这明显不合适。相反，若把 AJAX 放在 componentDidMount，因为 componentDidMount 在第二阶段，所以绝对不会多次重复调用，这才是 AJAX 合适的位置（当然，React 未来有更好的办法，在下一小节 Suspense 中可以讲到）。</p>
<p><strong>getDerivedStateFromProps</strong></p>
<blockquote>
<p>到了 React v16.3，React 干脆引入了一个新的生命周期函数 getDerivedStateFromProps，这个生命周期函数是一个 static 函数，在里面根本不能通过 this 访问到当前组件，输入只能通过参数，对组件渲染的影响只能通过返回值。没错，getDerivedStateFromProps 应该是一个纯函数，React 就是通过要求这种纯函数，强制开发者们必须适应异步渲染。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line">  //根据nextProps和prevState计算出预期的状态改变，返回结果会被送给setState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到了 React v16.3，React 生命周期函数全图如下:</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/14/1670f0fc08e10440" alt="img"></p>
<p>注意，上图中并包含全部React生命周期函数，在React v16发布时，还增加了一个componentDidCatch，当异常发生时，一个可以捕捉到异常的componentDidCatch就排上用场了。不过，很快React觉着这还不够，在v16.6.0又推出了一个新的捕捉异常的生命周期函数getDerivedStateFromError。</p>
<p>如果异常发生在第一阶段（render阶段），React就会调用getDerivedStateFromError，如果异常发生在第二阶段（commit阶段），React会调用componentDidCatch。这个区别也体现出两个阶段的区分对待。</p>
<p><strong>适应异步渲染的组件原则</strong></p>
<blockquote>
<p>明白了异步渲染的来龙去脉之后，开发者就应该明白，现在写代码必须要为未来的某一次 React 版本升级做好准备，当 React 开启异步渲染的时候，你的代码应该做到在 render 之前最多只能这些函数被调用：</p>
</blockquote>
<ul>
<li>构造函数</li>
<li><code>getDerivedStateFromProps</code></li>
<li><code>shouldComponentUpdate</code></li>
</ul>
<p>幸存的这些第一阶段函数，除了构造函数，其余两个全都必须是纯函数，也就是不应该做任何有副作用的操作。</p>
<p>实际上，如果之前你的用法规范，除了 shouldComponentUpdate 不怎么使用第一阶段生命周期函数，你还会发现不怎么需要改动代码，比如 componentWillMount 中的代码移到构造函数中就可以了。但是如果用法错乱，比如滥用componentWillReceiveProps，那就不得不具体情况具体分析，从而决定这些代码移到什么位置。</p>
<p>开发者中一个普遍的误区，就是总想把任务往前提，提到靠前的生命周期函数去，就像我前面说过的在 componentWillMount 中做 AJAX。正确的做法是根据各函数的语义来放置代码，并不是越往前越好。</p>
<h2 id="九、React-的未来（2）：Suspense-带来的异步操作革命"><a href="#九、React-的未来（2）：Suspense-带来的异步操作革命" class="headerlink" title="九、React 的未来（2）：Suspense 带来的异步操作革命"></a>九、React 的未来（2）：Suspense 带来的异步操作革命</h2><p>上一节我们介绍了 Fiber 架构下的异步渲染机制，我们知道生命周期函数的修改是势在必行，那么，接下来呢？接下来 React 会有什么“大事”呢？</p>
<p>这个答案估计连 React 的核心开发者也在讨论中，不过从各种渠道信息看来，至少有两件“大事”在会在看得见的未来发生，那就是：</p>
<ul>
<li><code>Suspense</code></li>
<li><code>Hooks</code></li>
</ul>
<p>当然 React 增加的功能肯定远不止这点，将这两件“大事”在这里提出来，是因为它们对我们使用开发者的影响最大，会彻底改变我们的代码模式。</p>
<p>在写这本小册时，React 正式版是 v16.6.0，还只是 alpha 阶段，也许当你读到这本小册时，React 已经走得更远，但是你依然应该阅读这一小节，因为作为开发者你应该要明白技术演化的来龙去脉。</p>
<p>我们首先来了解 Suspense。Suspense 应用的场合就是异步数据处理，最常见的例子，就是通过 AJAX 从服务器获取数据，每一个 React 开发者都曾为这个问题纠结。</p>
<p>如果用一句话概括 Suspense 的功用，那就是：用同步的代码来实现异步操作。</p>
<p>而要理解 Suspense，我们先来体会一下 React 中做 AJAX 之类异步操作的痛苦</p>
<p><strong>React 同步操作的不足</strong></p>
<p>上一节介绍过，React 最初的设计，整个渲染过程都是同步的。同步的意思是，当一个组件开始渲染之后，就必须一口气渲染完，不能中断，对于特别庞大的组件树，这个渲染过程会很耗时，而且，这种同步处理，也会导致我们的代码比较麻烦。</p>
<p>当我们开始渲染某个组件的时候，假设这个组件需要从服务器获取数据，那么，要么由这个组件的父组件想办法拿到服务器的数据，然后通过 props 传递进来，要么就要靠这个组件自力更生来获取数据，但是，没有办法通过一次渲染完成这个过程，因为渲染过程是同步的，不可能让 React 等待这个组件调用 AJAX 获取数据之后再继续渲染。</p>
<blockquote>
<p>常用的做法，需要组件的 render 和 componentDidMount 函数配合。</p>
</blockquote>
<ul>
<li>在 componentDidMount 中使用 AJAX，在 AJAX 成功之后，通过 setState 修改自身状态，这会引发一次新的渲染过程。</li>
<li>在 render 函数中，如果 state 中没有需要的数据，就什么都不渲染或者渲染一个“正在装载”之类提示；如果 state 中已经有需要的数据，就可以正常渲染了，但这也必定是在 componentDidMount 修改了 state 之后，也就是只有在第二次渲染过程中才可以。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Foo extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">     data: null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">     if (!this.state.data) &#123;</span><br><span class="line">        return null;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">        return &lt;div&gt;this.state.data&lt;/div&gt;;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">     callAPI().then(result =&gt; &#123;</span><br><span class="line">       this.setState(&#123;data: result&#125;);</span><br><span class="line">     &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式虽然可行，我们也照这种套路写过不少代码，但它的缺点也是很明显的。</p>
<p>组件必须要有自己的 state 和 componentDidMount 函数实现，也就不可能做成纯函数形式的组件。<br>需要两次渲染过程，第一次是 mount 引发的渲染，由 componentDidMount 触发 AJAX 然后修改 state，然后第二次渲染才真的渲染出内容。<br>代码啰嗦，十分啰嗦。</p>
<p><strong>理想中的代码形式</strong></p>
<p>而 Suspense 就是为了克服上述 React 的缺点。</p>
<p>在了解 Suspense 怎么解决这些问题之前，我们不妨自己想象一下，如果要利用 AJAX 获取数据，代码怎样写最简洁高效？</p>
<p>我先来说一说自己设想的最佳代码形式。首先，我不想写一个有状态的组件，因为通过 AJAX 获取的数据往往也就在渲染用一次，没必要存在 state 里；其次，想要使数据拿来就用，不需要经过 componentDidMount 走一圈。所以，代码最好是下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const Foo = () =&gt; &#123;</span><br><span class="line">  const data = callAPI();</span><br><span class="line">  return &lt;div&gt;&#123;data&#125;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>够简洁吧，可是目前的 React 版本做不到啊！</p>
<p>因为 callAPI 肯定是一个异步操作，不可能获得同步数据，无法在同步的 React 渲染过程中立足。</p>
<p>不过，现在做不到，不代表将来做不到，将来 React 会支持这样的代码形式，这也就是 Suspense。</p>
<p><strong>Suspense</strong></p>
<p>在 JsConf Iceland 2018 技术大会 上，React 的开发者展示了未来 React 会支持的新特性 Suspense，有了 Suspense，就可以在 React 中以同步的形式来写异步代码，代码形式类似下面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const Foo = () =&gt; &#123;</span><br><span class="line">  const data = createFetcher(callAJAX).read();</span><br><span class="line">  return &lt;div&gt;&#123;data&#125;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 React 推出 v16 的时候，就增加了一个新生命周期函数 componentDidCatch。如果某个组件定义了 componentDidCatch，那么这个组件中所有的子组件在渲染过程中抛出异常时，这个 componentDidCatch 函数就会被调用。</p>
<p>可以这么设想，componentDidCatch 就是 JavaScript 语法中的 catch，而对应的 try 覆盖所有的子组件，就像下面这样:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  //渲染子组件</span><br><span class="line">&#125; catch (error) &#123;</span><br><span class="line">  // componentDidCatch被调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Suspense 就是巧妙利用 componentDidCatch 来实现同步形式的异步处理。</p>
<p>Suspense 提供的 createFetcher 函数会封装异步操作，当尝试从 createFetcher 返回的结果读取数据时，有两种可能：一种是数据已经就绪，那就直接返回结果；还有一种可能是异步操作还没有结束，数据没有就绪，这时候 createFetcher 会抛出一个“异常”。</p>
<p>你可能会说，抛出异常，渲染过程不就中断了吗？</p>
<p>的确会中断，不过，createFetcher 抛出的这个“异常”比较特殊，这个“异常”实际上是一个 Promise 对象，这个 Promise 对象代表的就是异步操作，操作结束时，也是数据准备好的时候。当 componentDidCatch 捕获这个 Promise 类型的“异常”时，就可以根据这个 Promise 对象的状态改变来重新渲染对应组件，第二次渲染，肯定就能够成功。</p>
<p>下面是 createFetcher 的一个简单实现方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var NO_RESULT = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">export const createFetcher = (task) =&gt; &#123;</span><br><span class="line">  let result = NO_RESULT;</span><br><span class="line"></span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    const p = task();</span><br><span class="line"></span><br><span class="line">    p.then(res =&gt; &#123;</span><br><span class="line">      result = res;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (result === NO_RESULT) &#123;</span><br><span class="line">      throw p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，createFetcher 的参数 task 被调用应该返回一个 Promise 对象，这个对象在第一次调用时会被 throw 出去，但是，只要这个对象完结，那么 result 就有实际的值，不会再被 throw。</p>
<p>还需要一个和 createFetcher 配合的 Suspense，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Suspense extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    pending: false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidCatch(error) &#123;</span><br><span class="line">    // easy way to detect Promise type</span><br><span class="line">    if (typeof error.then === &#x27;function&#x27;) &#123;</span><br><span class="line">      this.setState(&#123;pending: true&#125;);</span><br><span class="line"></span><br><span class="line">      error.then(() =&gt; this.setState(&#123;</span><br><span class="line">        pending: false</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return this.state.pending ? null : this.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 Suspense 组件实现了 componentDidCatch，如果捕获的 error 是 Promise 类型，那就说明子组件用 createFetcher 获取异步数据了，就会等到它完结之后重设 state，引发一次新的渲染过程，因为 createFetcher 中会记录异步返回的结果，新的渲染就不会抛出异常了。</p>
<p>使用 createFetcher 和 Suspense 的示例代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const getName = () =&gt; new Promise((resolve) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&#x27;Morgan&#x27;);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const fetcher = createFetcher(getName);</span><br><span class="line"></span><br><span class="line">const Greeting = () =&gt; &#123;</span><br><span class="line">  return &lt;div&gt;Hello &#123;fetcher()&#125;&lt;/div&gt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const SuspenseDemo = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Suspense&gt;</span><br><span class="line">      &lt;Greeting /&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的 getName 利用 setTimeout 模拟了异步 AJAX 获取数据，第一次渲染 Greeting 组件时，会有 Promise 类型的异常抛出，被 Suspense 捕获。1 秒钟之后，当 getName 返回实际结果的时候，Suspense 会引发重新渲染，这一次 Greeting 会显示出 hello Morgan。</p>
<p>上面的 createFetcher 和 Suspense 是一个非常简陋的实现，主要用来让读者了解 Suspense 的工作原理，正式发布的 Suspense 肯定会具备更强大的功能。</p>
<p><strong>React v16.6.0 对 Suspense 的支持</strong></p>
<p>React 发布 v16.6.0 的时候，提供了 Suspense 组件，直接支持 Suspense 功能，但是还没有正式提供 createFetcher 的功能，只发布了一个独立但不稳定的 react-cache 包。这个包里的 unstable_createResource 相当于上面描述的 createFetcher。照这个命名来看，正式发布的时候这个 API 可能会叫做 createResource 而不是叫 createFetcher。</p>
<p>我们利用 React v16.6.0 和不稳定的 react-cache 来实现上述功能，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;Suspense&#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">import &#123;unstable_createResource as createResource&#125; from &#x27;react-cache&#x27;;</span><br><span class="line"></span><br><span class="line">const getName = () =&gt; new Promise((resolve) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&#x27;Morgan&#x27;);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const resource = createResource(getName);</span><br><span class="line"></span><br><span class="line">const Greeting = () =&gt; &#123;</span><br><span class="line">  return &lt;div&gt;hello &#123;resource.read()&#125;&lt;/div&gt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const SuspenseDemo = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;div&gt;loading...&lt;/div&gt;&#125; &gt;</span><br><span class="line">      &lt;Greeting /&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们使用 React 提供的 Suspense 组件，支持一个 fallback 属性，这个属性可以用于显示“装载中”界面。在上面的例子中，要等待 1 秒钟时间才得到模拟 API 的结果，这时候显示一个空白页面是肯定不合适的，在等待的这 1 秒钟里，显得就是一个“Loading…”字样。</p>
<p>很显然，需要一个最佳实践来控制 Suspense 的范围。如果我们只在组件树最顶层放一个 Suspense 组件，那么在 API 返回之前，整个页面只显示“装载中”，这样的用户体验并不好。正确的做法，是将每一个独立依赖某个 API 调用的组件用一个 Suspense 包住。</p>
<p>例如，一个页面中包括头部的 Header、左侧的导航栏 LeftPanel 和右侧的内容 Content，其中只有 Header 的渲染不依赖于 API，那么，JSX 可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;Header /&gt;</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;LoadingSpin /&gt;&#125;&gt;</span><br><span class="line">        &lt;LeftPanel /&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;LoadingSpin /&gt;&#125;&gt;</span><br><span class="line">        &lt;Content /&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>这样，网页首先显示 Header，然后无论 LeftPanel 还是 Content 中谁的 AJAX 首先返回结果，都可以立刻显示对应模块，而不用等待所有 AJAX 都返回才让用户看到更新。</p>
<p><strong>Suspense 带来的 React 使用模式改变</strong></p>
<p>Suspense 被推出之后，可以极大地减少异步操作代码的复杂度。</p>
<p>之前，只要有 AJAX 这样的异步操作，就必须要用两次渲染来显示 AJAX 结果，这就需要用组件的 state 来存储 AJAX 的结果，用 state 又意味着要把组件实现为一个 class。总之，我们需要做这些：</p>
<ul>
<li>实现一个 class；</li>
<li>class 中需要有 state；</li>
<li>需要实现 componentDidMount 函数；</li>
<li>render 必须要根据 this.state 来渲染不同内容。</li>
<li>有了 Suspense 之后，不需要做上面这些杂事，只要一个函数形式组件就足够了。</li>
</ul>
<p>在介绍 Redux 时，我们提到过在 Suspense 面前，Redux 的一切异步操作方案都显得繁琐，读者现在应该能够通过代码理解这一点了。</p>
<p>很可惜，目前 Suspense 还不支持服务器端渲染，当 Suspense 支持服务器端渲染的时候，那就真的会对 React 社区带来革命性影响。</p>
<p><strong>总结</strong></p>
<ul>
<li>Suspense 解决异步操作的问题；</li>
<li>有了 Supsense 之后，依赖 AJAX 的组件也可以是函数形式，不需要是 class。</li>
</ul>
<h2 id="十、函数化的-Hooks"><a href="#十、函数化的-Hooks" class="headerlink" title="十、函数化的 Hooks"></a>十、函数化的 Hooks</h2><p>React v16.7.0-alpha 中第一次引入了 Hooks 的概念，因为这是一个 alpha 版本，不算正式发布，所以，将来正式发布时 API 可能会有变化。</p>
<blockquote>
<p>Hooks 的目的，简而言之就是让开发者不需要再用 class 来实现组件</p>
</blockquote>
<p>还记得之前我们介绍的经典 Counter 组件吗？不考虑用 Redux 或者 Mobx 来管理状态的话，Counter 组件就需要把计数数据放在 state 里，要用 state，就意味着需要定义一个 class。</p>
<p>很多时候，一个简单组件也需要实现一个 class，的确是一件很烦的事，有了 Hooks 之后，事情就简单多了，我们用几个已经公开的 Hooks API 来看看如何避免写 class。</p>
<p><strong>useState</strong></p>
<blockquote>
<p>Hooks 会提供一个叫 useState 的方法，它开启了一扇新的定义 state 的门，对应 Counter 的代码可以这么写：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">const Counter = () =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">       &lt;div&gt;&#123;count&#125;&lt;/div&gt;</span><br><span class="line">       &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">       &lt;button onClick=&#123;() =&gt; setCount(count - 1)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意看，Counter 拥有自己的“状态”，但它只是一个函数，不是 class。</p>
<p>useState 只接受一个参数，也就是 state 的初始值，它返回一个只有两个元素的数组，第一个元素就是 state 的值，第二个元素是更新 state 的函数。</p>
<p>我们利用解构赋值（destructuring assignment）把两个元素分别赋值给 count 和 setCount，相当于这样的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 下面代码等同于： const [count, setCount] = useState(0);</span><br><span class="line">const result = useState(0);</span><br><span class="line">const count = result[0];</span><br><span class="line">const setCount = result[1];</span><br></pre></td></tr></table></figure>

<p>利用 count 可以读取到这个 state，利用 setCount 可以更新这个 state，而且我们完全可以控制这两个变量的命名，只要高兴，你完全可以这么写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [theCount, updateCount] = useState(0);</span><br></pre></td></tr></table></figure>

<p>因为 useState 在 Counter 这个函数体中，每次 Counter 被渲染的时候，这个 useState 调用都会被执行，useState 自己肯定不是一个纯函数，因为它要区分第一次调用（组件被 mount 时）和后续调用（重复渲染时），只有第一次才用得上参数的初始值，而后续的调用就返回“记住”的 state 值。</p>
<p>读者看到这里，心里可能会有这样的疑问：如果组件中多次使用 useState 怎么办？React 如何“记住”哪个状态对应哪个变量？</p>
<p>React 是完全根据 useState 的调用顺序来“记住”状态归属的，假设组件代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const Counter = () =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  const [foo, updateFoo] = useState(&#x27;foo&#x27;);</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一次 Counter 被渲染，都是第一次 useState 调用获得 count 和 setCount，第二次 useState 调用获得 foo 和 updateFoo（这里我故意让命名不用 set 前缀，可见函数名可以随意）。React 是渲染过程中的“上帝”，每一次渲染 Counter 都要由 React 发起，所以它有机会准备好一个内存记录，当开始执行的时候，每一次 useState 调用对应内存记录上一个位置，而且是按照顺序来记录的。React 不知道你把 useState 等 Hooks API 返回的结果赋值给什么变量，但是它也不需要知道，它只需要按照 useState 调用顺序记录就好了。</p>
<p>正因为这个原因，Hooks，千万不要在 if 语句或者 for 循环语句中使用！</p>
<p>像下面的代码，肯定会出乱子的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Counter = () =&gt; &#123;</span><br><span class="line">    const [count, setCount] = useState(0);</span><br><span class="line">    if (count % 2 === 0) &#123;</span><br><span class="line">        const [foo, updateFoo] = useState(&#x27;foo&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    const [bar, updateBar] = useState(&#x27;bar&#x27;);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为条件判断，让每次渲染中 useState 的调用次序不一致了，于是 React 就错乱了。</p>
<p><strong>useEffect</strong></p>
<p>除了 useState，React 还提供 useEffect，用于支持组件中增加副作用的支持。</p>
<p>在 React 组件生命周期中如果要做有副作用的操作，代码放在哪里？</p>
<p>当然是放在 componentDidMount 或者 componentDidUpdate 里，但是这意味着组件必须是一个 class。</p>
<p>在 Counter 组件，如果我们想要在用户点击“+”或者“-”按钮之后把计数值体现在网页标题上，这就是一个修改 DOM 的副作用操作，所以必须把 Counter 写成 class，而且添加下面的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  document.title = `Count: $&#123;this.state.count&#125;`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentDidUpdate() &#123;</span><br><span class="line">  document.title = `Count: $&#123;this.state.count&#125;`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>而有了 useEffect，我们就不用写一个 class 了，对应代码如下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState, useEffect &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">const Counter = () =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  </span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    document.title = `Count: $&#123;count&#125;`;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">       &lt;div&gt;&#123;count&#125;&lt;/div&gt;</span><br><span class="line">       &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">       &lt;button onClick=&#123;() =&gt; setCount(count - 1)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>useEffect 的参数是一个函数，组件每次渲染之后，都会调用这个函数参数，这样就达到了 componentDidMount 和 componentDidUpdate 一样的效果。</p>
<p>虽然本质上，依然是 componentDidMount 和 componentDidUpdate 两个生命周期被调用，但是现在我们关心的不是 mount 或者 update 过程，而是“after render”事件，useEffect 就是告诉组件在“渲染完”之后做点什么事。</p>
<p>读者可能会问，现在把 componentDidMount 和 componentDidUpdate 混在了一起，那假如某个场景下我只在 mount 时做事但 update 不做事，用 useEffect 不就不行了吗？</p>
<p>其实，用一点小技巧就可以解决。useEffect 还支持第二个可选参数，只有同一 useEffect 的两次调用第二个参数不同时，第一个函数参数才会被调用，所以，如果想模拟 componentDidMount，只需要这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  // 这里只有mount时才被调用，相当于componentDidMount</span><br><span class="line">&#125;, [123]);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上面的代码中，useEffect 的第二个参数是 [123]，其实也可以是任何一个常数，因为它永远不变，所以 useEffect 只在 mount 时调用第一个函数参数一次，达到了 componentDidMount 一样的效果。</p>
</blockquote>
<p><strong>useContext</strong></p>
<p>在前面介绍“提供者模式”章节我们介绍过 React 新的 Context API，这个 API 不是完美的，在多个 Context 嵌套的时候尤其麻烦。</p>
<p>比如，一段 JSX 如果既依赖于 ThemeContext 又依赖于 LanguageContext，那么按照 React Context API 应该这么写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ThemeContext.Consumer&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        theme =&gt; (</span><br><span class="line">            &lt;LanguageContext.Cosumer&gt;</span><br><span class="line">                language =&gt; &#123;</span><br><span class="line">                    //可以使用theme和lanugage了</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;/LanguageContext.Cosumer&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/ThemeContext.Consumer&gt;</span><br></pre></td></tr></table></figure>

<p>因为 Context API 要用 render props，所以用两个 Context 就要用两次 render props，也就用了两个函数嵌套，这样的缩格看起来也的确过分了一点点。</p>
<p>使用 Hooks 的 useContext，上面的代码可以缩略为下面这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const theme = useContext(ThemeContext);</span><br><span class="line">const language = useContext(LanguageContext);</span><br><span class="line">// 这里就可以用theme和language了</span><br></pre></td></tr></table></figure>

<p>这个useContext把一个需要很费劲才能理解的 Context API 使用大大简化，不需要理解render props，直接一个函数调用就搞定。</p>
<p>但是，useContext也并不是完美的，它会造成意想不到的重新渲染，我们看一个完整的使用useContext的组件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const ThemedPage = () =&gt; &#123;</span><br><span class="line">    const theme = useContext(ThemeContext);</span><br><span class="line">    </span><br><span class="line">    return (</span><br><span class="line">       &lt;div&gt;</span><br><span class="line">            &lt;Header color=&#123;theme.color&#125; /&gt;</span><br><span class="line">            &lt;Content color=&#123;theme.color&#125;/&gt;</span><br><span class="line">            &lt;Footer color=&#123;theme.color&#125;/&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为这个组件ThemedPage使用了useContext，它很自然成为了Context的一个消费者，所以，只要Context的值发生了变化，ThemedPage就会被重新渲染，这很自然，因为不重新渲染也就没办法重新获得theme值，但现在有一个大问题，对于ThemedPage来说，实际上只依赖于theme中的color属性，如果只是theme中的size发生了变化但是color属性没有变化，ThemedPage依然会被重新渲染，当然，我们通过给Header、Content和Footer这些组件添加shouldComponentUpdate实现可以减少没有必要的重新渲染，但是上一层的ThemedPage中的JSX重新渲染是躲不过去了。</p>
<p>说到底，useContext需要一种表达方式告诉React：“我没有改变，重用上次内容好了。”</p>
<p>希望Hooks正式发布的时候能够弥补这一缺陷。</p>
<p><strong>Hooks 带来的代码模式改变</strong></p>
<p>上面我们介绍了 useState、useEffect 和 useContext 三个最基本的 Hooks，可以感受到，Hooks 将大大简化使用 React 的代码。</p>
<p>首先我们可能不再需要 class了，虽然 React 官方表示 class 类型的组件将继续支持，但是，业界已经普遍表示会迁移到 Hooks 写法上，也就是放弃 class，只用函数形式来编写组件。</p>
<p>对于 useContext，它并没有为消除 class 做贡献，却为消除 render props 模式做了贡献。很长一段时间，高阶组件和 render props 是组件之间共享逻辑的两个武器，但如同我前面章节介绍的那样，这两个武器都不是十全十美的，现在 Hooks 的出现，也预示着高阶组件和 render props 可能要被逐步取代。</p>
<p>但读者朋友，不要觉得之前学习高阶组件和 render props 是浪费时间，相反，你只有明白 React 的使用历史，才能更好地理解 Hooks 的意义。</p>
<p>可以预测，在 Hooks 兴起之后，共享代码之间逻辑会用函数形式，而且这些函数会以 use- 前缀为约定，重用这些逻辑的方式，就是在函数形式组件中调用这些 useXXX 函数。</p>
<p>例如，我们可以写这样一个共享 Hook useMountLog，用于在 mount 时记录一个日志，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const useMountLog = (name) =&gt; &#123;</span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">        console.log(`$&#123;name&#125; mounted`);    </span><br><span class="line">    &#125;, [123]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任何一个函数形式组件都可以直接调用这个 useMountLog 获得这个功能，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const Counter = () =&gt; &#123;</span><br><span class="line">    useMountLog(&#x27;Counter&#x27;);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对了，所有的 Hooks API 都只能在函数类型组件中调用，class 类型的组件不能用，从这点看，很显然，class 类型组件将会走向消亡。</p>
<p><strong>总结</strong></p>
<ul>
<li>Hooks 的意义就是可以淘汰 class 类型的组件；</li>
<li>Hooks 将改变重用组件逻辑的模式；</li>
<li>在未来，Hooks 将是 React 使用的主流</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-React/React-理解+特性" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/05/React/React-%E7%90%86%E8%A7%A3+%E7%89%B9%E6%80%A7/" class="article-date">
  	<time datetime="2020-04-05T09:34:48.000Z" itemprop="datePublished">2020-04-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/05/React/React-%E7%90%86%E8%A7%A3+%E7%89%B9%E6%80%A7/">
        React-理解+特性
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>React，用于构建用户界面的 JavaScript 库，只提供了 UI 层面的解决方案</p>
<p>遵循组件设计模式、声明式编程范式和函数式编程概念，以使前端应用程序更高效</p>
<p>使用虚拟 <code>DOM</code> 来有效地操作 <code>DOM</code>，遵循从高阶组件到低阶组件的单向数据流</p>
<p>帮助我们将界面成了各个独立的小块，每一个块就是组件，这些组件之间可以组合、嵌套，构成整体页面</p>
<p><code>react</code> 类组件使用一个名为 <code>render()</code> 的方法或者函数组件<code>return</code>，接收输入的数据并返回需要展示的内容</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HelloMessage</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">HelloMessage</span> <span class="attr">name</span>=<span class="string">&quot;Taylor&quot;</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;hello-example&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上述这种类似 <code>XML</code> 形式就是 <code>JSX</code>，最终会被 <code>babel</code> 编译为合法的 <code>JS</code> 语句调用</p>
<p>被传入的数据可在组件中通过 <code>this.props</code> 在 <code>render()</code> 访问</p>
<h2 id="二、特性"><a href="#二、特性" class="headerlink" title="二、特性"></a>二、特性</h2><p><code>React</code> 特性有很多，如：</p>
<ul>
<li>JSX 语法</li>
<li>单向数据绑定</li>
<li>虚拟 DOM</li>
<li>声明式编程</li>
<li>Component</li>
</ul>
<p>着重介绍下声明式编程及 Component</p>
<h3 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h3><p>声明式编程是一种编程范式，它关注的是你要做什么，而不是如何做</p>
<p>它表达逻辑而不显式地定义步骤。这意味着我们需要根据逻辑的计算来声明要显示的组件</p>
<p>如实现一个标记的地图：</p>
<p>通过命令式创建地图、创建标记、以及在地图上添加的标记的步骤如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建地图</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>.<span class="title function_">map</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;map&quot;</span>), &#123;</span><br><span class="line">  <span class="attr">zoom</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">center</span>: &#123; lat, lng &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建标记</span></span><br><span class="line"><span class="keyword">const</span> marker = <span class="keyword">new</span> <span class="title class_">Map</span>.<span class="title function_">marker</span>(&#123;</span><br><span class="line">  <span class="attr">position</span>: &#123; lat, lng &#125;,</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;Hello Marker&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 地图上添加标记</span></span><br><span class="line">marker.<span class="title function_">setMap</span>(map);</span><br></pre></td></tr></table></figure>

<p>而用 <code>React</code> 实现上述功能则如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Map</span> zoom=&#123;<span class="number">4</span>&#125; center=&#123;(lat, lng)&#125;&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Marker</span> <span class="attr">position</span>=<span class="string">&#123;(lat,</span> <span class="attr">lng</span>)&#125; <span class="attr">title</span>=<span class="string">&#123;</span>&quot;<span class="attr">Hello</span> <span class="attr">Marker</span>&quot;&#125; /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Map</span>&gt;</span><br></pre></td></tr></table></figure>

<p>声明式编程方式使得 <code>React</code> 组件很容易使用，最终的代码简单易于维护</p>
<h3 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h3><p>在 <code>React</code> 中，一切皆为组件。通常将应用程序的整个逻辑分解为小的单个部分。 我们将每个单独的部分称为组件</p>
<p>组件可以是一个函数或者是一个类，接受数据输入，处理它并返回在 <code>UI</code> 中呈现的 <code>React</code> 元素</p>
<p>函数式组件如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Header</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Jumbotron</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">backgroundColor:</span> &quot;<span class="attr">orange</span>&quot; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>TODO App<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Jumbotron</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类组件（有状态组件）如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dashboard</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;dashboard&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ToDoForm</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ToDolist</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个组件该有的特点如下：</p>
<ul>
<li>可组合：每个组件易于和其它组件一起使用，或者嵌套在另一个组件内部</li>
<li>可重用：每个组件都是具有独立功能的，它可以被使用在多个 UI 场景</li>
<li>可维护：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护</li>
</ul>
<h2 id="三、优势"><a href="#三、优势" class="headerlink" title="三、优势"></a>三、优势</h2><p>通过上面的初步了解，可以感受到 <code>React</code> 存在的优势：</p>
<ul>
<li>高效灵活</li>
<li>声明式的设计，简单使用</li>
<li>组件式开发，提高代码复用率</li>
<li>单向响应的数据流会比双向绑定的更安全，速度更快</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/5/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/7/">Next &amp;raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2022 mr.杜
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>