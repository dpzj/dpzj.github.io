<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="杜鹏之家">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/23/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="杜鹏之家">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="mr.杜">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 6.2.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="https://img1.baidu.com/it/u=412709218,617594518&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=504&amp;h=500" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">mr.杜</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">Home</a></li>
				        
							<li><a href="/archives">Archives</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
						<!-- music -->
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Event-Loop/" style="font-size: 10px;">Event Loop</a> <a href="/tags/Graphviz/" style="font-size: 10px;">Graphviz</a> <a href="/tags/Mock/" style="font-size: 10px;">Mock</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/React/" style="font-size: 19.29px;">React</a> <a href="/tags/Redux/" style="font-size: 11.43px;">Redux</a> <a href="/tags/async-await/" style="font-size: 10px;">async/await</a> <a href="/tags/css/" style="font-size: 13.57px;">css</a> <a href="/tags/echart/" style="font-size: 10px;">echart</a> <a href="/tags/es6/" style="font-size: 16.43px;">es6</a> <a href="/tags/eslint/" style="font-size: 10px;">eslint</a> <a href="/tags/git/" style="font-size: 15.71px;">git</a> <a href="/tags/glup/" style="font-size: 10.71px;">glup</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/html/" style="font-size: 14.29px;">html</a> <a href="/tags/http/" style="font-size: 17.14px;">http</a> <a href="/tags/javascript/" style="font-size: 18.57px;">javascript</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/nginx/" style="font-size: 10.71px;">nginx</a> <a href="/tags/nodejs/" style="font-size: 12.86px;">nodejs</a> <a href="/tags/python/" style="font-size: 10.71px;">python</a> <a href="/tags/qiankun/" style="font-size: 10px;">qiankun</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/serveless/" style="font-size: 10px;">serveless</a> <a href="/tags/typescript/" style="font-size: 12.14px;">typescript</a> <a href="/tags/vs-code/" style="font-size: 11.43px;">vs code</a> <a href="/tags/vue/" style="font-size: 20px;">vue</a> <a href="/tags/vue3/" style="font-size: 10px;">vue3</a> <a href="/tags/webpack/" style="font-size: 17.86px;">webpack</a> <a href="/tags/xml/" style="font-size: 10px;">xml</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 13.57px;">优化</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10.71px;">前端</a> <a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 15px;">小程序</a> <a href="/tags/%E6%8A%93%E5%8C%85/" style="font-size: 10px;">抓包</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正则表达式</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 12.86px;">浏览器</a> <a href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/" style="font-size: 10.71px;">移动端</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.57px;">设计模式</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/">github</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">I&#39;m a developer.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://img1.baidu.com/it/u=412709218,617594518&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=504&amp;h=500" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">Home</a></li>
		        
					<li><a href="/archives">Archives</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-html+css+js+ts/3-js内存泄漏和垃圾回收机制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/09/html+css+js+ts/3-js%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" class="article-date">
  	<time datetime="2018-02-09T02:16:24.000Z" itemprop="datePublished">2018-02-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/09/html+css+js+ts/3-js%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/">
        3-js内存泄漏和垃圾回收机制
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h2><ul>
<li>程序的运行需要内存，只要程序提出要求，操作系统或者运行是就必须供给内存</li>
<li>对于持续运行的服务进程，必须及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃</li>
<li>不再用到的内存，没有及时释放，就叫做内存泄漏。</li>
<li>有些语言（比如c语言）必须手动释放内存，程序员负责内存管理</li>
<li>这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”。</li>
</ul>
<blockquote>
<p>javascript垃圾回收机制原理：解决内存的泄露，垃圾回收机制会定期（周期性）找出那些不再用到的内存（变量），然后释放其内存。</p>
</blockquote>
<h2 id="垃圾回收的必要性"><a href="#垃圾回收的必要性" class="headerlink" title="垃圾回收的必要性"></a>垃圾回收的必要性</h2><blockquote>
<p>由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃</p>
</blockquote>
<p>这段话解释了为什么需要系统需要垃圾回收，JS不像C&#x2F;C++，他有自己的一套垃圾回收机制（Garbage Collection）。JavaScript的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = &quot;before&quot;;</span><br><span class="line">var b = &quot;override a&quot;;</span><br><span class="line">var a = b; //重写a</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这段代码运行之后，“before”这个字符串失去了引用（之前是被a引用），系统检测到这个事实之后，就会释放该字符串的存储空间以便这些空间可以被再利用。</p>
</blockquote>
<h2 id="垃圾回收原理"><a href="#垃圾回收原理" class="headerlink" title="垃圾回收原理"></a>垃圾回收原理</h2><blockquote>
<p>现在各大浏览器通常用采用的垃圾回收有两种方法：<strong>标记清除</strong>、<strong>引用计数</strong></p>
</blockquote>
<h3 id="策略1：标记清除"><a href="#策略1：标记清除" class="headerlink" title="策略1：标记清除"></a>策略1：标记清除</h3><blockquote>
<p>这是javascript中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。</p>
</blockquote>
<p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间</p>
<ul>
<li>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记</li>
<li>去掉环境中的变量以及被环境中的变量引用的变量的标记</li>
<li>此后再被加上标记的变量将被视为准备删除的变量，因为环境中的变量已经无法访问到这些变量了</li>
</ul>
<h3 id="策略2：引用计数"><a href="#策略2：引用计数" class="headerlink" title="策略2：引用计数"></a>策略2：引用计数</h3><blockquote>
<p>语言引擎有一张”引用表”，保存了内存里面所有资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。</p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017041703.png" alt="img"></p>
<p>上图中，左下角的两个值，没有任何引用，所以可以释放</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1,2,3,4];</span><br><span class="line">console.log(&quot;hello world&quot;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的代码中，数组<code>[1,2,3,4]</code>是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它是会持续占用内存</p>
</blockquote>
<p>如果增加一行代码，解除arr对<code>[1,2,3,4]</code>引用，这块内存就可以被垃圾回收机制释放了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3,4];</span><br><span class="line">console.log(&quot;hello world&quot;);</span><br><span class="line">arr = null;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码中，arr重置为null，就解除了对<code>[1，2，3，4]</code>的引用，引用次数变成了0，内存就可以释放出来了。</p>
</blockquote>
<blockquote>
<p>因此，并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用</p>
</blockquote>
<p>再来下面来看看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function problem() &#123;</span><br><span class="line">    var objA = new Object();</span><br><span class="line">    var objB = new Object();</span><br><span class="line"></span><br><span class="line">    objA.someOtherObject = objB;</span><br><span class="line">    objB.anotherObject = objA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这个例子中，objA和objB通过各自的属性相互引用；也就是说这两个对象的引用次数都是2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA和objB还将会继续存在，因为他们的引用次数永远不会是0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露</p>
</blockquote>
<p>不过上面的问题也不是不能解决，我们可以手动切断他们的循环引用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myObj.element = null;</span><br><span class="line">element.someObject =null;</span><br></pre></td></tr></table></figure>

<p>这样写代码的话就可以解决循环引用的问题了，也就防止了内存泄露的问题。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><blockquote>
<p>如果存在循环引用的情况，那么这个引用值占的空间就永远不会被回收。</p>
</blockquote>
<h2 id="面试回答"><a href="#面试回答" class="headerlink" title="面试回答"></a>面试回答</h2><h3 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h3><blockquote>
<p>一般来说没有被引用的对象就是垃圾，就是要被清除，有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。</p>
</blockquote>
<h3 id="如何检垃圾"><a href="#如何检垃圾" class="headerlink" title="如何检垃圾"></a>如何检垃圾</h3><ul>
<li>一种算法是标记 标记-清除 算法</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-html+css+js+ts/1-移动端适配" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/07/html+css+js+ts/1-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/" class="article-date">
  	<time datetime="2018-02-07T14:33:28.000Z" itemprop="datePublished">2018-02-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/07/html+css+js+ts/1-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/">
        移动端像素比调试
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>物理像素:移动端设备的分辨率</li>
<li>独立像素:css的像素 320 375</li>
<li>像素比 &#x3D; 物理像素&#x2F;独立像素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>width=device-width</code> 设备宽度 <code>640px</code>(低版本的安卓手机不支持数字) 这个属性在不支持<code>IE</code></li>
<li><code>initial-scale=1.0</code>(初始缩放比),能够起到和<code>width=device-width</code>相同的效果(把理想的视窗设置为设备的宽度) 两个配合使用就能够很好的解决移动端各设备的适配问题</li>
<li><code>maximum-scale=1.0</code>最大缩放比例</li>
<li><code>user-scalable=0</code>禁止缩放</li>
<li><code>minimum-scale=1.0</code> 最小缩放比例</li>
</ul>
<h3 id="移动端布局方法"><a href="#移动端布局方法" class="headerlink" title="移动端布局方法"></a>移动端布局方法</h3><hr>
<ul>
<li>1、流式布局 与设备等宽 做自适应 100%或者具体的像素值</li>
<li>2、<code>rem</code>做盒子的宽度，viewport缩放</li>
<li>3、固定宽度 <code>viewport</code>缩放<code>content=&quot;width=640, initial-scale=0.5, maximum-scale=0.5, user-scalable=0&quot;</code>（用的比较少）</li>
<li>4、<code>vw/vh</code> 相对于viewport理想视窗(设备)的比例(兼容性不好)<br><code>1vw = 10%</code>设备宽 <code>10vw</code></li>
</ul>
<h3 id="meta标签属性设置"><a href="#meta标签属性设置" class="headerlink" title="meta标签属性设置"></a>meta标签属性设置</h3><hr>
<meta http-equiv="X-UA-Compatible" content="IE=edge chrome=1">

<ul>
<li>IE8<code>浏览器的显示方式:</code>IE&#x3D;edge<code>以</code>IE&#96;最高版本显示</li>
<li>chrome&#x3D;1 以谷歌浏览器模式渲染(GCF(Google Chrome Frame))</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>referrer 告诉浏览器链接来源于哪里(计算网页上链接的访问量)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no,adress=no&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>格式检测:（数字、邮箱、地址） no不识别为电话号码、邮箱、地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除默认的苹果工具栏、菜单栏(全屏显示)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;apple-touch-fullscreen&quot; =&quot;yes&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>全屏显示</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置app应用下状态条的颜色</li>
<li>默认值default (白色) black（黑色）</li>
<li><code>black-translucent</code>（灰色半透明）若果设置为这个值会占据页面的<code>px</code>位置浮在页面上方<code>20px</code>高度 <code>iphone4</code>是<code>40px</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>360</code>模式固定为极速模式</li>
</ul>
<h3 id="常见的meta属性"><a href="#常见的meta属性" class="headerlink" title="常见的meta属性"></a>常见的meta属性</h3><hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0，minimum-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="link-扩展"><a href="#link-扩展" class="headerlink" title="link 扩展"></a>link 扩展</h3><hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;xxx.com&quot;&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>预解析技术，当浏览网页时，浏览器会在加载页面的时对页面中的域名进行解析缓存，当我们点击这些网页的链接时就不需要再进行DNS的解析，减少用户的等待时间，提高用户的体验度</p>
</blockquote>
<ul>
<li><code>rem</code> 根目录 <code>html</code> 的<code>font-size</code>尺寸默认为<code>16px</code> <code>1rem = 16px;</code></li>
<li><code>1rem = html</code>的<code>font-size</code>的尺寸大小</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/html/" rel="tag">html</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/" rel="tag">移动端</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AF/">移动端</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-html+css+js+ts/1-移动端布局适配" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/05/html+css+js+ts/1-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80%E9%80%82%E9%85%8D/" class="article-date">
  	<time datetime="2018-02-05T07:11:47.000Z" itemprop="datePublished">2018-02-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/05/html+css+js+ts/1-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80%E9%80%82%E9%85%8D/">
        移动端适配
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、为什么要做适配"><a href="#一、为什么要做适配" class="headerlink" title="一、为什么要做适配"></a>一、为什么要做适配</h2><ul>
<li>为了适应各种移动端设备，完美呈现应有的布局效果</li>
<li>各个移动端设备，分辨率大小不一致，网页想铺满整个屏幕，并在各种分辨下等比缩放</li>
</ul>
<h2 id="二、适配方案"><a href="#二、适配方案" class="headerlink" title="二、适配方案"></a>二、适配方案</h2><ul>
<li>固定高度，宽度百分比适配-布局非常均匀，适合百分比布局</li>
<li>固定宽度，改变缩放比例适配-什么情况都可以</li>
<li><code>Rem</code>适配</li>
<li>像素比适配</li>
</ul>
<h2 id="三、单位"><a href="#三、单位" class="headerlink" title="三、单位"></a>三、单位</h2><ul>
<li><code>em</code>根据元素自身的字体大小计算,元素自身 <code>16px</code> <code>1em=16px</code></li>
<li><code>Rem</code> <code>R -&gt; root</code> 根节点( <code>html</code> ) 根据<code>html</code>的字体大小计算其他元素尺寸</li>
</ul>
<h2 id="四、百分比适配-常用"><a href="#四、百分比适配-常用" class="headerlink" title="四、百分比适配(常用)"></a>四、百分比适配(常用)</h2><blockquote>
<p>固定高度，宽度百分比适配</p>
</blockquote>
<ul>
<li>根据设置的大小去设置高度，单位可以用<code>px</code> 百分比 <code>auto</code></li>
<li>常用<code>Flex</code>布局</li>
<li>百分比宽度</li>
</ul>
<blockquote>
<p>以<code>640</code>设计稿为例，在外层容器上设置最大以及最小的宽</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#wrapper &#123;</span><br><span class="line">    max-width: 640px; /*设置设计稿的宽度*/</span><br><span class="line">    min-width: 300px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>后面的区块布局都用百分比，具体元素大小用<code>px</code>计算</p>
</blockquote>
<ul>
<li>也就是宽度用百分比，高度用<code>px</code></li>
<li>高度以及图片不要定死，让它自动撑开</li>
</ul>
<h2 id="五、Rem适配-常用"><a href="#五、Rem适配-常用" class="headerlink" title="五、Rem适配(常用)"></a>五、Rem适配(常用)</h2><ul>
<li>根据屏幕的分辨率动态设置<code>html</code>的文字大小，达到等比缩放的功能</li>
<li>保证<code>html</code>最终算出来的字体大小，不能小于<code>12px</code></li>
<li>在不同的移动端显示不同的元素比例效果</li>
<li>如果<code>html</code>的<code>font-size:20px</code>的时候，那么此时的<code>1rem = 20px</code></li>
<li>把设计图的宽度分成多少分之一，根据实际情况</li>
<li><code>rem</code>做盒子的宽度，<code>viewport</code>缩放</li>
</ul>
<blockquote>
<p><code>head</code>加入常见的<code>meta</code>属性</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;</span><br><span class="line">&lt;!--这个是关键--&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0，minimum-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>把这段代码加入<code>head</code>中的<code>script</code>预先加载</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// rem适配用这段代码动态计算html的font-size大小</span><br><span class="line">(function(win) &#123;</span><br><span class="line">    var docEl = win.document.documentElement;</span><br><span class="line">    var timer = &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">    function changeRem() &#123;</span><br><span class="line">        var width = docEl.getBoundingClientRect().width;</span><br><span class="line">        if (width &gt; 750) &#123; // 750是设计稿大小</span><br><span class="line">            width = 750;</span><br><span class="line">        &#125;</span><br><span class="line">        var fontS = width / 10; // 把设备宽度十等分 1rem=10px</span><br><span class="line">        docEl.style.fontSize = fontS + &quot;px&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    win.addEventListener(&quot;resize&quot;, function() &#123;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(changeRem, 30);</span><br><span class="line">    &#125;, false);</span><br><span class="line">    win.addEventListener(&quot;pageshow&quot;, function(e) &#123;</span><br><span class="line">        if (e.persisted) &#123; //清除缓存</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer = setTimeout(changeRem, 30);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, false);</span><br><span class="line">    changeRem();</span><br><span class="line">&#125;)(window)</span><br></pre></td></tr></table></figure>

<ul>
<li>或者使用淘宝提供的库 <a target="_blank" rel="noopener" href="https://github.com/amfe/lib-flexible">https://github.com/amfe/lib-flexible</a></li>
</ul>
<p><strong>布局细节</strong></p>
<ul>
<li>结构用<code>section</code>区块划分更语义化</li>
<li>然后在<code>body</code>设置宽度</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    width: 10rem;</span><br><span class="line">    margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>后面的区块都以百分比布局</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wrapper&quot;&gt;</span><br><span class="line">   &lt;header&gt;&lt;header&gt;</span><br><span class="line">   &lt;section&gt;&lt;section&gt;</span><br><span class="line">   &lt;section&gt;&lt;section&gt;</span><br><span class="line">   &lt;section&gt;&lt;section&gt;</span><br><span class="line">   &lt;section&gt;&lt;section&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">section,</span><br><span class="line">header &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>把视觉稿中的 px 转换成 rem</strong></p>
<blockquote>
<p>首先，目前日常工作当中，视觉设计师给到前端开发人员手中的视觉稿尺寸一般是基于 <code>640px</code> 、 <code>750px</code> 以及 <code>1125px</code> 宽度为准。甚至为什么？大家应该懂的（考虑<code>Retina</code>屏）</p>
</blockquote>
<blockquote>
<p>假定设计稿的大小为<code>750</code>，那么我们则将整个图分成<code>10</code>等份来看。&#96;&#96; 对应的 <code>font-size</code>为<code>75px</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">html&#123;</span><br><span class="line">	font-size: 75px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这样一来，对于视觉稿上的元素尺寸换算，只需要原始的 <code>px</code>值 除以 <code>rem</code>基准值 即可</li>
</ul>
<blockquote>
<p>那么，我们现在就可以比对设计稿，比如设计稿中，有一个<code>div</code>元素，宽度，高度都为<code>20px</code>,那么我们这样写即可（可以用 <code>markman</code>标准设计稿的元素大小）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	height: 0.27rem; /*20/75*/</span><br><span class="line">	width: 0.27rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>动态计算的<code>rem</code>最后会帮我们动态计算元素在不同屏幕下的宽高</li>
<li>对于设计稿上的每个元素的尺寸在设计稿大小已知的时候，我们需要测量出，然后在用测量的宽高除以设计稿<code>750</code>的十分之一也就是<code>75</code>,得到我们想要的<code>rem</code>。而<code>rem</code>是根据屏幕动态变化的，也就达到了适配的效果。也就是同一套设计稿运用在不同的设备上。</li>
</ul>
<blockquote>
<p>比如当我们切换到<code>320</code>设备大小的时候，这时候<code>1rem=32px;</code> <code>div</code>的像素实际是<code>0.27*32=8.64px``0.27</code>是我们在已知设计稿是<code>750</code>的情况下计算出来的，<code>rem</code>用来动态计算而已</p>
</blockquote>
<ul>
<li>对于<code>margin</code> <code>padding</code> <code>line-height</code> <code>width</code> <code>height</code>使用<code>rem</code>计算</li>
</ul>
<p><strong>如何快速计算</strong></p>
<blockquote>
<p>在实际生产当中，如果每一次计算 <code>px</code> 转换 <code>rem</code> ，或许会觉得非常麻烦</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/flashlizi/cssrem"><code>CSSREM</code></a> 是一个<code>CSS</code>的 <code>px</code> 值转 <code>rem</code> 值的<code>Sublime Text3</code>自动完成插件</li>
<li>插件效果</li>
</ul>
<p><img src="https://github.com/poetries/cssrem/raw/master/cssrem.gif" alt="img"></p>
<blockquote>
<p>插件使用方法</p>
</blockquote>
<ul>
<li><p>安装</p>
<ul>
<li>下载本项目，比如：git clone <a target="_blank" rel="noopener" href="https://github.com/flashlizi/cssrem">https://github.com/flashlizi/cssrem</a></li>
<li>进入<code>packages</code>目录：<code>Sublime Text</code> -&gt; <code>Preferences</code> -&gt; <code>Browse Packages</code>…</li>
<li>复制下载的<code>cssrem</code>目录到刚才的packges目录里。</li>
<li>重启<code>Sublime Text</code></li>
</ul>
</li>
<li><p>配置参数</p>
<ul>
<li><p>参数配置文件：<code>Sublime Text -&gt; Preferences -&gt; Package Settings -&gt; cssrem</code></p>
</li>
<li><p><code>px_to_rem</code> - <code>px</code>转<code>rem</code>的单位比例，默认为<code>40</code>【根据设计稿来设置，如设计稿<code>750</code>，我们取十分之一即<code>75</code>】。</p>
</li>
<li><p><code>max_rem_fraction_length</code> - <code>px</code>转<code>rem</code>的小数部分的最大长度。默认为<code>6</code>。</p>
</li>
<li><p><code>available_file_types</code> - 启用此插件的文件类型。默认为：[“<code>.css</code>“, “<code>.less</code>“, “<code>.sass</code>“]。</p>
</li>
</ul>
</li>
</ul>
<p><strong>文字适配的解决方案</strong></p>
<ul>
<li>对于一些标题性的文字，我们依然可以用<code>rem</code>。让他随着屏幕来进行缩放，因为标题性文字一般较大，而较大的文字，点阵对其影响就越小。这样，即使出现奇怪的尺寸，也能够让字体得到很好的渲染。</li>
<li>对于一些正文内容的文字（即站在使用者的角度，你不希望他进行缩放的文字）。我们采用<code>px</code>来进行处理</li>
</ul>
<h2 id="六、缩放比适配"><a href="#六、缩放比适配" class="headerlink" title="六、缩放比适配"></a>六、缩放比适配</h2><blockquote>
<p>固定宽度，改变缩放比例适配</p>
</blockquote>
<ul>
<li>设计图的宽度就是网页显示的宽度</li>
<li>改变视口的缩放比例</li>
<li>页面宽度固定死</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 缩放比例适配方案--用这个代码 </span><br><span class="line">var width = window.screen.width,</span><br><span class="line">    fixedW = 320, //设计稿宽度的一半</span><br><span class="line">    scale = width / fixedW, // 缩放比例</span><br><span class="line">    meta = document.createElement(&#x27;meta&#x27;),</span><br><span class="line">    metaAttr = &#123;</span><br><span class="line">        name : &#x27;viewport&#x27;,</span><br><span class="line">        content : &#x27;width=&#x27;+fixedW+&#x27;, initial-scale=&#x27;+scale+&#x27;, maximum-scale=&#x27;+scale+&#x27;, user-scalable=0&#x27;</span><br><span class="line">    &#125;;</span><br><span class="line">    for (var key in metaAttr) &#123;</span><br><span class="line">        meta[key] = metaAttr[key];</span><br><span class="line">    &#125;</span><br><span class="line">    document.head.appendChild(meta);</span><br></pre></td></tr></table></figure>

<h2 id="七、像素比适配"><a href="#七、像素比适配" class="headerlink" title="七、像素比适配"></a>七、像素比适配</h2><ul>
<li><code>window.devicePixelRatio</code></li>
<li>物理像素是手机屏幕分辨率</li>
<li>独立像素 指<code>css</code>像素 屏幕宽度</li>
<li>像素比 &#x3D; 物理像素 &#x2F; <code>css宽度</code></li>
<li>获取设备的像素比 <code>window.devicePixelRatio</code></li>
</ul>
<h2 id="八、小结"><a href="#八、小结" class="headerlink" title="八、小结"></a>八、小结</h2><blockquote>
<p>关于移动端布局方案有很多，<code>rem</code>和百分比运用最多的</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="http://ymblog.net/2015/07/01/%E7%A7%BB%E5%8A%A8%E5%89%8D%E7%AB%AFmeta%E6%A0%87%E7%AD%BE%E8%BD%AC/">http://ymblog.net/2015/07/01/移动前端meta标签转/</a>)</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/html/" rel="tag">html</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/" rel="tag">移动端</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AF/">移动端</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-html+css+js+ts/1-flex" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/02/html+css+js+ts/1-flex/" class="article-date">
  	<time datetime="2018-02-02T13:12:23.000Z" itemprop="datePublished">2018-02-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/02/html+css+js+ts/1-flex/">
        flex布局
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、Flex-布局是什么？"><a href="#一、Flex-布局是什么？" class="headerlink" title="一、Flex 布局是什么？"></a>一、Flex 布局是什么？</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p>
<p>任何一个容器都可以指定为 Flex 布局。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>行内元素也可以使用 Flex 布局。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p>
<h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt="img"></p>
<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p>
<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p>
<h2 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h2><p>以下6个属性设置在容器上。</p>
<blockquote>
<ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
</blockquote>
<h3 id="3-1-flex-direction属性"><a href="#3-1-flex-direction属性" class="headerlink" title="3.1 flex-direction属性"></a>3.1 flex-direction属性</h3><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png" alt="img"></p>
<p>它可能有4个值。</p>
<blockquote>
<ul>
<li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li>
<li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li>
<li><code>column</code>：主轴为垂直方向，起点在上沿。</li>
<li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li>
</ul>
</blockquote>
<h3 id="3-2-flex-wrap属性"><a href="#3-2-flex-wrap属性" class="headerlink" title="3.2 flex-wrap属性"></a>3.2 flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png" alt="img"></p>
<blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>它可能取三个值。</p>
<p>（1）<code>nowrap</code>（默认）：不换行。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png" alt="img"></p>
<p>（2）<code>wrap</code>：换行，第一行在上方。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg" alt="img"></p>
<p>（3）<code>wrap-reverse</code>：换行，第一行在下方。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg" alt="img"></p>
<h3 id="3-3-flex-flow"><a href="#3-3-flex-flow" class="headerlink" title="3.3 flex-flow"></a>3.3 flex-flow</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-4-justify-content属性"><a href="#3-4-justify-content属性" class="headerlink" title="3.4 justify-content属性"></a>3.4 justify-content属性</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" alt="img"></p>
<p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>
<blockquote>
<ul>
<li><code>flex-start</code>（默认值）：左对齐</li>
<li><code>flex-end</code>：右对齐</li>
<li><code>center</code>： 居中</li>
<li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li>
<li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
</blockquote>
<h3 id="3-5-align-items属性"><a href="#3-5-align-items属性" class="headerlink" title="3.5 align-items属性"></a>3.5 align-items属性</h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt="img"></p>
<p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>
<blockquote>
<ul>
<li><code>flex-start</code>：交叉轴的起点对齐。</li>
<li><code>flex-end</code>：交叉轴的终点对齐。</li>
<li><code>center</code>：交叉轴的中点对齐。</li>
<li><code>baseline</code>: 项目的第一行文字的基线对齐。</li>
<li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
</blockquote>
<h3 id="3-6-align-content属性"><a href="#3-6-align-content属性" class="headerlink" title="3.6 align-content属性"></a>3.6 align-content属性</h3><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt="img"></p>
<p>该属性可能取6个值。</p>
<blockquote>
<ul>
<li><code>flex-start</code>：与交叉轴的起点对齐。</li>
<li><code>flex-end</code>：与交叉轴的终点对齐。</li>
<li><code>center</code>：与交叉轴的中点对齐。</li>
<li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li>
</ul>
</blockquote>
<h3 id="四、项目的属性"><a href="#四、项目的属性" class="headerlink" title="四、项目的属性"></a>四、项目的属性</h3><p>以下6个属性设置在项目上。</p>
<blockquote>
<ul>
<li><code>order</code></li>
<li><code>flex-grow</code></li>
<li><code>flex-shrink</code></li>
<li><code>flex-basis</code></li>
<li><code>flex</code></li>
<li><code>align-self</code></li>
</ul>
</blockquote>
<h3 id="4-1-order属性"><a href="#4-1-order属性" class="headerlink" title="4.1 order属性"></a>4.1 order属性</h3><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png" alt="img"></p>
<h3 id="4-2-flex-grow属性"><a href="#4-2-flex-grow属性" class="headerlink" title="4.2 flex-grow属性"></a>4.2 flex-grow属性</h3><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png" alt="img"></p>
<p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<h3 id="4-3-flex-shrink属性"><a href="#4-3-flex-shrink属性" class="headerlink" title="4.3 flex-shrink属性"></a>4.3 flex-shrink属性</h3><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg" alt="img"></p>
<p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>
<p>负值对该属性无效。</p>
<h3 id="4-4-flex-basis属性"><a href="#4-4-flex-basis属性" class="headerlink" title="4.4 flex-basis属性"></a>4.4 flex-basis属性</h3><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p>
<h3 id="4-5-flex属性"><a href="#4-5-flex属性" class="headerlink" title="4.5 flex属性"></a>4.5 flex属性</h3><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p>
<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
<h3 id="4-6-align-self属性"><a href="#4-6-align-self属性" class="headerlink" title="4.6 align-self属性"></a>4.6 align-self属性</h3><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" alt="img"></p>
<p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/html/" rel="tag">html</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-html+css+js+ts/1-音视频" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/28/html+css+js+ts/1-%E9%9F%B3%E8%A7%86%E9%A2%91/" class="article-date">
  	<time datetime="2018-01-28T07:53:12.000Z" itemprop="datePublished">2018-01-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/28/html+css+js+ts/1-%E9%9F%B3%E8%A7%86%E9%A2%91/">
        html-原生音视频
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、video"><a href="#一、video" class="headerlink" title="一、video"></a>一、video</h2><hr>
<h3 id="1-1-video支持视频格式"><a href="#1-1-video支持视频格式" class="headerlink" title="1.1 video支持视频格式"></a>1.1 video支持视频格式</h3><hr>
<ul>
<li><p>常见的视频格式</p>
<ul>
<li>视频的组成部分：画面、音频、编码格式</li>
<li>视频编码：<code>H.264</code>、<code>Theora</code>、<code>VP8(google开源)</code></li>
</ul>
</li>
<li><p><code>HTML5</code>支持的视频格式：</p>
<ul>
<li><pre><code>Ogg
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 带有</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  Theora
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">视频编码+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  Vorbis
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">音频编码的</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  Ogg
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    文件</span><br><span class="line"></span><br><span class="line">    - 支持的浏览器:`F`、`C`、`O`</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  MEPG4</span><br></pre></td></tr></table></figure>

- 带有`H.264`视频编码+`AAC`音频编码的`MPEG4`文件
- 支持的浏览器: `S`、`C`
</code></pre>
</li>
<li><p>&#96;&#96;&#96;<br>WebM</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - 带有`VP8`视频编码+`Vorbis`音频编码的`WebM`格式</span><br><span class="line">    - 支持的浏览器: `I`、`F`、`C`、`O`</span><br><span class="line">    - 劣势：视频少、转码器几乎没有，不好转码</span><br><span class="line"></span><br><span class="line">- 想要`video`能自动填充慢父div的大小，只要给`video`标签加上`style=&quot;width= 100%; height=100%; object-fit: fill&quot;`即可</span><br><span class="line"></span><br><span class="line">### 1.2 标签原型</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- 指定一种视频格式，不能播就提示</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><video id="media" src="examp.mp4" width="500" 
poster="examp1.jpg" >您的浏览器不支持video</video></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 给定多种视频格式，浏览器根据自身支持程度选择播放哪一种</span><br><span class="line">- 注意：多个`source`标签，浏览器会从第一个开始识别，如果第一个不被识别，则会继续识别第二个；如果第一个识别成功，则会直接播放第一种格式视频</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<video controls = “controls”>

   <source src=”1.mp4” type=”video/mp4” />  //src属性写到source标签中，要指定视频的type类型，例如MP4的即为type=“video/mp4”

   <source src = “2.ogg” type=”video/ogg” />  //ogg格式

   <source src=”3.webm” type=”video/webm” />   //webm格式

</video>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 1.3 重要的video标签属性</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">| 属性(常用)     | 值            | 功能描述                                       |</span><br><span class="line">| :------------- | :------------ | :--------------------------------------------- |</span><br><span class="line">| **controls**   | controls      | 是否显示播放控件                               |</span><br><span class="line">| **autoplay**   | autoplay      | 设置是否打开浏览器后自动播放                   |</span><br><span class="line">| **width**      | Pilex（像素） | 设置播放器的宽度                               |</span><br><span class="line">| **height**     | Pilex（像素） | 设置播放器的高度                               |</span><br><span class="line">| **loop**       | loop          | 设置视频是否循环播放（即播放完后继续重新播放） |</span><br><span class="line">| **preload**    | preload       | 设置是否等加载完再播放                         |</span><br><span class="line">| **src**        | url           | 设置要播放视频的url地址                        |</span><br><span class="line">| **poster**     | imgurl        | 设置播放器初始默认显示图片                     |</span><br><span class="line">| **autobuffer** | autobuffer    | 设置为浏览器缓冲方式，不设置autoply才有效      |</span><br><span class="line"></span><br><span class="line">- API 属性</span><br><span class="line"></span><br><span class="line">| 属性                | 描述                                                       |</span><br><span class="line">| :------------------ | :--------------------------------------------------------- |</span><br><span class="line">| audioTracks         | 返回表示可用音轨的 AudioTrackList 对象                     |</span><br><span class="line">| buffered            | 返回表示音频/视频已缓冲部分的 TimeRanges 对象              |</span><br><span class="line">| controller          | 返回表示音频/视频当前媒体控制器的 MediaController 对象     |</span><br><span class="line">| crossOrigin         | 设置或返回音频/视频的 CORS 设置                            |</span><br><span class="line">| currentSrc          | 返回当前音频/视频的 URL                                    |</span><br><span class="line">| currentTime         | 设置或返回音频/视频中的当前播放位置（以秒计）              |</span><br><span class="line">| defaultMuted        | 设置或返回音频/视频默认是否静音                            |</span><br><span class="line">| defaultPlaybackRate | 设置或返回音频/视频的默认播放速度                          |</span><br><span class="line">| duration            | 返回当前音频/视频的长度（以秒计）                          |</span><br><span class="line">| ended               | 返回音频/视频的播放是否已结束                              |</span><br><span class="line">| error               | 返回表示音频/视频错误状态的 MediaError 对象                |</span><br><span class="line">| mediaGroup          | 设置或返回音频/视频所属的组合（用于连接多个音频/视频元素） |</span><br><span class="line">| muted               | 设置或返回音频/视频是否静音                                |</span><br><span class="line">| networkState        | 返回音频/视频的当前网络状态                                |</span><br><span class="line">| paused              | 设置或返回音频/视频是否暂停                                |</span><br><span class="line">| playbackRate        | 设置或返回音频/视频播放的速度                              |</span><br><span class="line">| played              | 返回表示音频/视频已播放部分的 TimeRanges 对象              |</span><br><span class="line">| readyState          | 返回音频/视频当前的就绪状态                                |</span><br><span class="line">| seekable            | 返回表示音频/视频可寻址部分的 TimeRanges 对象              |</span><br><span class="line">| seeking             | 返回用户是否正在音频/视频中进行查找                        |</span><br><span class="line">| startDate           | 返回表示当前时间偏移的 Date 对象                           |</span><br><span class="line">| textTracks          | 返回表示可用文本轨道的 TextTrackList 对象                  |</span><br><span class="line">| videoTracks         | 返回表示可用视频轨道的 VideoTrackList 对象                 |</span><br><span class="line">| volume              | 设置或返回音频/视频的音量                                  |</span><br><span class="line"></span><br><span class="line">- 常用API属性</span><br><span class="line"></span><br><span class="line">  - `duration`：返回当前音频/视频的长度（以秒计）</span><br><span class="line">  - `paused`：设置或返回音频/视频是否暂停</span><br><span class="line">  - `currentTime`：设置或返回音频/视频中的当前播放位置（以秒计）</span><br><span class="line">  - `ended`：返回音频/视频的播放是否已结束</span><br><span class="line"></span><br><span class="line">  ### 1.4 Video API</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">#### 1.4.1 Video 方法</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">| API             | 事件说明                                                     |</span><br><span class="line">| :-------------- | :----------------------------------------------------------- |</span><br><span class="line">| **play**        | video.play(); 播放视频                                       |</span><br><span class="line">| **pause**       | video.pause(); 暂停播放视频                                  |</span><br><span class="line">| **load**        | video.load(); 将全部属性回复默认值，视频恢复重新开始状态     |</span><br><span class="line">| **canPlayType** | var support = videoid.canPlayType(‘video/mp4′);   判断浏览器是否支持当前类型的视频格式  返回值：     空字符串：不支持Maybe：可能支持Probably：完全支持 |</span><br><span class="line"></span><br><span class="line">- 常用方法</span><br><span class="line">  - `play()`：开始播放音频/视频</span><br><span class="line">  - `pause()`：暂停当前播放的音频/视频</span><br><span class="line"></span><br><span class="line">#### 1.4.2网络状态</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- 获取video对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  Media = document.getElementById("media");
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- Media.currentSrc</span><br><span class="line"></span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">  - 返回当前资源的URL</span><br><span class="line"></span><br><span class="line">- Media.src = value</span><br><span class="line"></span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">  - 返回或设置当前资源的URL</span><br><span class="line"></span><br><span class="line">- Media.canPlayType(type)</span><br><span class="line"></span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">  - 是否能播放某种格式的资源</span><br><span class="line"></span><br><span class="line">- Media.networkState</span><br><span class="line"></span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">  - 0.此元素未初始化</span><br><span class="line">  - 1.正常但没有使用网络</span><br><span class="line">  - 2.正在下载数据</span><br><span class="line">  - 3.没有找到资源</span><br><span class="line"></span><br><span class="line">- Media.load()</span><br><span class="line"></span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">  - 重新加载src指定的资源</span><br><span class="line"></span><br><span class="line">- Media.buffered</span><br><span class="line"></span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">  - 返回已缓冲区域，TimeRanges</span><br><span class="line"></span><br><span class="line">- Media.preload</span><br><span class="line"></span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">  - none:不预载</span><br><span class="line">  - metadata:预载资源信息</span><br><span class="line">  - auto:</span><br><span class="line"></span><br><span class="line">#### 1.4.3 准备状态</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- **Media.readyState**</span><br><span class="line"></span><br><span class="line">- Media.seeking</span><br><span class="line"></span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">  - 是否正在seeking</span><br><span class="line"></span><br><span class="line">#### 1.4.4 回放状态</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- Media.currentTime = value</span><br><span class="line"></span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">  - 当前播放的位置，赋值可改变位置</span><br><span class="line"></span><br><span class="line">- Media.startTime;</span><br><span class="line"></span><br><span class="line">  - 一般为0，如果为流媒体或者不从0开始的资源，则不为0</span><br><span class="line"></span><br><span class="line">- Media.duration</span><br><span class="line"></span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">  - 当前资源长度 流返回无限</span><br><span class="line"></span><br><span class="line">- Media.paused</span><br><span class="line"></span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">  - 是否暂停</span><br><span class="line"></span><br><span class="line">- Media.defaultPlaybackRate = value</span><br><span class="line"></span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">  - 默认的回放速度，可以设置</span><br><span class="line"></span><br><span class="line">- Media.playbackRate = value</span><br><span class="line"></span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">  - 当前播放速度，设置后马上改变</span><br><span class="line"></span><br><span class="line">- Media.played</span><br><span class="line"></span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">  - 返回已经播放的区域，TimeRanges，关于此对象见下文</span><br><span class="line"></span><br><span class="line">- Media.seekable</span><br><span class="line"></span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">  - 返回可以seek的区域 TimeRanges</span><br><span class="line"></span><br><span class="line">- Media.ended</span><br><span class="line"></span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">  - 是否结束</span><br><span class="line"></span><br><span class="line">- Media.autoPlay</span><br><span class="line"></span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">  - 是否自动播放</span><br><span class="line"></span><br><span class="line">- Media.loop</span><br><span class="line"></span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">  - 是否循环播放</span><br><span class="line"></span><br><span class="line">- Media.play()</span><br><span class="line"></span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">  - 播放</span><br><span class="line"></span><br><span class="line">- Media.pause()</span><br><span class="line"></span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">  - 暂停</span><br><span class="line"></span><br><span class="line">#### 1.4.5 视频控制</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- Media.controls;//是否有默认控制条</span><br><span class="line">- Media.volume = value; //音量</span><br><span class="line">- Media.muted = value; //静音</span><br><span class="line">- TimeRanges(区域)对象</span><br><span class="line">- TimeRanges.length; //区域段数</span><br><span class="line">- TimeRanges.start(index) //第index段区域的开始位置</span><br><span class="line">- TimeRanges.end(index) //第index段区域的结束位置</span><br><span class="line"></span><br><span class="line">#### 1.4.6 相关事件</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- 首先绑定事件的话可以通过js中的addEventListener方法来绑定事件</span><br><span class="line"></span><br><span class="line">| 事件               | 说明                                   |</span><br><span class="line">| :----------------- | :------------------------------------- |</span><br><span class="line">| **loadstart**      | 客户端开始请求数据                     |</span><br><span class="line">| **progress**       | 客户端正在请求数据                     |</span><br><span class="line">| **suspend**        | 延迟下载                               |</span><br><span class="line">| **abort**          | 客户端主动终止下载（不是因为错误引起） |</span><br><span class="line">| **loadstart**      | 客户端开始请求数据                     |</span><br><span class="line">| **progress**       | 客户端正在请求数据                     |</span><br><span class="line">| **error**          | 请求数据时遇到错误                     |</span><br><span class="line">| **stalled**        | 网速失速                               |</span><br><span class="line">| **play**           | play()和autoplay开始播放时触发         |</span><br><span class="line">| **pause**          | pause()触发                            |</span><br><span class="line">| **loadedmetadata** | 成功获取资源长度                       |</span><br><span class="line">| **loadeddata**     | -                                      |</span><br><span class="line">| **waiting**        | 等待数据，并非错误                     |</span><br><span class="line">| **playing**        | 开始回放                               |</span><br><span class="line">| **canplay**        | 可以播放，但中途可能因为加载而暂停     |</span><br><span class="line">| **canplaythrough** | 可以播放，歌曲全部加载完毕             |</span><br><span class="line">| **seeking**        | 寻找中                                 |</span><br><span class="line">| **seeked**         | 寻找完毕                               |</span><br><span class="line">| **timeupdate**     | 播放时间改变                           |</span><br><span class="line">| **ended**          | 播放结束                               |</span><br><span class="line">| **ratechange**     | 播放速率改变                           |</span><br><span class="line">| **durationchange** | 资源长度改变                           |</span><br><span class="line">| **volumechange**   | 音量改变                               |</span><br><span class="line"></span><br><span class="line">- 常用事件</span><br><span class="line">  - `oncanplay`：当文件就绪可以开始播放时运行的脚本（缓冲已足够开始时）。</span><br><span class="line">  - `ontimeupdate`： 当播放位置改变时（比如当用户快进到媒介中一个不同的位置时）运行的脚本。</span><br><span class="line">  - `onended`：当媒介已到达结尾时运行的脚本（可发送类似“感谢观看”之类的消息）。</span><br><span class="line"></span><br><span class="line">#### 1.4.7 其他</span><br><span class="line"></span><br><span class="line">- 全屏:</span><br><span class="line">  - `element.webkitRequestFullScreen();`( webkit)</span><br><span class="line">  - `element.mozRequestFullScreen();` (Firefox )</span><br><span class="line">  - `element.requestFullscreen();` (W3C )</span><br><span class="line">- 退出全屏：</span><br><span class="line">  - `document.webkitCancelFullScreen()`; (webkit )</span><br><span class="line">  - `document.mozCancelFullScreen()`; (Firefox)</span><br><span class="line">  - `document.exitFullscreen();` (W3C)</span><br><span class="line"></span><br><span class="line">## 二、audio</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### 2.1 audio格式</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- 常见的音频格式</span><br><span class="line">  - 音频编码：`ACC`、`MP3`、`Vorbis`</span><br><span class="line">- HTML5支持的音频格式：</span><br><span class="line">  - `Ogg` 免费 支持的浏览器:`C`、`F`、`O`</span><br><span class="line">  - `MP3` 收费 支持的浏览器: `I`、`C`、`S`</span><br><span class="line">  - `Wav` 收费 支持的浏览器: `F`、`O`、`S`</span><br><span class="line"></span><br><span class="line">### 2.2 audio标签中的一些常用属性</span><br><span class="line"></span><br><span class="line">| 属性         | 属性值   | 注释                                                         |</span><br><span class="line">| :----------- | :------- | :----------------------------------------------------------- |</span><br><span class="line">| **src**      | url      | 播放的音乐的url地址（火狐只支持ogg的音乐，而IE9只支持MP3格式的音乐。chrome貌似全支持） |</span><br><span class="line">| **preload**  | preload  | 预加载（在页面被加载时进行加载或者说缓冲音频），如果使用了autoplay的话那么该属性失效。 |</span><br><span class="line">| **loop**     | loop     | 循环播放                                                     |</span><br><span class="line">| **controls** | controls | 是否显示默认控制条（控制按钮）                               |</span><br><span class="line">| **autoplay** | autoplay | 自动播放                                                     |</span><br><span class="line"></span><br><span class="line">- 对于音乐格式的支持</span><br><span class="line"></span><br><span class="line">| 音频格式 | Chrome | Firefox | IE9    | Opera  | Safari |</span><br><span class="line">| :------- | :----- | :------ | :----- | :----- | :----- |</span><br><span class="line">| OGG      | 支持   | 支持    | 支持   | 不支持 | 不支持 |</span><br><span class="line">| MP3      | 支持   | 不支持  | 支持   | 不支持 | 支持   |</span><br><span class="line">| WAV      | 不支持 | 支持    | 不支持 | 支持   | 不支持 |</span><br><span class="line"></span><br><span class="line">- audio可通过new来创建。也可以通过用document来获取</span><br><span class="line"></span><br></pre></td></tr></table></figure>
//通过new关键字来创建Audio对象
var Music = new Audio("test.mp3");

<p>&#x2F;&#x2F;通过document来获取已经存在的Audio对象<br>var Music &#x3D; document.getElementById(“audio”);<br>&#x2F;&#x2F;当然这里也可以使用document.getElementsByClassName(‘className’)等其他的方法来获取。</p>
<p>&#96;&#96;&#96;</p>
<h3 id="2-3-api所提供的对audio标签操作的一些属性和方法"><a href="#2-3-api所提供的对audio标签操作的一些属性和方法" class="headerlink" title="2.3 api所提供的对audio标签操作的一些属性和方法"></a>2.3 api所提供的对audio标签操作的一些属性和方法</h3><hr>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">注释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>duration</strong></td>
<td align="left">获取媒体文件的总时长，以s为单位，如果无法获取，返回NaN</td>
</tr>
<tr>
<td align="left"><strong>paused</strong></td>
<td align="left">如果媒体文件被暂停，那么paused属性返回true，反之则返回false</td>
</tr>
<tr>
<td align="left"><strong>ended</strong></td>
<td align="left">如果媒体文件播放完毕返回true</td>
</tr>
<tr>
<td align="left"><strong>muted</strong></td>
<td align="left">用来获取或设置静音状态。值为boolean</td>
</tr>
<tr>
<td align="left"><strong>volume</strong></td>
<td align="left">控制音量的属性值为0-1;0为音量最小，1为音量最大</td>
</tr>
<tr>
<td align="left"><strong>startTime</strong></td>
<td align="left">返回起始播放时间</td>
</tr>
<tr>
<td align="left"><strong>error</strong></td>
<td align="left">返回错误代码，为uull的时候为正常。否则可以通过Music.error.code来获取</td>
</tr>
<tr>
<td align="left"><strong>currentTime</strong></td>
<td align="left">用来获取或控制当前播放的时间，单位为s。</td>
</tr>
<tr>
<td align="left"><strong>currentSrc</strong></td>
<td align="left">以字符串形式返回正在播放或已加载的文件</td>
</tr>
</tbody></table>
<h3 id="2-4-常用的控制用的函数"><a href="#2-4-常用的控制用的函数" class="headerlink" title="2.4 常用的控制用的函数"></a>2.4 常用的控制用的函数</h3><hr>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>load()</strong></td>
<td align="left">加载音频、视频软件</td>
</tr>
<tr>
<td align="left"><strong>play()</strong></td>
<td align="left">加载并播放音频、视频文件或重新播放暂停的的音频、视频</td>
</tr>
<tr>
<td align="left"><strong>pause()</strong></td>
<td align="left">暂停出于播放状态的音频、视频文件</td>
</tr>
<tr>
<td align="left"><strong>canPlayType(obj)</strong></td>
<td align="left">测试是否支持给定的Mini类型的文件</td>
</tr>
</tbody></table>
<h3 id="2-5-audio标签API中的常用事件"><a href="#2-5-audio标签API中的常用事件" class="headerlink" title="2.5 audio标签API中的常用事件"></a>2.5 audio标签API中的常用事件</h3><hr>
<ul>
<li>首先绑定事件的话可以通过js中的addEventListener方法来绑定事件</li>
</ul>
<table>
<thead>
<tr>
<th align="left">事件名称</th>
<th align="left">事件作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>loadstart</strong></td>
<td align="left">客户端开始请求数据</td>
</tr>
<tr>
<td align="left"><strong>progress</strong></td>
<td align="left">客户端正在请求数据（或者说正在缓冲）</td>
</tr>
<tr>
<td align="left"><strong>play</strong></td>
<td align="left">play()和autoplay播放时</td>
</tr>
<tr>
<td align="left"><strong>pause</strong></td>
<td align="left">pause()方法促发时</td>
</tr>
<tr>
<td align="left"><strong>ended</strong></td>
<td align="left">当前播放结束</td>
</tr>
<tr>
<td align="left"><strong>timeupdate</strong></td>
<td align="left">当前播放时间发生改变的时候。播放中常用的时间处理</td>
</tr>
<tr>
<td align="left"><strong>canplaythrough</strong></td>
<td align="left">歌曲已经载入完全完成</td>
</tr>
<tr>
<td align="left"><strong>canplay</strong></td>
<td align="left">缓冲至目前可播放状态。</td>
</tr>
</tbody></table>
<p>其实<code>video</code>的<code>api</code>和<code>audio</code>几乎一致。稍稍有点不同。所以基本上会了一个其他的也就都会了s</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/html/" rel="tag">html</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-html+css+js+ts/1-h5-api" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/26/html+css+js+ts/1-h5-api/" class="article-date">
  	<time datetime="2018-01-26T02:24:27.000Z" itemprop="datePublished">2018-01-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/26/html+css+js+ts/1-h5-api/">
        html-api
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、Canvas-API"><a href="#一、Canvas-API" class="headerlink" title="一、Canvas API"></a>一、Canvas API</h3><hr>
<p><code>canvas API</code>是<code>H5</code>标准中最复杂的部分， 它提供几种属性和方法，可以在<code>canvas</code>元素上创建图形应用</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><hr>
<p>以下方法专门用于调用canvas API</p>
<ul>
<li><code>getContext(context)</code>创建可绘制图形的画布上下文，接受两个值，<code>2d</code>和<code>3d</code></li>
<li><code>fillRect(x,y,width,height)</code>绘制实心矩形</li>
<li><code>strokeRect(x,y,width,height)</code>绘制矩形轮廓</li>
<li><code>clearRect(x,y,width,height)</code>清除画布指定区域内容</li>
<li><code>createLinearGradient(x1,y1,x2,y2)</code>创建一个线性渐变效果</li>
<li><code>createRadialGradient(x1,y1,r1,x2,y2,r2)</code>创建一个放射渐变效果</li>
<li><code>addColorStop(position,color)</code>用于声明渐变颜色<code>position</code>范围是<code>0.0-1.0</code> 用于确定颜色开始变化位置</li>
<li><code>beginPath()</code>开始一条新路径</li>
<li><code>closePath()</code>在路径最后实现封闭该路径，它会生成一条直线，连接笔触的最后一个位置与路径的起点。如想要保持路径开放，使用<code>fill()</code>绘图，不用这个方法</li>
<li><code>stroke()</code> 用于创建路径轮廓</li>
<li><code>fill()</code>用于绘制实心形状</li>
<li><code>clip()</code>用于创建一个由路径定义的裁剪区域，只有在落入形状内的内容才绘制到画布上</li>
<li><code>moveTo(x,y)</code>将虚拟笔触移到新位置，下一个方法会从改点的开始继续设置路径</li>
<li><code>lineTo(x,y)</code>在新路径上添加一条直线</li>
<li><code>rect(x,y,width,height)</code>在路径为<code>(x,y)</code>位置上添加<code>width</code>和<code>height</code>矩形</li>
<li><code>arc(x,y,radius,startAngle,endAngle,direction)</code>在路径上添加一条弧线 ,<code>x</code>,<code>y</code>指定弧线的中心，角度单位为弧度，<code>direction</code>是一个表示顺时针或逆时针的布尔值。使用公式 <code>Math.PI/180x</code>角度，将角度转换为半径</li>
<li><code>strokeText(text,x,y,max)</code> 直接在画布上绘制文字轮廓。可选参数，max声明文字最大尺寸</li>
<li><code>fillText(text,x,y,max)</code>直接在画布上绘制实心文字。可选参数，<code>max</code>声明文字最大尺寸</li>
<li><code>translate(x,y)</code>将画布原点移到点<code>(x,y)</code>处，原点<code>（0,0）</code>初始位置位于<code>canvas</code>所在区域的左上角</li>
<li><code>rorate(angle)</code>这个方法可以使画布原点为中心发生旋转，角度必须是弧度。使用公式<code>Math.PI/180x</code> 将角度转换为弧度</li>
<li><code>scale(x,y)</code> 改变画布比例 默认值是<code>（1.0,1.0）</code>这些值可以是负值</li>
<li><code>transform（m1,m2,m3,m4,dx,dy）</code>修改画布的转换矩阵。新矩阵是基于之前的矩阵得到的</li>
<li><code>setTransform（m1,m2,m3,m4,dx,dy）</code>修改画布的转换矩阵。重置之前的值，声明新的值</li>
<li><code>save()</code>保存画布状态，包括转换矩阵、样式属性、裁剪遮罩</li>
<li><code>restore()</code> 恢复上一次保存的状态</li>
<li><code>drawImage()</code> 在画布上绘制图像</li>
</ul>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><hr>
<p><code>canvas API</code>专用属性列表</p>
<ul>
<li><code>rect( x, y, width, height )</code> 绘制矩形</li>
<li><code>fillRect( x, y, width, height )</code> 绘制被填充的矩形</li>
<li><code>strokeRect( x, y, width, height )</code> 绘制矩形（无填充）</li>
<li><code>clearRect( x, y, width, height )</code> 清除指定的矩形内的像素</li>
<li><code>fill()</code> 填充当前绘图（路径）</li>
<li><code>stroke()</code>绘制已定义的路径</li>
<li><code>beginPath()</code> 起始（重置）当前路径</li>
<li><code>moveTo( x, y )</code> 将笔触移动到指定的坐标(x,y)</li>
<li><code>lineTo( x, y )</code> 绘制一条从当前位置到指定的坐标(x,y)的直线</li>
<li><code>clip()</code> 从原始画布剪切任意形状和尺寸的区域</li>
<li><code>quadraticCurveTo()</code> 创建二次贝塞尔曲线</li>
<li><code>bezierCurveTo()</code> 创建三次贝塞尔曲线</li>
<li><code>arc( x, y, radius, startAngle, endAngle, anticlockwise)</code> 绘制圆或圆弧</li>
<li><code>arcTo( x1, y1, x2, y2, radius)</code> 根据给定点画圆弧，再以直线连接两个点</li>
<li><code>isPointInPath( x, y )</code> 检测指定的点是否在当前路径中，在则返回true。</li>
<li><code>fillStyle</code> 设置或返回用于填充绘画的颜色、渐变或模式</li>
<li><code>strokeStyle</code> 设置或返回用于笔触的颜色、渐变或模式</li>
<li><code>shadowColor</code> 设置或返回用于阴影的颜色</li>
<li><code>shadowBlur</code> 设置或返回用于阴影的模糊级别</li>
<li><code>shadowOffsetX</code> 设置或返回阴影与形状的水平距离</li>
<li><code>shadowOffsetY</code> 设置或返回阴影与形状的垂直距离</li>
<li><code>lineCap</code> 设置或返回线条的结束点样式（<code>butt</code>、<code>round</code>、<code>square</code>）</li>
<li><code>lineJoin</code> 设置或返回当两条线交汇时，边角的类型（<code>bevel</code>、<code>round</code>、miter）</li>
<li><code>lineWidth</code> 设置或返回当前的线条宽度</li>
<li><code>miterLimit</code> 设置或返回最大斜接长度</li>
<li><code>createLinearGradient( x0, y0, x1, y1 )</code> 创建线性渐变</li>
<li><code>createPattern( image/canvas/video, repeat )</code> 在指定的方向内重复绘制指定的元素</li>
<li><code>createRadialGradient( x0, y0, r0, x1, y1, r1 )</code>创建径向渐变</li>
<li><code>addColorStop( stop, color )</code> 规定渐变对象中的颜色和停止位置</li>
<li><code>font</code> 设置或返回文本内容的当前字体属性（和css的font一样）</li>
<li><code>textAlign</code> 设置或返回文本内容的当前对齐方式</li>
<li><code>textBaseline</code> 设置或返回在绘制文本时使用的当前文本基线</li>
<li><code>fillText( text, x, y )</code> 在画布上绘制“被填充”的文本</li>
<li><code>strokeText( text, x, y )</code> 在画布上绘制文本（无填充）</li>
<li><code>measureText( text )</code> 返回包含指定文本宽度的对象（属性width获取宽度）</li>
<li><code>drawImage( image/canvas, x, y )</code>、drawImage( image&#x2F;canvas, x, y, width, height )、drawImage( image&#x2F;canvas, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight )&#96; 在画布上绘制图像、画布或视频</li>
<li><code>createImageData( width, height )</code>、createImageData(imageData) 绘制ImageData对象</li>
<li><code>getImageData( x, y, width, height )</code> 返回ImageData对象，该对象为画布上指定的矩形复制像素数据。</li>
<li><code>putImageData( ImageData, x, y )</code>、putImageData( imageData, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight ) 把图像数据放回画布上。</li>
<li><code>width</code> 返回ImageData对象的宽度</li>
<li><code>height</code> 返回<code>ImageData</code>对象的高度</li>
<li><code>data</code> 返回一个对象，包含指定的ImageData对象的图像数据</li>
<li><code>globalAlpha</code> 设置或返回绘图的当前alpha或透明度</li>
<li><code>globalCompositeOperation</code> 设置或返回新图像如何绘制到已有的图像上。</li>
<li><code>scale( x, y )</code> 缩放当前绘图</li>
<li><code>translate( x, y )</code> 重新设置画布上的(0,0)位置</li>
<li><code>rotate( angle )</code> 选择当前绘图，单位为“弧度”，角度转弧度公式<code>（ degrees*Math.PI/180）</code></li>
<li><code>transform( m11, m12, m21, m22, dx, dy )</code> 替换绘图的当前转换矩阵</li>
<li><code>setTransform()</code> 将当前转换重置为单元矩阵，然后运行transform()</li>
<li><code>save()</code> 保存当前环境的状态</li>
<li><code>restore()</code> 恢复之前保存过的路径状态和属性</li>
<li><code>getContext(&#39;2d&#39;)</code> 获取<code>2d</code>对象</li>
<li><code>toDataURL()</code> 将canvas转换成图片，返回地址</li>
</ul>
<h4 id="canvas常用总结"><a href="#canvas常用总结" class="headerlink" title="canvas常用总结"></a>canvas常用总结</h4><hr>
<ul>
<li><p>标签</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>不支持<code>canvas</code> 的浏览器可以看到的内容</li>
</ul>
</li>
<li><pre><code>&lt;canvas&gt;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  绘制环境</span><br><span class="line"></span><br><span class="line">  - `getContext(&quot;2d&quot;)`;目前支持`2d`的场景</span><br><span class="line"></span><br><span class="line">- 绘制矩形</span><br><span class="line"></span><br><span class="line">  - `rect(L,T,W,H)`:创建一个矩形</span><br><span class="line"></span><br><span class="line">  - `fillRect(L,T,W,H)`:绘制填充的矩形</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    strokeRect(L,T,W,H)</span><br></pre></td></tr></table></figure>

  绘制矩形(无填充)

  - 默认一像素黑色边框
</code></pre>
</li>
<li><p>设置绘图</p>
<ul>
<li><code>fillStyle</code>:填充颜色(绘制<code>canvas</code>是有顺序的)</li>
<li><code>lineWidth</code>:线宽度，笔迹粗细</li>
<li><code>strokeStyle</code>:边线颜色</li>
</ul>
</li>
<li><p>绘制路径</p>
<ul>
<li><code>stroke</code> ：绘制，划线(黑色默认)</li>
<li><code>fill</code> :填充(黑色默认)</li>
<li><code>rect(矩形区域)</code></li>
<li><code>clearRect</code> 擦除一个矩形区域</li>
<li><code>save</code> 进入到XXX（高逼格）状态</li>
<li><code>restore</code> 退出xxx（高逼格）状态</li>
</ul>
</li>
<li><p>绘制圆形</p>
<ul>
<li><code>arc(x,y,半径,起始弧度,结束弧度,旋转方向)</code></li>
<li><code>x</code>，<code>y</code>起始位置</li>
<li>弧度与角度：<code>弧度=角度 x π / 180</code></li>
<li>旋转方向：顺时针（默认：<code>false</code>），逆时针（<code>true</code>）</li>
</ul>
</li>
<li><p>绘制字体</p>
<ul>
<li><code>font</code>：设置字体大小</li>
<li><code>fillText</code>：填充字体</li>
<li><code>strokeText</code>：绘制字体</li>
</ul>
</li>
</ul>
<h3 id="二、视频音频"><a href="#二、视频音频" class="headerlink" title="二、视频音频"></a>二、视频音频</h3><hr>
<ul>
<li><p>视频音频格式的简单介绍</p>
<ul>
<li>常见的视频格式<ul>
<li>视频的组成部分：画面、音频、编码格式</li>
<li>视频编码：H.264、Theora、VP8(google开源)</li>
</ul>
</li>
<li>常见的音频格式<ul>
<li>视频编码：ACC、MP3、Vorbis</li>
</ul>
</li>
</ul>
</li>
<li><p><code>HTML5</code>能在完全脱离插件的情况下播放音视频,但是不是所有格式都支持。</p>
</li>
<li><p>支持的视频格式：</p>
<ul>
<li><code>Ogg=</code>带有<code>Theora</code>视频编码<code>+Vorbis</code>音频编码的<code>Ogg</code>文件</li>
<li><code>MEPG4=</code>带有H.264视频编码<code>+AAC</code>音频编码的<code>MPEG4</code>文件</li>
<li><code>WebM=</code>带有<code>VP8</code>视频编码<code>+Vorbis</code>音频编码的<code>WebM</code>格式</li>
</ul>
</li>
</ul>
<h4 id="Video的使用"><a href="#Video的使用" class="headerlink" title="Video的使用"></a><code>Video</code>的使用</h4><hr>
<ul>
<li>单独用法<ul>
<li>&#96;&#96;</li>
</ul>
</li>
<li>带提示用法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt; video src=&quot;文件地址&quot; controls=&quot;controls&quot;&gt;</span><br><span class="line">	您的浏览器暂不支持video标签。播放视频</span><br><span class="line">&lt;/ video &gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>兼容用法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt; video  controls=&quot;controls&quot;  width=&quot;300&quot;&gt;</span><br><span class="line">	&lt;source src=&quot;move.ogg&quot; type=&quot;video/ogg&quot; &gt;</span><br><span class="line">	&lt;source src=&quot;move.mp4&quot; type=&quot;video/mp4&quot; &gt;</span><br><span class="line">	您的浏览器暂不支持video标签。播放视频</span><br><span class="line">&lt;/ video &gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Video</code>的常见属性</li>
</ul>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Autoplay</td>
<td align="left">Autoplay</td>
<td align="left">视频就绪自动播放</td>
</tr>
<tr>
<td align="left">controls</td>
<td align="left">controls</td>
<td align="left">向用户显示播放控件</td>
</tr>
<tr>
<td align="left">Width</td>
<td align="left">Pixels(像素)</td>
<td align="left">设置播放器宽度</td>
</tr>
<tr>
<td align="left">Height</td>
<td align="left">Pixels(像素)</td>
<td align="left">设置播放器高度</td>
</tr>
<tr>
<td align="left">Loop</td>
<td align="left">Loop</td>
<td align="left">播放完是否继续播放该视频，循环播放</td>
</tr>
<tr>
<td align="left">Preload</td>
<td align="left">load{auto,meta,none}</td>
<td align="left">规定是否预加载视频。</td>
</tr>
<tr>
<td align="left">Src</td>
<td align="left">url</td>
<td align="left">视频url地址</td>
</tr>
<tr>
<td align="left">Poster</td>
<td align="left">Imgurl</td>
<td align="left">加载等待的画面图片</td>
</tr>
<tr>
<td align="left">Autobuffer</td>
<td align="left">Autobuffer</td>
<td align="left">设置为浏览器缓冲方式，不设置autoply才有效</td>
</tr>
</tbody></table>
<ul>
<li><code>Video</code>的<code>API</code>方法</li>
</ul>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">属性</th>
<th align="left">事件</th>
</tr>
</thead>
<tbody><tr>
<td align="left">play()</td>
<td align="left">currentSrc</td>
<td align="left">play</td>
</tr>
<tr>
<td align="left">pause()</td>
<td align="left">currentTime</td>
<td align="left">pause</td>
</tr>
<tr>
<td align="left">load()</td>
<td align="left">videoWidth</td>
<td align="left">progress</td>
</tr>
<tr>
<td align="left">canPlayType()</td>
<td align="left">videoHeight</td>
<td align="left">error</td>
</tr>
</tbody></table>
<h3 id="三、地理信息与本地存储"><a href="#三、地理信息与本地存储" class="headerlink" title="三、地理信息与本地存储"></a>三、地理信息与本地存储</h3><hr>
<h4 id="地理位置"><a href="#地理位置" class="headerlink" title="地理位置"></a>地理位置</h4><hr>
<ul>
<li><p>经度 : 南北极的连接线</p>
</li>
<li><p>纬度 : 东西连接的线</p>
</li>
<li><p>位置信息从何而来</p>
<ul>
<li><code>IP</code>地址</li>
<li><code>GPS</code>全球定位系统</li>
<li><code>Wi-Fi</code>无线网络</li>
<li>基站</li>
</ul>
</li>
<li><p><code>avigator.geolocation</code></p>
<ul>
<li><p>单次定位请求 ：<code>getCurrentPosition</code>(请求成功,请求失败,数据收集方式)</p>
</li>
<li><p>请求成功函数</p>
<ul>
<li>经度 : <code>coords.longitude</code></li>
<li>纬度 : <code>coords.latitude</code></li>
<li>准确度 : <code>coords.accuracy</code></li>
<li>海拔 : <code>coords.altitude</code></li>
<li>海拔准确度 : <code>coords.altitudeAcuracy</code></li>
<li>行进方向 : <code>coords.heading</code></li>
<li>地面速度 : <code>coords.speed</code></li>
<li>请求的时间: <code>new Date(position.timestamp)</code></li>
</ul>
</li>
<li><p>请求失败函数</p>
<ul>
<li><p>失败编号 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code</span><br></pre></td></tr></table></figure>

<ul>
<li>0 : 不包括其他错误编号中的错误</li>
<li>1 : 用户拒绝浏览器获取位置信息</li>
<li>2 : 尝试获取用户信息，但失败了</li>
<li>3 : 设置了<code>timeout</code>值，获取位置超时了</li>
</ul>
</li>
</ul>
</li>
<li><p>数据收集 : json的形式</p>
<ul>
<li><code>enableHighAcuracy</code> : 更精确的查找，默认<code>false</code></li>
<li><code>timeout</code> : 获取位置允许最长时间，默认<code>infinity</code></li>
<li><code>maximumAge</code> : 位置可以缓存的最大时间，默认<code>0</code></li>
</ul>
</li>
<li><p>多次定位请求* : <code>watchPosition</code></p>
<ul>
<li>移动设备有用，位置改变才会触发</li>
<li>配置参数：<code>frequency</code> 更新的频率</li>
<li>关闭更新请求 : <code>clearWatch</code></li>
</ul>
</li>
<li><p>百度地图<code>API</code></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://api.map.baidu.com/api?v=2.0&amp;ak=qZfInp9MaT9Qa0PoNy4Rmx3Y9W9ZXMfw&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h4><hr>
<ul>
<li><p><code>Storage</code></p>
<ul>
<li>&#96;&#96;&#96;<br>sessionStorage<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - `session`临时回话，从页面打开到页面关闭的时间段</span><br><span class="line">  - 窗口的临时存储，页面关闭，本地存储消失</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  localStorage</span><br></pre></td></tr></table></figure>

<ul>
<li>永久存储（可以手动删除数据）</li>
</ul>
</li>
</ul>
</li>
<li><p><code>Storage</code>的特点</p>
<ul>
<li>存储量限制 ( 5M )</li>
<li>客户端完成，不会请求服务器处理</li>
<li><code>sessionStorage</code>数据是不共享、 <code>localStorage</code>共享</li>
</ul>
</li>
<li><p><code>Storage API</code></p>
<ul>
<li><pre><code>setItem()
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  :</span><br><span class="line"></span><br><span class="line">  - 设置数据，(`key`,`value`)类型，类型都是字符串</span><br><span class="line">  - 可以用获取属性的形式操作</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  getItem():</span><br></pre></td></tr></table></figure>

- 获取数据，通过`key`来获取到相应的`value`
</code></pre>
</li>
<li><p>&#96;&#96;&#96;<br>removeItem()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  :</span><br><span class="line"></span><br><span class="line">  - 删除数据，通过key来删除相应的`value`</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  clear()</span><br></pre></td></tr></table></figure>

<p>:</p>
<ul>
<li>删除全部存储的值</li>
</ul>
</li>
</ul>
</li>
<li><p>存储事件:</p>
<ul>
<li>当数据有修改或删除的情况下，就会触发<code>storage</code>事件</li>
<li>在对数据进行改变的窗口对象上是不会触发的&#96;</li>
<li><code>Key</code> : 修改或删除的<code>key</code>值，如果调用<code>clear()</code>,<code>key</code>为<code>null</code></li>
<li><code>newValue</code> : 新设置的值，如果调用<code>removeStorage()</code>,<code>key</code>为<code>null</code></li>
<li><code>oldValue</code> : 调用改变前的<code>value</code>值</li>
<li><code>storageArea</code> : 当前的<code>storage</code>对象</li>
<li><code>url</code> : 触发该脚本变化的文档的url</li>
<li>注：<code>session</code>同窗口才可以,例子：<code>iframe</code>操作</li>
</ul>
</li>
</ul>
<h3 id="四、HTML5拖拽"><a href="#四、HTML5拖拽" class="headerlink" title="四、HTML5拖拽"></a>四、HTML5拖拽</h3><hr>
<ul>
<li><p>图片自带拖拽功能</p>
</li>
<li><p>其他元素可设置<code>draggable</code>属性</p>
</li>
<li><p><code>draggable ：true</code></p>
<ul>
<li><p>拖拽元素(被拖拽元素对象)事件 :</p>
<ul>
<li><code>ondragstart</code> : 拖拽前触发</li>
<li><code>ondrag</code> :拖拽前、拖拽结束之间，连续触发</li>
<li><code>ondragend</code> :拖拽结束触发</li>
</ul>
</li>
<li><p>目标元素(拖拽元素被拖到的对象)事件 :</p>
<ul>
<li><p><code>ondragenter</code> :进入目标元素触发</p>
</li>
<li><p><code>ondragover</code>:进入目标、离开目标之间，连续触发</p>
</li>
<li><p><code>ondragleave</code> :离开目标元素触发</p>
</li>
<li><p>&#96;&#96;&#96;<br>ondrop</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">      :在目标元素上释放鼠标触发</span><br><span class="line"></span><br><span class="line">      - 需要在`ondragover`事件里面阻止默认事件</span><br><span class="line"></span><br><span class="line">- 拖拽兼容问题</span><br><span class="line"></span><br><span class="line">  - 火狐浏览器下需设置`dataTransfer`对象才可以拖拽除图片外的其他标签</span><br><span class="line"></span><br><span class="line">    - `dataTransfer`对象</span><br><span class="line"></span><br><span class="line">    - `setData()` : 设置数据 `key`和`value`(必须是字符串)</span><br><span class="line"></span><br><span class="line">    - `getData()` : 获取数据，根据`key`值，获取对应的`value`</span><br><span class="line"></span><br><span class="line">    - `effectAllowed` : 设置光标样式(`none`, `copy`, `copyLink`, `copyMove`, `link`, `linkMove`,`move`, `all` 和`uninitialized`)</span><br><span class="line"></span><br><span class="line">    - `setDragImage` ：三个参数（指定的元素，坐标`X`，坐标`Y`）</span><br><span class="line"></span><br><span class="line">    - ```</span><br><span class="line">      files</span><br></pre></td></tr></table></figure>

<p>： 获取外部拖拽的文件，返回一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filesList</span><br></pre></td></tr></table></figure>

<p>列表</p>
<ul>
<li><code>filesList</code>下有个<code>type</code>属性，返回文件的类型</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>读取文件信息</p>
<ul>
<li><p>&#96;&#96;&#96;<br>FileReader</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    (读取文件信息)</span><br><span class="line"></span><br><span class="line">    - `readAsDataURL`</span><br><span class="line"></span><br><span class="line">  - 参数为要读取的文件对象</span><br><span class="line"></span><br><span class="line">    - `onload`当读取文件成功完成的时候触发此事件</span><br><span class="line">    - `this. result` 获取读取的文件数据</span><br><span class="line"></span><br><span class="line">### 五、跨文档操作</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- 跨文档请求</span><br><span class="line"></span><br><span class="line">- 同域跨文档</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    iframe</span><br></pre></td></tr></table></figure>

<p>内页：</p>
<ul>
<li>父页面操作子页面：<code>contentWindow</code></li>
<li>子页面操作父页面：<code>window.top</code>(找到最顶级的父页面)&#x2F;<code>parent</code>(第一父页面)</li>
<li>新窗口页：<ul>
<li>父页面操作子页面：<code>window.open</code></li>
<li>子页面操作父页面：<code>window.opener</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>不同域跨文档</p>
<ul>
<li><p>&#96;&#96;&#96;<br>postMessage（“发送的数据”,”接收的域”）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - `message`事件监听</span><br><span class="line">    - `ev.origin`发送数据来源的域</span><br><span class="line">    - `ev.data` 发送的数据</span><br><span class="line"></span><br><span class="line">  - 通过判断发送的数据来执行相应的需求</span><br><span class="line"></span><br><span class="line">- ajax跨域</span><br><span class="line"></span><br><span class="line">  - `XMLHttpRequest` 新增功能</span><br><span class="line"></span><br><span class="line">    - 跨域请求：修改服务端头信息</span><br><span class="line">      - I`E`兼容：`XDomaiRequest`</span><br><span class="line"></span><br><span class="line">  - 进度事件：</span><br><span class="line"></span><br><span class="line">    - ```</span><br><span class="line">      upload.onprogress(ev)</span><br></pre></td></tr></table></figure>

<p>  上传进度(实现文件上传进度条)</p>
<ul>
<li><p><code>ev.total</code> 发送文件的总量</p>
</li>
<li><p><code>ev.loaded</code> 已发送的量</p>
</li>
<li><p><code>FormData</code> 构建提交二进制数据</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/html/" rel="tag">html</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-html+css+js+ts/3-js宽高属性" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/24/html+css+js+ts/3-js%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7/" class="article-date">
  	<time datetime="2018-01-24T03:35:46.000Z" itemprop="datePublished">2018-01-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/24/html+css+js+ts/3-js%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7/">
        js宽高属性
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="第一部分-JavaScript中的宽高属性"><a href="#第一部分-JavaScript中的宽高属性" class="headerlink" title="第一部分 JavaScript中的宽高属性"></a>第一部分 JavaScript中的宽高属性</h2><hr>
<h3 id="一、与window相关的宽高属性"><a href="#一、与window相关的宽高属性" class="headerlink" title="一、与window相关的宽高属性"></a>一、与window相关的宽高属性</h3><hr>
<h4 id="1-1-window-location和document-location"><a href="#1-1-window-location和document-location" class="headerlink" title="1.1 window.location和document.location"></a>1.1 window.location和document.location</h4><hr>
<ul>
<li><p><code>window</code>对象的<code>location</code>属性引用的是<code>location</code>对象，表示该窗口中当前显示文档的<code>URL</code></p>
</li>
<li><p><code>document</code>的对象的<code>location</code>属性也是引用<code>location</code>对象</p>
</li>
<li><p>所以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.location === document.location</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//true</span><br></pre></td></tr></table></figure>



<h4 id="1-2-window-screen"><a href="#1-2-window-screen" class="headerlink" title="1.2 window.screen"></a>1.2 window.screen</h4></li>
</ul>
<hr>
<ul>
<li>&#96;&#96;&#96;<br>window.screen<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  包含有关用户屏幕的信息。它包括：</span><br><span class="line"></span><br><span class="line">  - `window.screen.width`</span><br><span class="line">  - `window.screen.height`</span><br><span class="line">  - `window.screen.availHeight`</span><br><span class="line">  - `window.screen.availWidth`</span><br><span class="line">  - `window.screenTop`</span><br><span class="line">  - `window.screenLeft`</span><br><span class="line"></span><br><span class="line">![window.screen](http://upload-images.jianshu.io/upload_images/1480597-d7979b36ca991d9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">**1.3 与window相关的宽高**</span><br><span class="line"></span><br><span class="line">- `window.innerWidth` 内部的宽度</span><br><span class="line">- `window.innerHeight` 内部的高度</span><br><span class="line">- `window.outWidth` 外部的宽度</span><br><span class="line">- `window.outHeight` 外部的高度</span><br><span class="line"></span><br><span class="line">![与window相关的宽高](http://upload-images.jianshu.io/upload_images/1480597-7c90cc88a3355d8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">### 二、与document相关的宽高属性</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">#### 2.1与client相关的宽高</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- `document.body.clientWidth` 元素宽度（可视内容区+内边距）</span><br><span class="line">- `document.body.clientHeight`元素高度（可视内容区+内边距）</span><br><span class="line"></span><br><span class="line">该属性指的是元素的可视部分宽度和高度，即`padding+content`</span><br><span class="line">如果没有滚动条，即为元素设定的宽度和高度</span><br><span class="line">如果出现滚动条，滚动条会遮盖元素的宽高，那么该属性就是其本来宽高减去滚动条的宽高</span><br><span class="line"></span><br><span class="line">example1：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
body{<br>  border: 20px solid #000;<br>  margin: 10px;<br>  padding: 40px;<br>  background: #eee;<br>  height: 350px;<br>  width: 500px;<br>  overflow: scroll;<br>}<br>console.log(document.body.clientWidth);  &#x2F;&#x2F; 350+padding(80) &#x3D; 430<br>console.log(document.body.clientHeight);  &#x2F;&#x2F; 500 + padding(80) &#x3D; 580<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">example2: 在div中添加文字， 指导出现滚动条</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>#exp2 {<br>    width:200px;<br>    height:200px;<br>    background:red;<br>    border:1px solid #000;<br>    overflow:auto;<br>}</p>
<p>var test &#x3D; document.getElementById(“exp2”);</p>
<p>console,log(test.clientHeight); &#x2F;&#x2F; 200<br>console.log(test.clientWidth); &#x2F;&#x2F;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/10/322.png)</span><br><span class="line"></span><br><span class="line">- **小结clientWidth和clientHeight**</span><br><span class="line">  - 无`padding`无滚动 ： `clientWidth` = 盒子的`width`</span><br><span class="line">  - 有`padding`无滚动 ： `clientWidth` = 盒子的`width` + 盒子的`padding * 2`</span><br><span class="line">  - 有`padding`有滚动 ： `clientWidth` = 盒子和`width` + 盒子的`padding * 2`- 滚动轴宽度</span><br><span class="line"></span><br><span class="line">- `document.body.clientLeft`</span><br><span class="line">- `document.body.clientTop`</span><br><span class="line"></span><br><span class="line">这两个返回的是元素周围边框的厚度，如果不指定一个边框或者不定位该元素，它的值就是0</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>body{<br>    border: 20px solid #000;<br>    margin: 10px;<br>    padding: 40px;<br>    background: #eee;<br>    height: 350px;<br>    width: 500px;<br>    overflow: scroll;<br>}<br>console.log(document.body.clientLeft);  &#x2F;&#x2F; 20<br>console.log(document.body.clientTop);  &#x2F;&#x2F; 20</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**小结clientLeft和clientTop**</span><br><span class="line"></span><br><span class="line">- 这一对属性是用来读取元素的</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  border<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  的宽度和高度的</span><br><span class="line"></span><br><span class="line">  - `clientTop = border-top`</span><br><span class="line">  - `clientLeft = border-left`</span><br><span class="line"></span><br><span class="line">#### 2.2 与offset相关的宽高</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- **document.body.offsetWidth（元素的border+padding+content的宽度）**</span><br><span class="line">- **document.body.offsetHeight（元素的border+padding+content的高度）**</span><br><span class="line"></span><br><span class="line">该属性和其内部的内容是否超出元素大小无关，只和本来设定的border以及width和height有关</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>body{<br>    border: 20px solid #000;<br>    margin: 10px;<br>    padding: 40px;<br>    background: #eee;<br>    height: 350px;<br>    width: 500px;<br>    overflow: scroll;<br>}<br>console.log(document.body.offsetWidth);  &#x2F;&#x2F; 470 &#x3D; padding<em>2 + 350 + border</em>2<br>console.log(document.body.offsetHeight);  &#x2F;&#x2F; 620 &#x3D; padding<em>2 + 500 + border</em>2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**小结offsetWidth和offsetHeight**</span><br><span class="line"></span><br><span class="line">- 无padding</span><br><span class="line"></span><br><span class="line">  无滚动无border</span><br><span class="line">  </span><br><span class="line">  - offsetWidth = clientWidth = 盒子的宽度</span><br><span class="line"></span><br><span class="line">- 有padding</span><br><span class="line"></span><br><span class="line">  无滚动有border</span><br><span class="line">  </span><br><span class="line">  - offsetWidth = 盒子的宽度 + 盒子padding*2 + 盒子边框*2 = clientWidth + 边框宽度*2</span><br><span class="line"></span><br><span class="line">- 有padding</span><br><span class="line"></span><br><span class="line">  有滚动，且滚动是显示的，有border</span><br><span class="line">  </span><br><span class="line">  - offsetWidth = 盒子宽度 + 盒子padding*2 + 盒子边框*2 = clientWidth + 滚动轴宽度 + 边框宽度*2</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- **document.offsetLeft**</span><br><span class="line">- **document.offsetTop**</span><br><span class="line"></span><br><span class="line">了解这两个属性我们必须先了解它，什么是`offsetParent`</span><br><span class="line"></span><br><span class="line">- 如果当前元素的父级元素没有进行`CSS`定位（`position`为`absolute`或`relative`）,`offsetParent`为`body.`</span><br><span class="line">- 假如当前元素的父级元素中有`CSS`定位，`offsetParent`取最近的那个父级元素</span><br><span class="line"></span><br><span class="line">**offsetLeft的兼容性问题：**</span><br><span class="line"></span><br><span class="line">- 在`IE6/7`中</span><br><span class="line">  - `offsetLeft` = offsetParent的padding-left + 当前元素的margin-left</span><br><span class="line">- 在`IE8/9/10`以及`chrome`中</span><br><span class="line">  - `offsetLeft` = offsetParent的margin-left + offsetParent的border宽度 + offsetParent的padding-left + 当前元素的margin-left</span><br><span class="line">- 在`FireFox`中</span><br><span class="line">  - `offsetLeft` = offsetParent的margin-left + 当前元素的margin-left + offsetParent的padding-left</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>body{<br>    border: 20px solid #000;<br>    margin: 10px;<br>    padding: 40px;<br>    background: #eee;<br>    height: 350px;<br>    width: 500px;<br>    overflow: scroll;<br>} </p>
<p>#exp {<br>   width:400px;<br>   height:200px;<br>   padding:20px;<br>   margin:10px;<br>   background:red;<br>   border:20px solid #000;<br>   overflow:auto;<br>}<br>var div &#x3D; document.getElementById(“exp”);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在IE8/9/10以及chrome中：</span><br><span class="line">  - div.offsetLeft = 本身的margin10 + 父级元素的padding40 + margin10 + border20 = 80</span><br><span class="line">  - div.offsetTop = 本身的margin10 + 父级元素的padding40 + margin10 + border20 = 80</span><br><span class="line">- 在FireFox：（相比chrome中少了border）</span><br><span class="line">  - div.offsetLeft = 本身的margin10 + 父级元素的padding40 + margin10 = 60</span><br><span class="line">  - div.offsetTop = 本身的margin10 + 父级元素的padding40 + margin10 = 60</span><br><span class="line">- 在IE6/7中：（相比在FireFox，不但少了border还少了父级元素的margin）</span><br><span class="line">  - `div.offsetLeft` = 本身的`margin10` + 父级元素的`padding40` = 50</span><br><span class="line">  - `div.offsetTop` = 本身的`margin10` + 父级元素的`padding40` = 50</span><br><span class="line"></span><br><span class="line">#### 2.3与scroll相关的宽高 (实际项目中用的最多)</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- **document.body.scrollWidth**</span><br><span class="line">- **document.body.scrollHeight**</span><br><span class="line"></span><br><span class="line">document.body的scrollWidth和scrollHeight与div的scrollWidth和scrollHeight是有区别的</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>body{<br>    border: 20px solid #000;<br>    margin: 10px;<br>    padding: 40px;<br>    background: #eee;<br>    height: 350px;<br>    width: 500px;<br>    overflow: scroll;<br>}</p>
<p>document.body.scrollHeight; &#x2F;&#x2F;<br>document.body.scrollWidth; &#x2F;&#x2F;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 当给定宽高小于浏览器窗口的宽高</span><br><span class="line">  - scrollWidth = 通常是浏览器窗口的宽度</span><br><span class="line">  - scrollHeight = 通常是浏览器窗口的高度</span><br><span class="line">- 当给定宽高大于浏览器窗口的宽高，且内容小于给定宽高的时候</span><br><span class="line">  - scrollWidth = 给定宽度 + 其所有的padding + margin + border</span><br><span class="line">  - scrollHeight = 给定高度 + 其所有的padding + margin + border</span><br><span class="line">- 当给定宽高大于浏览器窗口宽高，且内容大于给定宽高</span><br><span class="line">  - scrollWidth = 内容宽度 + 其所有的padding + margin + border</span><br><span class="line">  - scrollHeight = 内容高度 + 其所有的padding + margin + border</span><br><span class="line"></span><br><span class="line">**在某div中的scrollWidth和scrollHeight**</span><br><span class="line"></span><br><span class="line">- 无滚动轴时：</span><br><span class="line">  - scrollWidth = clientWidth = 盒子宽度 + 盒子padding*2</span><br><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/10/323.png)</span><br><span class="line"></span><br><span class="line">- 有滚动轴时：</span><br><span class="line">  - scrollWidth = 实际内容的宽度 + padding*2</span><br><span class="line">  - scrollHeight = 实际内容的高度 + padding*2</span><br><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/10/324.png)</span><br><span class="line"></span><br><span class="line">- **document.body.scrollLeft**</span><br><span class="line">- **document.body.scrollTop**</span><br><span class="line"></span><br><span class="line">与前面不同的是，这对属性是可读写的，指的是当元素其中的超出其宽高的时候，元素被卷起来的高度和宽度</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#exp {<br>   width:400px;<br>   height:200px;<br>   padding:20px;<br>   margin:10px;<br>   background:red;<br>   border:20px solid #000;<br>   overflow-y:scroll;<br>}</p>
<p>var mydiv &#x3D; document.getElementById(“exp”);</p>
<p>mydiv.scrollTop ;  &#x2F;&#x2F;默认情况下是0<br>mydiv.scrollLeft ; &#x2F;&#x2F;默认情况下是0 </p>
<p>&#x2F;&#x2F;可以改写它</p>
<p>mydiv.scrollTop &#x3D; 20;<br>console.log(mydiv.scrollTop)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/10/325.png)</span><br><span class="line"></span><br><span class="line">**obj.style.width和obj.style.height**</span><br><span class="line"></span><br><span class="line">对于一个`DOM`元素，它的`style`属性返回的是一个对象，这个对象的任意一个属性是可读写的，`style.width`等于`css`属性中的宽度。`style.height`等于`css`属性中的高度</span><br><span class="line"></span><br><span class="line">#### 2.4 documentElement和body的关系</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">是父子级的关系</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>body{<br>    border: 20px solid #000;<br>    margin: 10px;<br>    padding: 40px;<br>    background: #eee;<br>    height: 350px;<br>    width: 500px;<br>    overflow: scroll;<br>}</p>
<p>#exp {<br>   width:400px;<br>   height:200px;<br>   padding:20px;<br>   margin:10px;<br>   background:red;<br>   border:20px solid #000;<br>   overflow-y:scroll;<br>}</p>
<p>console.log(document); &#x2F;&#x2F;document<br>console.log(document.documentElement); &#x2F;&#x2F;html<br>console.log(document.body); &#x2F;&#x2F;body</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/10/326.png)</span><br><span class="line"></span><br><span class="line">- 兼容问题推荐使用 获取浏览器窗口可视区域大小</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>document.body.clientWidth || document.documentElement.clientWidth;<br>document.body.clientHeight || document.documentElement.clientHeight;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 三、Event对象的5种坐标</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/10/327.png)</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div id="example" 
style="width: 200px;height: 200px;background: red;margin: 100px auto;"></div>
var example = document.getElementById("example");
example.onclick = function(e){
    console.log("clientX "+e.clientX + " : " + " clientY "+e.clientY);
    console.log("screenX "+e.screenX + " : " + " screenY "+e.screenY);
    console.log("offsetX "+e.offsetX + " : " + " offsetY "+e.offsetY);
    console.log("pageX "+e.pageX + " : " + " pageY "+e.pageY);
    console.log("x "+e.x + " : " + " y "+e.y);
}
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/10/328.png)</span><br><span class="line"></span><br><span class="line">### 四、 js各种宽高的应用</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- **example1：可视区域加载**</span><br><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/10/329.png)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div id="example1" ></div>
#example1 {
            width: 500px;
            height: 350px;
            background: red;
            margin: 1000px auto 0 auto;
        }
        @-webkit-keyframes fadeInLeft{
            0%{
                opacity: 0;
                transform: translate3d(-100%,0,0);
            }
            100%{
                opacity: 1;
                transform: none;
                
<pre><code>        &#125;
    &#125;
        .fadeInLeft &#123;
            animation-name: fadeInLeft;
            animation-duration: 2s;
        &#125;
</code></pre>
<p>function showDiv(){<br>            var example &#x3D; document.getElementById(“example”);<br>            var clients &#x3D; window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;&#x2F;&#x2F;可视区域的高度<br>            var divTop &#x3D; example.getBoundingClientRect().top;<br>            if(divTop &lt;&#x3D; clients){<br>                example.classList.add(“fadeInLeft”);<br>                              &#x2F;&#x2F;  这里可以通过setAttribute设置图片的src按需加载<br>            }<br>            document.title &#x3D; clients+”—“+divTop;<br>        }</p>
<p>window.onscroll &#x3D; showDiv;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[在线演示](http://codepen.io/poetries/pen/RoeJgG)</span><br><span class="line"></span><br><span class="line">- **example2：网页滚动到顶部或者底部**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div id="example2" ></div>
#example2 {
            width: 500px;
            height: 350px;
            background: red;
            margin: 1000px auto 0 auto;
}
function scrollTopOrBottom(){
            var example2 = document.getElementById("example");
            var clients = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;//可视区域的高度，兼容性写法
            var scrollTop = document.body.scrollTop;
            var wholeHeight = document.body.scrollHeight;
            if(clients + scrollTop >= wholeHeight){
                alert("我已经到了底部!");
                              // 这里可以调用Ajax分页加载到页面中，实现多页加载功能
            }else if(scrollTop == 0){
                alert("我已经到了顶部了!");
                      
<pre><code>        &#125;
        document.title = (clients + scrollTop)+&quot;---&quot;+wholeHeight+&quot;--&quot;+scrollTop;
    &#125;
    
</code></pre>
<p>window.onscroll &#x3D; scrollTopOrBottom;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[在线演示](http://codepen.io/poetries/pen/WoayJy)</span><br><span class="line"></span><br><span class="line">- **example3：DIV滚动到底部加载**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div id="example3" >
            DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载
            DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载
            DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载
            DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载
            DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载
            DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载
</div>
#example3 {
            width: 500px;
            height: 400px;
            background: red;
            margin: 10px auto;
            padding: 10px;
            overflow-y: scroll;
}
var div = document.getElementById("example3");
        function divScroll(){
            
<pre><code>        var wholeHeight = div.scrollHeight;//滚动区域高度
        var divScrollTop = div.scrollTop;//卷上去的那部分高度
        var divHeight = div.clientHeight; //div的可视区域的高度
        
        
        if(divScrollTop + divHeight &gt;= wholeHeight)&#123;
            alert(&quot;我已经到了底部!&quot;);
           // 这里可以在div中通过滚动加载分页按需显示
        &#125;else if(divScrollTop == 0)&#123;
            alert(&quot;我已经到了顶部了!&quot;);
        &#125;
        document.title = (divScrollTop + divHeight)+&quot;---&quot;+wholeHeight+&quot;--&quot;+divScrollTop;
</code></pre>
<p>}</p>
<p>div.onscroll &#x3D; divScroll;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[在线演示](http://codepen.io/poetries/pen/vyVrvm)</span><br><span class="line"></span><br><span class="line">- **example4：计算滚动轴的宽度**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;获取滚动轴的宽度<br>    function getScrollBar(){<br>        var el &#x3D; document.createElement(“p”);<br>        var styles &#x3D; {<br>            width:”100px”,<br>            height:”100px”,<br>            overflowY:”scroll”<br>        };<br>        for (var prop in styles){<br>            el.style[prop] &#x3D; styles[prop];&#x2F;&#x2F;把 styles上的属性全部遍历拷贝到el.style上</p>
<pre><code>    &#125;
    document.body.appendChild(el);
    var scrollBarWidth = el.offsetWidth - el.clientWidth;
    el.remove();
    return scrollBarWidth;
&#125;
alert(getScrollBar());//17
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[在线演示](http://codepen.io/poetries/pen/RoeBbL)</span><br><span class="line"></span><br><span class="line">### 五、js中的宽高属性总结</span><br><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/10/330.png)</span><br><span class="line"></span><br><span class="line">![img](https://camo.githubusercontent.com/3318530334bbc8f5e7ce267866c43ba72fa01f32/687474703a2f2f6f61376436647871742e626b742e636c6f7564646e2e636f6d2f626c6f672f696d616765732f3038313734323039323736363338392e6a7067)</span><br><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/10/331.png)</span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/10/332.png)</span><br><span class="line"></span><br><span class="line">## 第二部分 jQuery中的宽高属性</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### 一、jquery相关宽高介绍</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">- 1.1 width()</span><br><span class="line">  - 特殊元素`window.document`只可以读，普通元素可以读写，`width()`返回结果无单位，`css(&quot;width&quot;)`的结果有单位</span><br><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/10/333.png)</span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/10/334.png)</span><br><span class="line"></span><br><span class="line">- 1.2 innerWidth()</span><br><span class="line">  - 包含padding（不推荐window,document调用）</span><br><span class="line">- **1.3 innerHeight()**</span><br><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/10/335.png)</span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/10/336.png)</span><br><span class="line"></span><br><span class="line">- 1.4 outerWidth()</span><br><span class="line">  - 包含padding和border，当传true时包含marging，不传时不包含marging（不推荐window,document调用）</span><br><span class="line">- **1.5 outerHeight()**</span><br><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/10/337.png)</span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/10/338.png)</span><br><span class="line"></span><br><span class="line">- 1.6 scrollLeft():</span><br><span class="line">  - 相对于水平滚动条左边的距离，如果滚动条非常左、或者元素不能被滚动，这个值为0；</span><br><span class="line">- **1.7 scrollTop():**</span><br><span class="line">  - 相对于垂直滚动条上边的距离，如果滚动条非常上、或者元素不能被滚动，这个值为0；</span><br><span class="line">- **1.8 .offset():**</span><br><span class="line">  - 相对于document的当前坐标值(相对于body左上角的left,top的值)；</span><br><span class="line">- 1.9 .position():</span><br><span class="line">  - 相对于offset parent的当前坐标值(相对于offset parent元素的左上角的left、top的值)</span><br><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/10/339.png)</span><br><span class="line"></span><br><span class="line">### 二、jquery相关宽高举例</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">**2.1 exmaple1**</span><br><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/10/340.png)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="parentDiv">
    <div class="childrenDiv"></div>
</div>
html,body {
    margin:10px;
    border:5px solid red;
    padding:20px;
}
.parentDiv {
    width:800px;
    height:500px;
    margin:5px auto;
    background:#FF6600;
    border:5px dashed green;padding:30px;position:relative;

<p>}<br>.childrenDiv {<br>    width:300px;<br>    height:500px;<br>    margin:5px auto;<br>    background:yellow;<br>    border:5px solid black;<br>    padding:5px;<br>    box-sizing:border-box;&#x2F;<em>包括padding和border的值</em>&#x2F;<br>}<br>&#x2F;&#x2F;特殊元素的高度<br>&#x2F;&#x2F;window  document<br>console.log(“$(window).height()”+$(window).height());<br>console.log(“$(document).height()”+$(document).height());</p>
<p>&#x2F;&#x2F;innerHeight<br>console.log(“$(window).innerHeight()”+$(window).innerHeight());<br>console.log(“$(document).innerHeight()”+$(document).innerHeight());</p>
<p>&#x2F;&#x2F;普通child元素的高度</p>
<p>&#x2F;&#x2F;480 &#x3D; 500 - border<em>2 - padding</em>2 (因为设置了box-sizing，box-sizing把border和padding的值计算了进去)<br>console.log(‘$(“.childrenDiv”).height()’+ $(“.childrenDiv”).height());</p>
<p>&#x2F;&#x2F;490 &#x3D; 500 - border<em>2 - padding</em>2（innerHeight不包括padding）<br>console.log(‘$(“.childrenDiv”).innerHeight()’+ $(“.childrenDiv”).innerHeight());</p>
<p>&#x2F;&#x2F;500 &#x3D; 500  不包括margin<br>console.log(‘$(“.childrenDiv”).outerHeight()’+ $(“.childrenDiv”).outerHeight());</p>
<p>&#x2F;&#x2F;510 &#x3D; 500 + margin true包括margin<br>console.log(‘$(“.childrenDiv”).outerHeight()’+ $(“.childrenDiv”).outerHeight(true));</p>
<p>&#x2F;&#x2F;scrollTop</p>
<p>$(window).scroll(function(){<br>    document.title &#x3D; “scrollTop  “+$(this).scrollTop();<br>});</p>
<p>&#x2F;&#x2F; jquery宽高演示之offset和position</p>
<p>console.log(‘$(“.childrenDiv”).offset().top ‘+$(“.childrenDiv”).offset().top);<br>console.log(‘$(“.childrenDiv”).offset().left ‘+$(“.childrenDiv”).offset().left);<br>console.log(‘$(“.childrenDiv”).position().top ‘+$(“.childrenDiv”).position().top);<br>console.log(‘$(“.childrenDiv”).position().top ‘+$(“.childrenDiv”).position().left);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/10/341.png)</span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/10/342.png)</span><br><span class="line"></span><br><span class="line">[在线演示](http://codepen.io/poetries/pen/yVRqZO)</span><br><span class="line"></span><br><span class="line">### 三、jquery各种宽高应用</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">**3.1 jquery可视区域加载**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div id="example" ></div>
#example {
            width: 500px;
            height: 350px;
            background: red;
            margin: 1000px auto 0 auto;
        }
        @-webkit-keyframes fadeInLeft{
            0%{
                opacity: 0;
                transform: translate3d(-100%,0,0);
            }
            100%{
                opacity: 1;
                transform: none;
                
<pre><code>        &#125;
    &#125;
        .fadeInLeft &#123;
            animation-name: fadeInLeft;
            animation-duration: 2s;
        &#125;
</code></pre>
<p>$(window).scroll(function(){<br>    var ks_area &#x3D; $(window).height();&#x2F;&#x2F;可视区域高度<br>    var scrollHeight &#x3D; $(window).scrollTop();&#x2F;&#x2F;被卷上去的那部分<br>    var divTop &#x3D; $(“#example”).offset().top;&#x2F;&#x2F;盒子距离浏览器顶部的距离</p>
<pre><code>if(ks_area + scrollHeight &gt;= divTop)&#123;
    $(&quot;#example&quot;).addClass(&quot;fadeInLeft&quot;);
&#125;
document.title = ks_area+&#39;-&#39;+scrollHeight+&#39;-&#39;+divTop;
</code></pre>
<p>});</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[在线演示](http://codepen.io/poetries/pen/MbPqVE)</span><br><span class="line"></span><br><span class="line">**3.2 jquery滚动到底部和顶部加载**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div id="example" ></div>
<script src="http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js"></script>
#example {
            width: 500px;
            height: 350px;
            background: red;
            margin: 1000px auto 0 auto;
}
$(window).scroll(function(){
    var ks_area = $(window).height();
    var scrollTop = $(window).scrollTop();
    var wholeHeight = $(document).height();
    
<pre><code>if(ks_area + scrollTop &gt;=wholeHeight )&#123;
    alert(&quot;已经到底部了&quot;);
&#125;else if(scrollTop == 0)&#123;
    alert(&quot;已经到头部了&quot;);
&#125;
</code></pre>
<p>})<br>&#96;&#96;&#96;</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/javascript/">javascript</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-html+css+js+ts/3-js-继承" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/22/html+css+js+ts/3-js-%E7%BB%A7%E6%89%BF/" class="article-date">
  	<time datetime="2018-01-22T12:16:15.000Z" itemprop="datePublished">2018-01-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/22/html+css+js+ts/3-js-%E7%BB%A7%E6%89%BF/">
        js 继承
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>JavaScript继承本质和原型链有关</p>
</blockquote>
<ul>
<li>原型、实例、构造函数、原型链之间的关系</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/321.png" alt="img"></p>
<h2 id="一、借助构造函数实现继承"><a href="#一、借助构造函数实现继承" class="headerlink" title="一、借助构造函数实现继承"></a>一、借助构造函数实现继承</h2><ul>
<li>缺点：实例无法访问父类原型上的属性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Parent1 () &#123;</span><br><span class="line">    this.name = &#x27;parent1&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">Parent1.prototype.say = function () &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">function Child1 () &#123;</span><br><span class="line">    Parent1.call(this);</span><br><span class="line">    this.type = &#x27;child1&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">// Parent1原型上的say没法拿到</span><br><span class="line">console.log(new Child1(), new Child1().say());</span><br></pre></td></tr></table></figure>

<h2 id="二、借助原型链实现继承"><a href="#二、借助原型链实现继承" class="headerlink" title="二、借助原型链实现继承"></a>二、借助原型链实现继承</h2><ul>
<li>缺点：子类和父类公用一个原型,最后导致子类的多个实例都是一样的，无法隔离</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Parent2 () &#123;</span><br><span class="line">    this.name = &#x27;parent2&#x27;;</span><br><span class="line">    this.play = [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line">function Child2 () &#123;</span><br><span class="line">    this.type = &#x27;child2&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">Child2.prototype = new Parent2();</span><br><span class="line"></span><br><span class="line">var s1 = new Child2();</span><br><span class="line">var s2 = new Child2();</span><br><span class="line">s1.play.push(4);</span><br><span class="line">console.log(s1.play, s2.play); // [1, 2, 3, 4] [1, 2, 3,4] 结果是一样的，说明两个实例无法隔离</span><br></pre></td></tr></table></figure>

<h2 id="三、组合继承方式"><a href="#三、组合继承方式" class="headerlink" title="三、组合继承方式"></a>三、组合继承方式</h2><ul>
<li>此方法解决了上面的实例相同的问题，但是父类的构造函数执行了多次</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Parent3 () &#123;</span><br><span class="line">    this.name = &#x27;parent3&#x27;;</span><br><span class="line">    this.play = [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line">function Child3 () &#123;</span><br><span class="line">    Parent3.call(this);</span><br><span class="line">    this.type = &#x27;child3&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">Child3.prototype = new Parent3(); // 把Parent3的实例指向Child3的原型</span><br><span class="line">var s3 = new Child3();</span><br><span class="line">var s4 = new Child3();</span><br><span class="line">s3.play.push(4);</span><br><span class="line">console.log(s3.play, s4.play); // [1, 2, 3, 4] [1, 2, 3]</span><br></pre></td></tr></table></figure>

<ul>
<li>优化组合继承1：此方法解决了父类的构造函数执行了多次问题，但是无法判断实例是由子类创建的，还是父类创建的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function Parent4 () &#123;</span><br><span class="line">    this.name = &#x27;parent4&#x27;;</span><br><span class="line">    this.play = [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line">function Child4 () &#123;</span><br><span class="line">    Parent4.call(this);</span><br><span class="line">    this.type = &#x27;child4&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">Child4.prototype = Parent4.prototype; // Child4和Parent4公用一个原型了</span><br><span class="line">var s5 = new Child4();</span><br><span class="line">var s6 = new Child4();</span><br><span class="line">console.log(s5, s6);</span><br><span class="line"></span><br><span class="line">console.log(s5 instanceof Child4, s5 instanceof Parent4); // 都是返回true</span><br><span class="line">console.log(s5.constructor); // 这里返回的构造函数是Parent4，而不是Child4，问题所在</span><br><span class="line">​``` </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 优化组合继承2：完美解决方案</span><br><span class="line"></span><br><span class="line">​```javascript</span><br><span class="line">function Parent5 () &#123;</span><br><span class="line">    this.name = &#x27;parent5&#x27;;</span><br><span class="line">    this.play = [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line">function Child5 () &#123;</span><br><span class="line">    Parent5.call(this);</span><br><span class="line">    this.type = &#x27;child5&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">Child5.prototype = Object.create(Parent5.prototype);</span><br><span class="line">Child5.prototype.constructor = Child5;	 //重新修改了Child5的构造函数为Child5</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-html+css+js+ts/3-js-复制粘贴" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/19/html+css+js+ts/3-js-%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4/" class="article-date">
  	<time datetime="2018-01-19T00:58:16.000Z" itemprop="datePublished">2018-01-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/19/html+css+js+ts/3-js-%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4/">
        js-复制粘贴
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、基本使用"><a href="#一、基本使用" class="headerlink" title="一、基本使用"></a>一、基本使用</h2><h3 id="1-1-API-介绍"><a href="#1-1-API-介绍" class="headerlink" title="1.1 API 介绍"></a>1.1 API 介绍</h3><p><strong>复制、剪切、粘贴事件</strong></p>
<ul>
<li><code>copy</code> 发生复制操作时触发;</li>
<li><code>cut</code> 发生剪切操作时触发;</li>
<li><code>paste</code> 发生粘贴操作时触发</li>
</ul>
<blockquote>
<p>每个事件都有一个 <code>before</code> 事件对应：<code>beforecopy</code>、<code>beforecut</code>、<code>beforepaste</code>。这几个 <code>before</code>一般不怎么用，所以我们把注意力放在另外三个事件就可以了</p>
</blockquote>
<p><strong>触发条件</strong></p>
<ul>
<li>鼠标右键菜单的<code>复制</code>、<code>粘贴</code>、<code>剪切</code></li>
<li>使用了相应的键盘组合键，比如:<code>command+c</code>、<code>command+v</code></li>
</ul>
<p><strong>使用姿势</strong></p>
<blockquote>
<p>以 <code>copy</code> 为例</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">document.body.oncopy = e =&gt; &#123;</span><br><span class="line">  // 监听全局复制 做点什么</span><br><span class="line">&#125;;</span><br><span class="line">// 还有这种写法：</span><br><span class="line">document.addEventListener(&#x27;copy&#x27;, e =&gt; &#123;</span><br><span class="line">  // 监听全局复制 做点什么</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面是在<code>document.body</code>上全局监听的，然而很多人不知道的是，我们还可以为某些 <code>dom</code> 单独添加剪切板事件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// html结构</span><br><span class="line">&lt;div id=&quot;test1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;test2&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 写法一样：</span><br><span class="line">    let test1 = document.querySelector(&#x27;#test1&#x27;);</span><br><span class="line">    test1.oncopy = e =&gt; &#123;</span><br><span class="line">        // 监听test1发生的复制事件 做点什么</span><br><span class="line">        // test1发生的复制事件会触发回调，其他地方不会触发回调</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其他事件也是一样的</p>
</blockquote>
<h3 id="1-2-clipboardData"><a href="#1-2-clipboardData" class="headerlink" title="1.2 clipboardData"></a>1.2 clipboardData</h3><p><strong>clipboardData 对象:用于访问以及修改剪贴板中的数据</strong></p>
<blockquote>
<p>不同浏览器，所属的对象不同：在 <code>IE</code> 中这个对象是<code>window</code>对象的属性，在<code>Chrome</code>、<code>Safari</code>和<code>Firefox</code>中，这个对象是相应的<code>event</code>对象的属性。所以我们在使用的时候，需要做一下如下兼容</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.body.oncopy = e =&gt; &#123;</span><br><span class="line">  let clipboardData = e.clipboardData || window.clipboardData;</span><br><span class="line">  // 获取clipboardData对象 + do something</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>对象方法</strong></p>
<blockquote>
<p>对象有三个方法: <code>getData()</code>、<code>setData()</code>、<code>clearData()</code></p>
</blockquote>
<p><strong>getData() 访问剪切板中的数据</strong></p>
<blockquote>
<p><code>getData()</code>接受一个<code>text</code>参数，即要取得的数据的格式</p>
</blockquote>
<p><strong>在复制、剪切、粘贴触发的事件的数据</strong></p>
<blockquote>
<p>实际上在 <code>chorme</code> 上测试只有<code>paste</code>粘贴的时候才能用<code>getData()</code>访问到数据，用法如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 要粘贴的数据：</span><br><span class="line"></span><br><span class="line">document.body.onpaste = e =&gt; &#123;</span><br><span class="line">  let clipboardData = e.clipboardData || window.clipboardData; // 兼容处理</span><br><span class="line">  console.log(&#x27;要粘贴的数据&#x27;, clipboardData.getData(&#x27;text&#x27;));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>被复制&#x2F;剪切的数据</strong>：</p>
<blockquote>
<p>在复制和剪切中的数据，需要通过<code>window.getSelection(0).toString()</code>来访问:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.body.oncopy = e =&gt; &#123;</span><br><span class="line">  console.log(&#x27;被复制的数据:&#x27;, window.getSelection(0).toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>setData(): 修改剪切板中的数据</strong></p>
<blockquote>
<p>第一个参数也是<code>text</code>，第二个参数是要放在剪切板中的文本</p>
</blockquote>
<p><strong>clearData()</strong></p>
<h2 id="二、应用"><a href="#二、应用" class="headerlink" title="二、应用"></a>二、应用</h2><h3 id="2-1-复制大段文本"><a href="#2-1-复制大段文本" class="headerlink" title="2.1 复制大段文本"></a>2.1 复制大段文本</h3><p><strong>实现类知乎&#x2F;掘金复制大段文本添加版权信息</strong></p>
<blockquote>
<p>实现很简单：取消默认复制之后，主要是在被复制的内容后面添加信息，然后根据 <code>clipboardData</code> 的 <code>setData()</code>方法将信息写入剪贴板</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 掘金这里不是全局监听，应该只是监听文章的dom范围内。</span><br><span class="line">document.body.oncopy = event =&gt; &#123;</span><br><span class="line">  event.preventDefault(); // 取消默认的复制事件</span><br><span class="line">  let textFont,</span><br><span class="line">    copyFont = window.getSelection(0).toString(); // 被复制的文字 等下插入</span><br><span class="line">  // 防知乎掘金 复制一两个字则不添加版权信息 超过一定长度的文字 就添加版权信息</span><br><span class="line">  if (copyFont.length &gt; 10) &#123;</span><br><span class="line">    textFont =</span><br><span class="line">      copyFont +</span><br><span class="line">      &#x27;\n&#x27; +</span><br><span class="line">      &#x27;作者：OBKoro1\n&#x27; +</span><br><span class="line">      &#x27;链接：https://juejin.im/user/58714f0e325b123db4a2eb95372/posts\n&#x27; +</span><br><span class="line">      &#x27;来源：掘金\n&#x27; +</span><br><span class="line">      &#x27;著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&#x27;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    textFont = copyFont; // 没超过十个字 则采用被复制的内容。</span><br><span class="line">  &#125;</span><br><span class="line">  if (event.clipboardData) &#123;</span><br><span class="line">    return event.clipboardData.setData(&#x27;text&#x27;, textFont); // 将信息写入粘贴板</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 兼容IE</span><br><span class="line">    return window.clipboardData.setData(&#x27;text&#x27;, textFont);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>然后 <code>command+c</code>、<code>command+v</code>，输出:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">你复制的内容</span><br><span class="line">作者：OBKoro1</span><br><span class="line">链接：https://juejin.im/user/58714f0eb123db4a2eb95372/posts</span><br><span class="line">来源：掘金</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h3 id="2-2-防复制功能"><a href="#2-2-防复制功能" class="headerlink" title="2.2 防复制功能"></a>2.2 防复制功能</h3><ul>
<li>禁止复制+剪切</li>
<li>禁止右键，右键某些选项:全选，复制，粘贴等。</li>
<li>禁用文字选择，能选择却不能复制，体验很差。</li>
<li><code>user-select</code> 用 <code>css</code> 禁止选择文本</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 禁止右键菜单</span><br><span class="line">document.body.oncontextmenu = e =&gt; &#123;</span><br><span class="line">    console.log(e, &#x27;右键&#x27;);</span><br><span class="line">    return false;</span><br><span class="line">    // e.preventDefault();</span><br><span class="line">&#125;;</span><br><span class="line">// 禁止文字选择。</span><br><span class="line">document.body.onselectstart = e =&gt; &#123;</span><br><span class="line">    console.log(e, &#x27;文字选择&#x27;);</span><br><span class="line">    return false;</span><br><span class="line">    // e.preventDefault();</span><br><span class="line">&#125;;</span><br><span class="line">// 禁止复制</span><br><span class="line">document.body.oncopy = e =&gt; &#123;</span><br><span class="line">    console.log(e, &#x27;copy&#x27;);</span><br><span class="line">    return false;</span><br><span class="line">    // e.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line">// 禁止剪切</span><br><span class="line">document.body.oncut = e =&gt; &#123;</span><br><span class="line">    console.log(e, &#x27;cut&#x27;);</span><br><span class="line">    return false;</span><br><span class="line">    // e.preventDefault();</span><br><span class="line">&#125;;</span><br><span class="line">// 禁止粘贴</span><br><span class="line">document.body.onpaste = e =&gt; &#123;</span><br><span class="line">    console.log(e, &#x27;paste&#x27;);</span><br><span class="line">    return false;</span><br><span class="line">    // e.preventDefault();</span><br><span class="line">&#125;;</span><br><span class="line">/** css 禁止文本选择 这样不会触发js**/</span><br><span class="line">body &#123;</span><br><span class="line">    user-select: none;</span><br><span class="line">    -moz-user-select: none;</span><br><span class="line">    -webkit-user-select: none;</span><br><span class="line">    -ms-user-select: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>e.preventDefault()</code>也可以禁用，但建议使用<code>return false</code>这样就不用去访问<code>e</code>和<code>e</code>的方法了。</li>
<li>示例中<code>document.body</code>全局都禁用了，也可以对 <code>dom</code>(某些区域)进行禁用</li>
</ul>
<p><strong>破解防复制</strong></p>
<p>上面的防复制方法通过<code>js+css</code>实现的，所以思路就是：禁用<code>js+取消user-select</code>样式。</p>
<blockquote>
<p><code>Chrome</code>浏览器的话：打开浏览器控制台，按<code>F1</code>进入<code>Setting</code>，勾选<code>Disable</code> <code>JavaScript</code>(禁止 <code>js</code>)。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/1480597-2f3188629fa5a86d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<blockquote>
<p>此时如果还不能复制的话，就要去找<code>user-select</code>样式,取消这个样式就可以了</p>
</blockquote>
<h3 id="2-3-点击复制功能"><a href="#2-3-点击复制功能" class="headerlink" title="2.3 点击复制功能"></a>2.3 点击复制功能</h3><p><strong>不能使用 clipboardData</strong></p>
<ul>
<li>在 <code>IE</code> 中可以用<code>window.clipboardData.setData(&#39;text&#39;,&#39;内容&#39;)</code>实现</li>
<li>上文提到过，在 <code>IE</code> 中<code>clipboardData</code>是<code>window</code>的属性</li>
<li>而其他浏览器则是相应的<code>event</code>对象的属性，这实际上是一种安全措施，防止未经授权的访问,为了兼容其他浏览器，所以我们不能通过<code>clipboardData</code>来实现这种操作</li>
</ul>
<p><strong>具体做法</strong></p>
<ul>
<li>创建一个隐藏的<code>input</code>框</li>
<li>点击的时候，将要复制的内容放进<code>input</code>框中</li>
<li>选择文本内容<code>input.select()</code>。这里只能用<code>input</code>或者<code>textarea</code>才能选择文本</li>
<li><code>document.execCommand(&quot;copy&quot;)</code>，执行浏览器的复制命令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function copyText() &#123;</span><br><span class="line">  var text = document.getElementById(&#x27;text&#x27;).innerText; // 获取要复制的内容也可以传进来</span><br><span class="line">  var input = document.getElementById(&#x27;input&#x27;); // 获取隐藏input的dom</span><br><span class="line">  input.value = text; // 修改文本框的内容</span><br><span class="line">  input.select(); // 选中文本</span><br><span class="line">  document.execCommand(&#x27;copy&#x27;); // 执行浏览器复制命令</span><br><span class="line">  alert(&#x27;复制成功&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-第三方库clipboard"><a href="#2-4-第三方库clipboard" class="headerlink" title="2.4 第三方库clipboard"></a>2.4 第三方库clipboard</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/zenorocha/clipboard.js">https://github.com/zenorocha/clipboard.js</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-html+css+js+ts/3-js防抖节流原理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/17/html+css+js+ts/3-js%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E5%8E%9F%E7%90%86/" class="article-date">
  	<time datetime="2018-01-17T13:23:24.000Z" itemprop="datePublished">2018-01-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/17/html+css+js+ts/3-js%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E5%8E%9F%E7%90%86/">
        js-防抖节流原理
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、防抖debounce"><a href="#一、防抖debounce" class="headerlink" title="一、防抖debounce"></a>一、防抖debounce</h2><blockquote>
<p>你是否在日常开发中遇到一个问题，在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作</p>
</blockquote>
<ul>
<li>这些需求都可以通过函数防抖动来实现。如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作</li>
<li>防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于<code>wait</code>，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数<code>wait</code>）调用函数</li>
</ul>
<blockquote>
<p>持续触发<code>scroll</code>事件时，并不执行<code>handle</code>函数，当<code>1000</code>毫秒内没有触发<code>scroll</code>事件时，才会延时触发<code>scroll</code>事件</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/312.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 防抖</span><br><span class="line">function debounce(fn, wait) &#123;    </span><br><span class="line">    var timeout = null;    </span><br><span class="line">    return function() &#123;        </span><br><span class="line">        if(timeout !== null)   clearTimeout(timeout);        </span><br><span class="line">        timeout = setTimeout(fn, wait);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 处理函数</span><br><span class="line">function handle() &#123;    </span><br><span class="line">    console.log(Math.random()); </span><br><span class="line">&#125;</span><br><span class="line">// 滚动事件</span><br><span class="line">// 当持续触发scroll事件时，事件处理函数handle只在停止滚动1000毫秒之后才会调用一次，也就是说在持续触发scroll事件的过程中，事件处理函数handle一直没有执行</span><br><span class="line">window.addEventListener(&#x27;scroll&#x27;, debounce(handle, 1000));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们先来看一个袖珍版的防抖理解一下防抖的实现</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// func是用户传入需要防抖的函数</span><br><span class="line">// wait是等待时间</span><br><span class="line">const debounce = (func, wait = 50) =&gt; &#123;</span><br><span class="line">  // 缓存一个定时器id</span><br><span class="line">  let timer = 0</span><br><span class="line">  // 这里返回的函数是每次用户实际调用的防抖函数</span><br><span class="line">  // 如果已经设定过定时器了就清空上一次的定时器</span><br><span class="line">  // 开始一个新的定时器，延迟执行用户传入的方法</span><br><span class="line">  return function(...args) &#123;</span><br><span class="line">    if (timer) clearTimeout(timer)</span><br><span class="line">    timer = setTimeout(() =&gt; &#123;</span><br><span class="line">      func.apply(this, args)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 不难看出如果用户调用该函数的间隔小于wait的情况下，上一次的时间还未到就被清除了，并不会执行函数</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是一个简单版的防抖，但是有缺陷，这个防抖只能在最后调用。一般的防抖会有<code>immediate</code>选项，表示是否立即调用。这两者的区别，举个栗子来说</p>
</blockquote>
<ul>
<li>例如在搜索引擎搜索问题的时候，我们当然是希望用户输入完最后一个字才调用查询接口，这个时候适用延迟执行的防抖函数，它总是在一连串（间隔小于<code>wait</code>的）函数触发之后调用。</li>
<li>例如用户给<code>interviewMap</code>点<code>star</code>的时候，我们希望用户点第一下的时候就去调用接口，并且成功之后改变<code>star</code>按钮的样子，用户就可以立马得到反馈是否<code>star</code>成功了，这个情况适用立即执行的防抖函数，它总是在第一次调用，并且下一次调用必须与前一次调用的时间间隔大于<code>wait</code>才会触发</li>
</ul>
<p><strong>完整代码</strong></p>
<blockquote>
<p>下面我们来实现一个带有立即执行选项的防抖函数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 这个是用来获取当前时间戳的</span><br><span class="line">function now() &#123;</span><br><span class="line">  return +new Date()</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行</span><br><span class="line"> *</span><br><span class="line"> * @param  &#123;function&#125; func        回调函数</span><br><span class="line"> * @param  &#123;number&#125;   wait        表示时间窗口的间隔</span><br><span class="line"> * @param  &#123;boolean&#125;  immediate   设置为ture时，是否立即调用函数</span><br><span class="line"> * @return &#123;function&#125;             返回客户调用函数</span><br><span class="line"> */</span><br><span class="line">function debounce (func, wait = 50, immediate = true) &#123;</span><br><span class="line">  let timer, context, args</span><br><span class="line"></span><br><span class="line">  // 延迟执行函数</span><br><span class="line">  const later = () =&gt; setTimeout(() =&gt; &#123;</span><br><span class="line">    // 延迟函数执行完毕，清空缓存的定时器序号</span><br><span class="line">    timer = null</span><br><span class="line">    // 延迟执行的情况下，函数会在延迟函数中执行</span><br><span class="line">    // 使用到之前缓存的参数和上下文</span><br><span class="line">    if (!immediate) &#123;</span><br><span class="line">      func.apply(context, args)</span><br><span class="line">      context = args = null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, wait)</span><br><span class="line"></span><br><span class="line">  // 这里返回的函数是每次实际调用的函数</span><br><span class="line">  return function(...params) &#123;</span><br><span class="line">    // 如果没有创建延迟执行函数（later），就创建一个</span><br><span class="line">    if (!timer) &#123;</span><br><span class="line">      timer = later()</span><br><span class="line">      // 如果是立即执行，调用函数</span><br><span class="line">      // 否则缓存参数和调用上下文</span><br><span class="line">      if (immediate) &#123;</span><br><span class="line">        func.apply(this, params)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        context = this</span><br><span class="line">        args = params</span><br><span class="line">      &#125;</span><br><span class="line">    // 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个</span><br><span class="line">    // 这样做延迟函数会重新计时</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">      timer = later()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于按钮防点击来说的实现：如果函数是立即执行的，就立即调用，如果函数是延迟执行的，就缓存上下文和参数，放到延迟函数中去执行。一旦我开始一个定时器，只要我定时器还在，你每次点击我都重新计时。一旦你点累了，定时器时间到，定时器重置为 <code>null</code>，就可以再次点击了。</li>
<li>对于延时执行函数来说的实现：清除定时器ID，如果是延迟调用就调用函数<br>#</li>
</ul>
<h2 id="二、节流throttle"><a href="#二、节流throttle" class="headerlink" title="二、节流throttle"></a>二、节流throttle</h2><blockquote>
<p>防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行</p>
</blockquote>
<p>如下图，持续触发<code>scroll</code>事件时，并不立即执行<code>handle</code>函数，每隔<code>1000</code>毫秒才会执行一次<code>handle</code>函数</p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/313.png" alt="img"></p>
<p><strong>节流版本</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait</span><br><span class="line"> *</span><br><span class="line"> * @param  &#123;function&#125;   func      回调函数</span><br><span class="line"> * @param  &#123;number&#125;     wait      表示时间窗口的间隔</span><br><span class="line"> * @param  &#123;object&#125;     options   如果想忽略开始函数的的调用，传入&#123;leading: false&#125;。</span><br><span class="line"> *                                如果想忽略结尾函数的调用，传入&#123;trailing: false&#125;</span><br><span class="line"> *                                两者不能共存，否则函数不能执行</span><br><span class="line"> * @return &#123;function&#125;             返回客户调用函数   </span><br><span class="line"> */</span><br><span class="line">_.throttle = function(func, wait, options) &#123;</span><br><span class="line">    var context, args, result;</span><br><span class="line">    var timeout = null;</span><br><span class="line">    // 之前的时间戳</span><br><span class="line">    var previous = 0;</span><br><span class="line">    // 如果 options 没传则设为空对象</span><br><span class="line">    if (!options) options = &#123;&#125;;</span><br><span class="line">    // 定时器回调函数</span><br><span class="line">    var later = function() &#123;</span><br><span class="line">      // 如果设置了 leading，就将 previous 设为 0</span><br><span class="line">      // 用于下面函数的第一个 if 判断</span><br><span class="line">      previous = options.leading === false ? 0 : _.now();</span><br><span class="line">      // 置空一是为了防止内存泄漏，二是为了下面的定时器判断</span><br><span class="line">      timeout = null;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      if (!timeout) context = args = null;</span><br><span class="line">    &#125;;</span><br><span class="line">    return function() &#123;</span><br><span class="line">      // 获得当前时间戳</span><br><span class="line">      var now = _.now();</span><br><span class="line">      // 首次进入前者肯定为 true</span><br><span class="line">	  // 如果需要第一次不执行函数</span><br><span class="line">	  // 就将上次时间戳设为当前的</span><br><span class="line">      // 这样在接下来计算 remaining 的值时会大于0</span><br><span class="line">      if (!previous &amp;&amp; options.leading === false) previous = now;</span><br><span class="line">      // 计算剩余时间</span><br><span class="line">      var remaining = wait - (now - previous);</span><br><span class="line">      context = this;</span><br><span class="line">      args = arguments;</span><br><span class="line">      // 如果当前调用已经大于上次调用时间 + wait</span><br><span class="line">      // 或者用户手动调了时间</span><br><span class="line"> 	  // 如果设置了 trailing，只会进入这个条件</span><br><span class="line">	  // 如果没有设置 leading，那么第一次会进入这个条件</span><br><span class="line">	  // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了</span><br><span class="line">	  // 其实还是会进入的，因为定时器的延时</span><br><span class="line">	  // 并不是准确的时间，很可能你设置了2秒</span><br><span class="line">	  // 但是他需要2.2秒才触发，这时候就会进入这个条件</span><br><span class="line">      if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class="line">        // 如果存在定时器就清理掉否则会调用二次回调</span><br><span class="line">        if (timeout) &#123;</span><br><span class="line">          clearTimeout(timeout);</span><br><span class="line">          timeout = null;</span><br><span class="line">        &#125;</span><br><span class="line">        previous = now;</span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        if (!timeout) context = args = null;</span><br><span class="line">      &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class="line">        // 判断是否设置了定时器和 trailing</span><br><span class="line">	    // 没有的话就开启一个定时器</span><br><span class="line">        // 并且不能不能同时设置 leading 和 trailing</span><br><span class="line">        timeout = setTimeout(later, remaining);</span><br><span class="line">      &#125;</span><br><span class="line">      return result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/22/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="page-number" href="/page/22/">22</a><span class="page-number current">23</span><a class="page-number" href="/page/24/">24</a><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/24/">Next &amp;raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2022 mr.杜
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>