<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="杜鹏之家">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="杜鹏之家">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="mr.杜">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 6.2.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="https://img1.baidu.com/it/u=412709218,617594518&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=504&amp;h=500" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">mr.杜</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">Home</a></li>
				        
							<li><a href="/archives">Archives</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
						<!-- music -->
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Event-Loop/" style="font-size: 10px;">Event Loop</a> <a href="/tags/Graphviz/" style="font-size: 10px;">Graphviz</a> <a href="/tags/Mock/" style="font-size: 10px;">Mock</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/React/" style="font-size: 19.29px;">React</a> <a href="/tags/Redux/" style="font-size: 11.43px;">Redux</a> <a href="/tags/async-await/" style="font-size: 10px;">async/await</a> <a href="/tags/css/" style="font-size: 13.57px;">css</a> <a href="/tags/echart/" style="font-size: 10px;">echart</a> <a href="/tags/es6/" style="font-size: 16.43px;">es6</a> <a href="/tags/eslint/" style="font-size: 10px;">eslint</a> <a href="/tags/git/" style="font-size: 15.71px;">git</a> <a href="/tags/glup/" style="font-size: 10.71px;">glup</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/html/" style="font-size: 14.29px;">html</a> <a href="/tags/http/" style="font-size: 17.14px;">http</a> <a href="/tags/javascript/" style="font-size: 18.57px;">javascript</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/nginx/" style="font-size: 10.71px;">nginx</a> <a href="/tags/nodejs/" style="font-size: 12.86px;">nodejs</a> <a href="/tags/python/" style="font-size: 10.71px;">python</a> <a href="/tags/qiankun/" style="font-size: 10px;">qiankun</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/serveless/" style="font-size: 10px;">serveless</a> <a href="/tags/typescript/" style="font-size: 12.14px;">typescript</a> <a href="/tags/vs-code/" style="font-size: 11.43px;">vs code</a> <a href="/tags/vue/" style="font-size: 20px;">vue</a> <a href="/tags/vue3/" style="font-size: 10px;">vue3</a> <a href="/tags/webpack/" style="font-size: 17.86px;">webpack</a> <a href="/tags/xml/" style="font-size: 10px;">xml</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 13.57px;">优化</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10.71px;">前端</a> <a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 15px;">小程序</a> <a href="/tags/%E6%8A%93%E5%8C%85/" style="font-size: 10px;">抓包</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正则表达式</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 12.86px;">浏览器</a> <a href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/" style="font-size: 10.71px;">移动端</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.57px;">设计模式</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/">github</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">I&#39;m a developer.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://img1.baidu.com/it/u=412709218,617594518&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=504&amp;h=500" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">Home</a></li>
		        
					<li><a href="/archives">Archives</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-webpack/webpack与其他打包工具的区别" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/12/12/webpack/webpack%E4%B8%8E%E5%85%B6%E4%BB%96%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E7%9A%84%E5%8C%BA%E5%88%AB/" class="article-date">
  	<time datetime="2020-12-12T02:43:28.000Z" itemprop="datePublished">2020-12-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/12/webpack/webpack%E4%B8%8E%E5%85%B6%E4%BB%96%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E7%9A%84%E5%8C%BA%E5%88%AB/">
        webpack与其他打包工具的区别
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、模块化工具"><a href="#一、模块化工具" class="headerlink" title="一、模块化工具"></a>一、模块化工具</h2><p>模块化是一种处理复杂系统分解为更好的可管理模块的方式</p>
<p>可以用来分割，组织和打包应用。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体(<code>bundle</code>)</p>
<p>在前端领域中，并非只有<code>webpack</code>这一款优秀的模块打包工具，还有其他类似的工具，例如<code>Rollup</code>、<code>Parcel</code>、<code>snowpack</code>，以及最近风头无两的<code>Vite</code></p>
<p>通过这些模块打包工具，能够提高我们的开发效率，减少开发成本</p>
<p>这里没有提及<code>gulp</code>、<code>grunt</code>是因为它们只是定义为构建工具，不能类比</p>
<h3 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h3><p><code>Rollup</code> 是一款 <code>ES Modules</code> 打包器，从作用上来看，<code>Rollup</code> 与 <code>Webpack</code> 非常类似。不过相比于 <code>Webpack</code>，<code>Rollup</code>要小巧的多</p>
<p>现在很多我们熟知的库都都使用它进行打包，比如：<code>Vue</code>、<code>React</code>和<code>three.js</code>等</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/messages.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">hi</span>: <span class="string">&#x27;Hey Guys, I am zce~&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ./src/logger.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">log</span> = msg =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---------- INFO ----------&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--------------------------&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">error</span> = msg =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;---------- ERROR ----------&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(msg)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;---------------------------&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; log &#125; <span class="keyword">from</span> <span class="string">&#x27;./logger&#x27;</span></span><br><span class="line"><span class="keyword">import</span> messages <span class="keyword">from</span> <span class="string">&#x27;./messages&#x27;</span></span><br><span class="line"><span class="title function_">log</span>(messages.<span class="property">hi</span>)</span><br></pre></td></tr></table></figure>

<p>然后通过<code>rollup</code>进行打包</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx rollup ./src/index.<span class="property">js</span> --file ./dist/bundle.<span class="property">js</span></span><br></pre></td></tr></table></figure>

<p>打包结果如下图<img src="https://static.vue-js.com/8fe07830-b143-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<p>可以看到，代码非常简洁，完成不像<code>webpack</code>那样存在大量引导代码和模块函数</p>
<p>并且<code>error</code>方法由于没有被使用，输出的结果中并无<code>error</code>方法，可以看到，<code>rollup</code>默认开始<code>Tree-shaking</code> 优化输出结果</p>
<p>因此，可以看到<code>Rollup</code>的优点：</p>
<ul>
<li>代码效率更简洁、效率更高</li>
<li>默认支持 Tree-shaking</li>
</ul>
<p>但缺点也十分明显，加载其他类型的资源文件或者支持导入 <code>CommonJS</code> 模块，又或是编译 <code>ES</code> 新特性，这些额外的需求 <code>Rollup</code>需要使用插件去完成</p>
<p>综合来看，<code>rollup</code>并不适合开发应用使用，因为需要使用第三方模块，而目前第三方模块大多数使用<code>CommonJs</code>方式导出成员，并且<code>rollup</code>不支持<code>HMR</code>，使开发效率降低</p>
<p>但是在用于打包<code>JavaScript</code> 库时，<code>rollup</code>比 <code>webpack</code> 更有优势，因为其打包出来的代码更小、更快，其存在的缺点可以忽略</p>
<h3 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h3><p>Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序</p>
<p><code>Parcel</code> 跟 <code>Webpack</code> 一样都支持以任意类型文件作为打包入口，但建议使用<code>HTML</code>文件作为入口，该<code>HTML</code>文件像平时一样正常编写代码、引用资源。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- ./src/index.<span class="property">html</span> --&gt;</span><br><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Parcel Tutorials<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>main.js文件通过<code>ES Moudle</code>方法导入其他模块成员</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; log &#125; <span class="keyword">from</span> <span class="string">&#x27;./logger&#x27;</span></span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;hello parcel&#x27;</span>)</span><br><span class="line"><span class="comment">// ./src/logger.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">log</span> = msg =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---------- INFO ----------&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后，使用命令打包</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx parcel src/index.html</span><br></pre></td></tr></table></figure>

<p>执行命令后，<code>Parcel</code>不仅打包了应用，同时也启动了一个开发服务器，跟<code>webpack Dev Server</code>一样</p>
<p>跟<code>webpack</code>类似，也支持模块热替换，但用法更简单</p>
<p>同时，<code>Parcel</code>有个十分好用的功能：支持自动安装依赖，像<code>webpack</code>开发阶段突然使用安装某个第三方依赖，必然会终止<code>dev server</code>然后安装再启动。而<code>Parcel</code>则免了这繁琐的工作流程</p>
<p>同时，<code>Parcel</code>能够零配置加载其他类型的资源文件，无须像<code>webpack</code>那样配置对应的<code>loader</code></p>
<p>打包命令如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx parcel src/index.html</span><br></pre></td></tr></table></figure>

<p>由于打包过程是多进程同时工作，构建速度会比<code>Webpack</code> 快，输出文件也会被压缩，并且样式代码也会被单独提取到单个文件中</p>
<p><img src="https://static.vue-js.com/ec17e7a0-b1a2-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<p>可以感受到，<code>Parcel</code>给开发者一种很大的自由度，只管去实现业务代码，其他事情用<code>Parcel</code>解决</p>
<h3 id="Snowpack"><a href="#Snowpack" class="headerlink" title="Snowpack"></a>Snowpack</h3><p>Snowpack，是一种闪电般快速的前端构建工具，专为现代<code>Web</code>设计，较复杂的打包工具（如<code>Webpack</code>或<code>Parcel</code>）的替代方案，利用<code>JavaScript</code>的本机模块系统，避免不必要的工作并保持流畅的开发体验</p>
<p>开发阶段，每次保存单个文件时，<code>Webpack</code>和<code>Parcel</code>都需要重新构建和重新打包应用程序的整个<code>bundle</code>。而<code>Snowpack</code>为你的应用程序每个文件构建一次，就可以永久缓存，文件更改时，<code>Snowpack</code>会重新构建该单个文件</p>
<p>下图给出<code>webpack</code>与<code>snowpack</code>打包区别：</p>
<p><img src="https://static.vue-js.com/79197830-b1a3-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<p>在重新构建每次变更时没有任何的时间浪费，只需要在浏览器中进行HMR更新</p>
<h3 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h3><p>vite ，是一种新型前端构建工具，能够显著提升前端开发体验</p>
<p>它主要由两部分组成：</p>
<ul>
<li>一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的 [模块热更新HMR</li>
<li>一套构建指令，它使用 Rollup打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源</li>
</ul>
<p>其作用类似<code>webpack</code>+ <code>webpack-dev-server</code>，其特点如下：</p>
<ul>
<li>快速的冷启动</li>
<li>即时的模块热更新</li>
<li>真正的按需编译</li>
</ul>
<p><code>vite</code>会直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快</p>
<p>利用现代浏览器支持<code>ES Module</code>的特性，当浏览器请求某个模块的时候，再根据需要对模块的内容进行编译，这种方式大大缩短了编译时间</p>
<p>原理图如下所示：</p>
<p><img src="https://static.vue-js.com/9f2eed30-b143-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<p>在热模块<code>HMR</code>方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像<code>webpack</code>那样需要把该模块的相关依赖模块全部编译一次，效率更高</p>
<h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p>相比上述的模块化工具，<code>webpack</code>大而全，很多常用的功能做到开箱即用。有两大最核心的特点：<strong>一切皆模块</strong>和<strong>按需加载</strong></p>
<p>与其他构建工具相比，有如下优势：</p>
<ul>
<li>智能解析：对 CommonJS 、 AMD 、ES6 的语法做了兼容</li>
<li>万物模块：对 js、css、图片等资源文件都支持打包</li>
<li>开箱即用：HRM、Tree-shaking等功能</li>
<li>代码分割：可以将代码切割成不同的 chunk，实现按需加载，降低了初始化时间</li>
<li>插件系统，具有强大的 Plugin 接口，具有更好的灵活性和扩展性</li>
<li>易于调试：支持 SourceUrls 和 SourceMaps</li>
<li>快速运行：webpack 使用异步 IO 并具有多级缓存，这使得 webpack 很快且在增量编译上更加快</li>
<li>生态环境好：社区更丰富，出现的问题更容易解决</li>
</ul>
<ol>
<li>除了Webpack外，你还了解哪些模块管理工具<br> webpack:<br> 就目前而言，webpack已是最常用的打包工具，webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。<br> gulp：<br> gulp是一个前端自动化构建工具，强调的是前端开发的工作流程，可以通过配置一系列的task，第一task处理的事情（如代码压缩，合并，编译以及浏览器实时更新等）。然后定义这些执行顺序，来让glup执行这些task，从而构建项目的整个开发流程。自动化构建工具并不能把所有的模块打包到一起，也不能构建不同模块之间的依赖关系。</li>
</ol>
<p>  grunt：<br>  是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。<br>  Rollup</p>
<ol start="2">
<li>Rollup 是一款 ES Modules 打包器， 从作用上来看，Rollup 与 Webpack 非常类似。不过相比于 Webpack，Rollup要小巧的多<br> 现在很多我们熟知的库都都使用它进行打包，比如：Vue、React和three.js等<br> Parcel<br> Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序<br> Parcel 跟 Webpack 一样都支持以任意类型文件作为打包入口，但建议使用		HTML文件作为入口，该HTML文件像平时一样正常编写代码、引用资源。<br> 模块化是一种处理复杂系统分解为更好的可管理模块的方式。可以用来分割、组织和打包应用。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体。<br> 在前端领域中，除了Webpack外，比较流行的模块打包工具还包括Rollup、Parcel、snowpack和最近风靡的Vite。</li>
</ol>
<p>  2.1. Rollup<br>  Rollup 是一款 ES Modules 打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。从作用上来看，Rollup 与 Webpack 非常类似。不过相比于 Webpack，Rollup 要小巧的多。现在很多苦都使用它进行打包，比如：Vue、React和three.js等。<br>  使用之前，可以使用npm install –global rollup 命令进行安装。Rollup 可以通过命令行接口(command line interface)配合可选配置文件(optional configuration file)来调用，或者可以通过 JavaScript API来调用。运行 rollup –help 可以查看可用的选项和参数。<br>  2.2. Parcel<br>  Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序。<br>  2.3.  Vite<br>  Vite是Vue的作者尤雨溪开发的Web开发构建工具，它是一个基于浏览器原生ES模块导入的开发服务器，在开发环境下，利用浏览器去解析import，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随启随用。同时不仅对Vue文件提供了支持，还支持热更新，而且热更新的速度不会随着模块增多而变慢。<br>  Vite具有以下特点： - 快速的冷启动 - 即时热模块更新（HMR，Hot Module Replacement） - 真正按需编译<br>  Vite由两部分组成： - 一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的 [模块热更新HMR。 - 一套构建指令，它使用 Rollup打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源。<br>  Vite在开发阶段可以直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快。当浏览器请求某个模块的时候，根据需要对模块的内容进行编译，大大缩短了编译时间。工作原理如下图所示。<br>  在热模块HMR方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像Webpack那样需要把该模块的相关依赖模块全部编译一次，因此效率也更高。<br>3. webpack，rollup，parcel优劣？(了解)<br>    对比</p>
<p>  Webpack<br>  Rollup<br>  Parcel<br>  功能</p>
<p>为处理资源管理和分割代码而生，可以用来处理任何类型的文件，灵活，插件多。<br>    用标准化的格式（es6）来写代码，通过减少死代码尽可能地缩小包体积。<br>    用标准化的格式（es6）来写代码，通过减少死代码尽可能地缩小包体积。<br>配置<br>    webpack需要配config文件，指明entry, output, plugin，transformations。<br>    rollup需要配config文件，指明entry, output, plugin，transformations。rollup 有对import&#x2F;export所做的node polyfills，webpack没有。rollup支持相对路径，而webpack没有，所以得使用</p>
<pre><code>parcel则是完全开箱可用的，不用配置。
</code></pre>
<p>入口文件<br>    webpack只支持js文件作为入口文件，如果要以其他格式的文件作为入口，比如html文件为入口，如要加第三方Plugin。<br>    rollup可以用html作为入口文件，但也需要plugin，比如rollup-plugin-html-entry。<br>    parcel可以用index.html作为入口文件，而且它会通过看index.html的script tag里包含的什么自己找到要打包生成哪些js文件。<br>transformations<br>    transformations指的是把其他文件转化成js文件的过程，需要经过transformation才能够被打包。webpack使用Loaders来处理。<br>    rollup使用plugins来处理。<br>    parcel会自动去转换，当找到配置文件比如.babelrc, .postcssrc后就会自动转。<br>摇树优化<br>    摇树优化是webpack的一大特性。需要1，用import&#x2F;export语法，2，在package.json中加副作用的入口，3，加上支持去除死代码的缩小器（uglifyjsplugin）。<br>    rollup会统计引入的代码并排除掉那些没有被用到的。这使您可以在现有工具和模块的基础上构建，而无需添加额外的依赖项或膨胀项目的大小。<br>    parcel不支持摇树优化。<br>dev server<br>    webpack用webpack-dev-server。<br>rollup用rollup-plugin-serve和rollup-plugin-livereload共同作用。<br>    parcel内置的有dev server<br>热更新<br>    webpack的 wepack-dev-server支持hot模式。<br>    rollup不支持hmr。<br>    parcel有内置的hmr。<br>代码分割<br>    webpack通过在entry中手动设置，使用CommonsChunkPlugin，和模块内的内联函数动态引入来做代码分割。<br>    rollup有实验性的代码分割特性。它是用es模块在浏览器中的模块加载机制本身来分割代码的。需要把experimentalCodeSplitting 和 experimentalDynamicImport 设为true。<br>    parcel支持0配置的代码分割。主要是通过动态improt。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-webpack/webpack模块联邦" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/12/07/webpack/webpack%E6%A8%A1%E5%9D%97%E8%81%94%E9%82%A6/" class="article-date">
  	<time datetime="2020-12-07T07:24:58.000Z" itemprop="datePublished">2020-12-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/07/webpack/webpack%E6%A8%A1%E5%9D%97%E8%81%94%E9%82%A6/">
        webpack模块联邦
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>多个独立的构建可以组成一个应用程序，这些独立的构建之间不应该存在依赖关系，因此可以单独开发和部署它们。<br>这通常被称作微前端，但并不仅限于此。<br>Webpack5 模块联邦可以让 Webpack 达到了线上 Runtime 的效果，让代码直接在项目间利用 CDN 直接共享，不再需要本地安装 Npm 包、构建再发布了！<br>我们知道 Webpack 可以通过 DLL 或者 Externals 做代码共享时 Common Chunk，但不同应用和项目间这个任务就变得困难了，我们几乎无法在项目之间做到按需热插拔。</p>
<p>早期NPM方式共享模块   代码的共享是将依赖作为library安装到我们的项目里进行webpack打包并且构建上线<br>对于项目 Home 与 Search，需要共享一个模块时，最常见的办法就是将其抽成通用依赖并分别安装在各自项目中。虽然 Monorepo 可以一定程度解决重复安装和修改困难的问题，但依然需要走本地编译。</p>
<p>真正 Runtime 的方式可能是 UMD 方式共享代码模块，即将模块用 Webpack UMD模式打包，并输出到其他项目中。这是非常普遍的模块共享方式：<br>对于项目 Home 与 Search，直接利用 UMD 包复用一个模块。但这种技术方案问题也很明显，就是包体积无法达到本地编译时的优化效果，且库之间容易冲突。</p>
<p>微前端：micro-frontends (MFE) 也是最近比较火的模块共享管理方式，微前端就是要解决多项目并存问题，多项目并存的最大问题就是模块共享，模块之间是不能有冲突。  对于微前端我们还要考虑样式冲突，声明周期管理冲突等问题，我们先不考虑这些   想把问题聚焦在资源加载的方式上   微前端一般有两种打包方式：1.子应用独立打包，模块实现解耦，但这种方式无法抽取公共的依赖，2.整体应用打一个打包 很好的解决我们上面第一种方式的问题，但是打包效率速度实在是太慢了。不具备水平的扩展能力。<br>由于微前端还要考虑样式冲突、生命周期管理，所以本文只聚焦在资源加载方式上。微前端一般有两种打包方式：</p>
<ol>
<li>子应用独立打包，模块更解耦，但无法抽取公共依赖等。</li>
<li>整体应用一起打包，很好解决上面的问题，但打包速度实在是太慢了，不具备水平扩展能力。</li>
</ol>
<p>终于提到本文的主角了，模块联邦方式作为 Webpack5 内置核心特性之一的 FederatedModule：<br>这个方案是直接将一个应用的包应用于另一个应用，同时具备整体应用一起打包的公共依赖抽取能力。  比如：我们直接可以在Search应用里直接使用已经发布到线上的Home应用的组件。</p>
<p><strong>应用案例</strong><br>本案例模拟三个应用： Nav 、 Search 及 Home 。每个应用都是独立的，又通过模块邦联系到了一起。<br>比如Home需要使用Nav组件共享出来的header，Search可能要使用Header和Home组件构建出来的HomeList。<br>模块联邦将他们共享的模块暴露出来进行引用。<br>1、Nav 导航<br>src&#x2F;header.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const Header = () =&gt; &#123;</span><br><span class="line"> const header = document.createElement(&#x27;h1&#x27;)</span><br><span class="line"> header.textContent = &#x27;公共头部内容&#x27;</span><br><span class="line"> return header</span><br><span class="line">&#125;</span><br><span class="line">export default Header</span><br></pre></td></tr></table></figure>
<p>src&#x2F;index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import Header from &#x27;./Header&#x27;</span><br><span class="line">const div = document.createElement(&#x27;div&#x27;)</span><br><span class="line">div.appendChild(Header())</span><br><span class="line">document.body.appendChild(div)</span><br></pre></td></tr></table></figure>
<p>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">const &#123;</span><br><span class="line"> ModuleFederationPlugin</span><br><span class="line">&#125; = require(&#x27;webpack&#x27;).container</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode: &#x27;production&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(),</span><br><span class="line">  new ModuleFederationPlugin(&#123;</span><br><span class="line">   // 模块联邦名字</span><br><span class="line">   name: &#x27;nav&#x27;,</span><br><span class="line">   // 外部访问的资源名字</span><br><span class="line">   filename: &#x27;remoteEntry.js&#x27;,</span><br><span class="line">   // 引用的外部资源列表</span><br><span class="line">   remotes: &#123;&#125;,</span><br><span class="line">   // 暴露给外部资源列表</span><br><span class="line">   exposes: &#123;</span><br><span class="line">    &#x27;./Header&#x27;: &#x27;./src/Header.js&#x27;,   // 暴露 Header组件  key：可以定义成./Header 这个./Header并不代表是我当前引用下的某个路径   而是将来在别人用的时候基于这个路径来拼接url，值是正真的我们本地项目的应用</span><br><span class="line">  &#125;,</span><br><span class="line">   // 共享模块，如lodash</span><br><span class="line">   shared: &#123;&#125;,   // 如果我们的 header模块里有共享的第三方模块比如：lodash等，我们可以把他放到这里在打包的时候可以把第三方的共享的模块打到单独的一个包里。</span><br><span class="line"> &#125;),</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用 webpack 运行服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[felix] nav $ npx webpack serve --port 3003</span><br></pre></td></tr></table></figure>

<p>2、Home 首页<br>src&#x2F;HomeList</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const HomeList = (num) =&gt; &#123;</span><br><span class="line"> let str = &#x27;&lt;ul&gt;&#x27;</span><br><span class="line"> for (let i = 0; i &lt; num; i++) &#123;</span><br><span class="line">  str += &#x27;&lt;li&gt;item &#x27; + i + &#x27;&lt;/li&gt;&#x27;</span><br><span class="line">&#125;</span><br><span class="line"> str += &#x27;&lt;/ul&gt;&#x27;</span><br><span class="line"> return str</span><br><span class="line">&#125;</span><br><span class="line">export default HomeList</span><br></pre></td></tr></table></figure>
<p>src&#x2F;index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import HomeList from &#x27;./HomeList&#x27;</span><br><span class="line">remotes: &#123;</span><br><span class="line">    nav</span><br><span class="line">	(&#x27;nav/Header&#x27;)：remotes: &#123; nav &#125;Header    exposes: &#123;./Header&#x27;:&#x27;&#x27;&#125;</span><br><span class="line">import(&#x27;nav/Header&#x27;).then((Header) =&gt; &#123;  //引用模块联邦的组件  这样导入别人组件的时候需要通过异步的方式因为 网络共享或者是模块载入 是由延迟的，所以要通过promise的方式（异步模块加载的形式）去引用它。</span><br><span class="line"> const body = document.createElement(&#x27;div&#x27;)</span><br><span class="line"> body.appendChild(Header.default())</span><br><span class="line"> document.body.appendChild(body)</span><br><span class="line"> document.body.innerHTML += HomeList(5)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">const &#123;</span><br><span class="line"> ModuleFederationPlugin</span><br><span class="line">&#125; = require(&#x27;webpack&#x27;).container</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode: &#x27;production&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(),</span><br><span class="line">  new ModuleFederationPlugin(&#123;</span><br><span class="line">   name: &quot;home&quot;,</span><br><span class="line">   filename: &quot;remoteEntry.js&quot;,</span><br><span class="line">   remotes: &#123;</span><br><span class="line">    nav: &quot;nav@http://localhost:3003/remoteEntry.js&quot;,    // 引用第三方或别人写好的应用的路径。远端的服务路径</span><br><span class="line">  &#125;,</span><br><span class="line">   exposes: &#123;</span><br><span class="line">    &#x27;./HomeList&#x27;: &#x27;./src/HomeList.js&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">   shared: &#123;&#125;,</span><br><span class="line"> &#125;),</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用 webpack 运行服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[felix] nav $ npx webpack serve --port 3001</span><br></pre></td></tr></table></figure>

<p>3、search 搜索<br>src&#x2F;index</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([import(&#x27;nav/Header&#x27;), import(&#x27;home/HomeList&#x27;)])</span><br><span class="line">.then(([&#123;</span><br><span class="line">  default: Header</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  default: HomeList</span><br><span class="line">&#125;]) =&gt; &#123;</span><br><span class="line">  document.body.appendChild(Header())</span><br><span class="line">  document.body.innerHTML += HomeList(4)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">const &#123;</span><br><span class="line"> ModuleFederationPlugin</span><br><span class="line">&#125; = require(&#x27;webpack&#x27;).container</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode: &#x27;production&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(),</span><br><span class="line">  new ModuleFederationPlugin(&#123;</span><br><span class="line">   name: &#x27;search&#x27;,</span><br><span class="line">   filename: &#x27;remoteEntry.js&#x27;,</span><br><span class="line">   remotes: &#123;</span><br><span class="line">    nav: &quot;nav@http://localhost:3003/remoteEntry.js&quot;,</span><br><span class="line">    home: &quot;home@http://localhost:3001/remoteEntry.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">   exposes: &#123;&#125;,</span><br><span class="line">   shared: &#123;&#125;,</span><br><span class="line"> &#125;),</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用 webpack 运行服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[felix] nav $ npx webpack serve --port 3002</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-webpack/webpack面试题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/12/03/webpack/webpack%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  	<time datetime="2020-12-03T12:08:31.000Z" itemprop="datePublished">2020-12-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/03/webpack/webpack%E9%9D%A2%E8%AF%95%E9%A2%98/">
        webpack面试题总结
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>webpack 面试题</p>
<h1 id="一、-概念"><a href="#一、-概念" class="headerlink" title="一、 概念"></a>一、 概念</h1><h2 id="1-什么是webpack，谈谈你对它的理解？"><a href="#1-什么是webpack，谈谈你对它的理解？" class="headerlink" title="1. 什么是webpack，谈谈你对它的理解？"></a>1. 什么是webpack，谈谈你对它的理解？</h2><p>是一个模块化打包工具，将不同的资源和文件，进行打包，合并在一个文件里。<br>概念+打包流程+前端模块化<br>1、依赖管理：方便引用第三方模块，让模块更容易复用、避免全局注入导致的冲突、、避免重复加载或者加载不必要的模块<br>2、合并代码：把各个分散的模块集中打包成大文件，减少HTTP的链接的请求次数，配合uglify.js可以减少、优化代码的体积<br>3、各种插件：babel把ES6+转化为ES5-，eslint可以检查编译时的各种错误</p>
<p>(30条消息) 前端模块化理解<em>perwhy_wang的博客-CSDN博客</em>前端模块化的理解</p>
<h2 id="2-webpack的工作原理"><a href="#2-webpack的工作原理" class="headerlink" title="2. webpack的工作原理?"></a>2. webpack的工作原理?</h2><h3 id="工作原理概括"><a href="#工作原理概括" class="headerlink" title="工作原理概括"></a>工作原理概括</h3><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在了解webpack原理前，需要掌握以下几个核心概念，以方便后面的理解：</p>
<ol>
<li><p>Entry:入口指示webpack以哪个文件为入口起点开始打包，分析构建内部依赖图</p>
</li>
<li><p>output:输出指示webpack的打包后的资源bundles输出到哪里去，以及如何命名</p>
</li>
<li><p>Loader:让webpack能够去处理哪些非JavaScrip文件（webpack自身只理解javaScript)</p>
</li>
<li><p>plugin:插件可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等</p>
</li>
<li><p>mode:模式指示webpack使用相应模式的配置</p>
<h3 id="流程概括"><a href="#流程概括" class="headerlink" title="流程概括"></a>流程概括</h3><p>webpack的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p>
</li>
<li><p>初始化参数：从配置文件和Shell语句中读取与合并参数，得出最终的参数；</p>
</li>
<li><p>开始编译： 用上一步得到的参数初始化Complier对象，加载所有配置的插件，执行对象的run方法开始执行编译；</p>
</li>
<li><p>确定入口： 根据配置中的entry找出所有入口文件；</p>
</li>
<li><p>编译模块：从入口文件出发，调用所有配置的Loader对模块进行翻译，再找出该模块依赖的模块，再递归本步骤知道所有入口依赖的文件都经过了本步骤的处理；</p>
</li>
<li><p>完成模块编译： 在经过第4步使用Loader翻译完所有模块后，得到了每个模块被翻译后的最终内容以及他们之间的依赖关系；</p>
</li>
<li><p>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</p>
</li>
<li><p>输出完成： 在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</p>
<p>在以上过程中，webpack会在特定的时间点广播出特定的时间，插件在监听到感兴趣的时间后会执行特定的逻辑，并且插件可以调用Webpack提供的API改变Webpack的运行结果。</p>
<h3 id="流程细节"><a href="#流程细节" class="headerlink" title="流程细节"></a>流程细节</h3><p>Webpack的构建流程可以分为以下三个阶段：</p>
</li>
<li><p>初始化：启动构建，读取与合并配置参数，加载Plugin，实例化Complier.</p>
</li>
<li><p>编译：从Entry出发，针对每个Module串行调用对应的Loader去翻译文件内容，再找到该Module依赖的Module，递归地进行编译处理。</p>
</li>
<li><p>输出： 对编译后的Module组合成Chunk，把Chunk转换成文件，输出到文件系统。<br>如果只执行一次构建，以上阶段将会按照顺序各执行一次。但在开启监听模式下，流程将变为如下：</p>
</li>
</ol>
<h2 id="3-webpack4和webpack5的区别？"><a href="#3-webpack4和webpack5的区别？" class="headerlink" title="3. webpack4和webpack5的区别？"></a>3. webpack4和webpack5的区别？</h2><p>更快的构建速度<br>更高的版本要求<br>更灵活的模块组合<br>更智能的缓存优化<br>更小的体积<br>webpack4 上需要下载安装 terser-webpack-plugin 插件<br>webpack5 内部本身就自带 js 压缩功能，他内置了 terser-webpack-plugin 插件，我们不用再下载安装。而且在 mode&#x3D;“production” 的时候会自动开启 js 压缩功能。<br>webpack4 缓存配置<br>● npm install hard-source-webpack-plugin -D<br>webpack5 缓存配置<br>● webpack5 内部内置了 cache 缓存机制。直接配置即可。<br>● cache 会在开发模式下被设置成 type： memory 而且会在生产模式把cache 给禁用掉。<br>webpack4 启动服务<br>● 通过 webpack-dev-server 启动服务<br>webpack5 启动服务<br>● 内置使用 webpack serve 启动，但是他的日志不是很好，所以一般都加都喜欢用 webpack-dev-server 优化。<br>devtool的区别<br>● sourceMap需要在 webpack.config.js里面直接配置 devtool 就可以实现了。而 devtool有很多个选项值，不同的选项值，不同的选项产生的 .map 文件不同，打包速度不同。<br>● 一般情况下，我们一般在开发环境配置用“cheap-eval-module-source-map”，在生产环境用‘none’。<br>v4: devtool: ‘cheap-eval-module-source-map’<br>v5: devtool: ‘eval-cheap-module-source-map’<br>打包：<br>● webpack4打包:即使后续没有使用到num1的函数，依然会将代码打包进去<br>● webpack5打包:后续没有使用到num1的函数，不会将代码打包进去<br>输出代码：<br>● webpack4只能输出es5的代码<br>● webpack5新增属性output.ecmaVersion，可以生成ES5和ES6的代码</p>
<h2 id="4-前端代码为何要进行构建和打包？"><a href="#4-前端代码为何要进行构建和打包？" class="headerlink" title="4. 前端代码为何要进行构建和打包？"></a>4. 前端代码为何要进行构建和打包？</h2><ol>
<li><p>代码方面体积更小，加载更快（tree-shaking，压缩合并）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i. 编译高级语言和语法（ts，es6，模块化） ii. 兼容性和错误提示（polyfill，postcss，eslint）</span><br></pre></td></tr></table></figure>
</li>
<li><p>研发流程统一、高效的开发环境</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i. 统一的构建流程和产出标准 ii. 集成公司构建规范（提测，上线）</span><br></pre></td></tr></table></figure></li>
</ol>
<p>打包之后许多零碎的文件打包成一个整体，页面只需请求一次，js文件中使用模块化互相引用，这样能在一定程度上提供页面渲染效率，打包的同时会进行编译，将es6，sass等高级语法进行转换编译，以兼容高版本的浏览器</p>
<h2 id="5-webpack的优缺点？"><a href="#5-webpack的优缺点？" class="headerlink" title="5. webpack的优缺点？"></a>5. webpack的优缺点？</h2><p>优点：<br>（1） webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD&#x2F;CMD 的支持也很全面，方便旧项目进行代码迁移。<br>（2）能被模块化的不仅仅是 JS 了。<br>（3） 开发便捷，能替代部分 grunt&#x2F;gulp 的工作，比如打包、压缩混淆、图片转base64等。<br>（4）扩展性强，插件机制完善<br>缺点：<br>● 配置复杂<br>● 不分包bundle.js体积庞大<br>● 只能用于采用模块化开发的项目<br>● 打包慢<br>● ES模块除Module外全用babel转换，但是一部分ES2015 语法的 firefox 与 chrome 浏览器中能直接跑的代码，无法用 webpack 编译</p>
<h2 id="6-什么是bundle，什么是chunk，什么是module"><a href="#6-什么是bundle，什么是chunk，什么是module" class="headerlink" title="6. 什么是bundle，什么是chunk，什么是module"></a>6. 什么是bundle，什么是chunk，什么是module</h2><p>bundle： 是由webpack打包出来的文件<br>chunk： 是指webpack在进行模块依赖分析的时候，代码分割出来的代码块<br>module： 是开发中的单个模块</p>
<h1 id="二、-loader"><a href="#二、-loader" class="headerlink" title="二、 loader"></a>二、 loader</h1><h2 id="1-Loader机制的作用是什么？"><a href="#1-Loader机制的作用是什么？" class="headerlink" title="1. Loader机制的作用是什么？"></a>1. Loader机制的作用是什么？</h2><p>webpack 本身只能处理 JavaScript 和 JSON 文件，而 loader 为 webpack 添加了处理其他类型文件的能力。<br>webpack默认只能打包js文件，配置里的module.rules数组配置了一组规则，告诉 Webpack 在遇到哪些文件时使用哪些 Loader 去加载和转换打包成js。<br>注意：use属性的值需要是一个由 Loader 名称组成的数组，Loader 的执行顺序是由后到前的；每一个 Loader 都可以通过 URL querystring 的方式传入参数，例如css-loader?minimize中的minimize告诉css-loader要开启 CSS 压缩。</p>
<h2 id="2-有哪些常见的Loader？他们是解决什么问题的？"><a href="#2-有哪些常见的Loader？他们是解决什么问题的？" class="headerlink" title="2. 有哪些常见的Loader？他们是解决什么问题的？"></a>2. 有哪些常见的Loader？他们是解决什么问题的？</h2><p>● file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件<br>● url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去<br>● source-map-loader：加载额外的 Source Map 文件，以方便断点调试<br>● image-loader：加载并且压缩图片文件<br>● babel-loader：把 ES6 转换成 ES5<br>● css-loader：加载 CSS，支持模块化、压缩、文件导入等特性<br>● style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。<br>● eslint-loader：通过 ESLint 检查 JavaScript 代码</p>
<h2 id="3-Webpack-的-Loader-是什么？"><a href="#3-Webpack-的-Loader-是什么？" class="headerlink" title="3. Webpack 的 Loader 是什么？"></a>3. Webpack 的 Loader 是什么？</h2><p>Webpack 只能理解 JavaScript 和 JSON 文件，这是 Webpack 开箱可用的自带能力。loader 可以让 Webpack 能够去处理其他类型的文件，比如 .scss 和 .ts，并将它们转换为有效的功能离散的 chunk 文件以供应用程序使用，以及被添加到依赖图中，也可将内联图像转换为 data URL。简单来说，loader 可以将一段代码转换成另一端代码，通常用来将一段特殊代码转换成一段浏览器可识别的代码。<br>loader从下到上地取值(evaluate)&#x2F;执行(execute)，也就是是从后往前执行。在下面的示例中，从 ts-loader开始执行，然后继续执行 css-loader，最后以 raw-loader 为结束。loader 有两个属性：test，正则表达式，用于识别出哪些文件会被转换，use 定义在进行转换时应该使用哪个 loader，可以是字符串、数组和对象。</p>
<h1 id="三、-plugin"><a href="#三、-plugin" class="headerlink" title="三、 plugin"></a>三、 plugin</h1><h2 id="1-Plugin（插件）的作用是什么？"><a href="#1-Plugin（插件）的作用是什么？" class="headerlink" title="1. Plugin（插件）的作用是什么？"></a>1. Plugin（插件）的作用是什么？</h2><p>通过安装和配置第三方的插件，可以拓展 webpack 的能力，从而让 webpack 用起来更方便。最常用的webpack 插件有如下两个：<br>① webpack-dev-server<br>类似于 node.js 阶段用到的 nodemon 工具<br>每当修改了源代码，webpack 会自动进行项目的打包和构建<br>② html-webpack-plugin<br>webpack 中的 HTML 插件（类似于一个模板引擎插件）<br>可以通过此插件自定制 index.html 页面的内容<br>webpack-dev-server 可以让 webpack 监听项目源代码的变化，从而进行自动打包构建。<br>运行如下的命令，即可在项目中安装webpack插件：<br>npm install webpack-dev-<a href="mailto:server@3.11.0">server@3.11.0</a> -D</p>
<p>下面进行webpack-dev-server配置，修改package.json -&gt; scripts中的dev命令：<br>“scripts”:{<br>“dev”：”webpack serve”，&#x2F;&#x2F; script 节点下的脚本,可以通过 npm run 执行<br>}</p>
<p>再次运行npm run dev 命令，重新进行项目的打包，在浏览器中访问<a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a> 地址，查看自动打包效果，注意webpack-dev-server 会启动一个实时打包的http 服务器。</p>
<h2 id="2-有哪些常见的Plugin？他们是解决什么问题的？"><a href="#2-有哪些常见的Plugin？他们是解决什么问题的？" class="headerlink" title="2. 有哪些常见的Plugin？他们是解决什么问题的？"></a>2. 有哪些常见的Plugin？他们是解决什么问题的？</h2><p>● define-plugin：定义环境变量<br>● commons-chunk-plugin：提取公共代码<br>● uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码<br>● purgecss-webpack-plugin：擦除无用css<br>● happypack：多线程处理打包<br>● webpack-bundle-analyzer：打包分析<br>● speed-measure-webpack-plugin：构建速度分析<br>● html-webpack-plugin：<br>● 为html文件中引入的外部资源如script、link动态添加每次compile后的hash，防止引用缓存的外部文件问题</p>
<h2 id="3-是否写过Loader和Plugin？描述一下编写loader或plugin的思路？"><a href="#3-是否写过Loader和Plugin？描述一下编写loader或plugin的思路？" class="headerlink" title="3. 是否写过Loader和Plugin？描述一下编写loader或plugin的思路？"></a>3. 是否写过Loader和Plugin？描述一下编写loader或plugin的思路？</h2><p>Loader像一个”翻译官”把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。<br>编写Loader时要遵循单一原则，每个Loader只做一种”转义”工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。<br>相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p>
<h2 id="4-Webpack-的-Plugin-是什么？"><a href="#4-Webpack-的-Plugin-是什么？" class="headerlink" title="4. Webpack 的 Plugin 是什么？"></a>4. Webpack 的 Plugin 是什么？</h2><p>plugin是插件的意思，通常是用于对某个现有的架构进行扩展。<br>webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文 件压缩等等。</p>
<h2 id="5-Loader和Plugin的不同？"><a href="#5-Loader和Plugin的不同？" class="headerlink" title="5. Loader和Plugin的不同？"></a>5. Loader和Plugin的不同？</h2><p>不同的作用<br>● Loader直译为”加载器”。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。<br>● Plugin直译为”插件”。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。<br>不同的用法</p>
<ol>
<li><p>Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）</p>
</li>
<li><p>Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。</p>
<h2 id="6-是否写过Loader和Plugin？描述一下编写loader或plugin的思路？"><a href="#6-是否写过Loader和Plugin？描述一下编写loader或plugin的思路？" class="headerlink" title="6. 是否写过Loader和Plugin？描述一下编写loader或plugin的思路？"></a>6. 是否写过Loader和Plugin？描述一下编写loader或plugin的思路？</h2><p>Loader像一个”翻译官”把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。</p>
<p>编写Loader时要遵循单一原则，每个Loader只做一种”转义”工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。</p>
<p>相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p>
</li>
</ol>
<h1 id="四、-优化"><a href="#四、-优化" class="headerlink" title="四、 优化"></a>四、 优化</h1><h2 id="1、-如何提高webpack的构建速度？"><a href="#1、-如何提高webpack的构建速度？" class="headerlink" title="1、 如何提高webpack的构建速度？"></a>1、 如何提高webpack的构建速度？</h2><ol>
<li>多入口情况下，使用CommonsChunkPlugin来提取公共代码</li>
<li>通过externals配置来提取常用库<br>利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。</li>
<li>使用Happypack 实现多线程加速编译</li>
<li>使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度</li>
<li>使用Tree-shaking和Scope Hoisting来剔除多余代码</li>
</ol>
<h2 id="2、-如何利用webpack来优化前端性能？（提高性能和体验）"><a href="#2、-如何利用webpack来优化前端性能？（提高性能和体验）" class="headerlink" title="2、 如何利用webpack来优化前端性能？（提高性能和体验）!"></a>2、 如何利用webpack来优化前端性能？（提高性能和体验）!</h2><p>前端性能优化方案都有哪些？ - 知乎 (zhihu.com)<br>(30条消息) 前端性能优化的方法_万般皆是你的博客-CSDN博客<br>用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。<br>● 压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css<br>● 利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径<br>● 删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数–optimize-minimize来实现<br>● 提取公共代码。<br>● 异步组件<br>● 异步图片<br>● 配置webpack对小图片打包成base64字符 减少io请求</p>
<h2 id="3、-怎么配置单页应用？怎么配置多页应用？"><a href="#3、-怎么配置单页应用？怎么配置多页应用？" class="headerlink" title="3、 怎么配置单页应用？怎么配置多页应用？"></a>3、 怎么配置单页应用？怎么配置多页应用？</h2><p>单页应用可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可，这里不再赘述<br>多页应用的话，可以使用webpack的 AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。</p>
<h2 id="4、-如何提升webpack的运行速度-开发环境-有哪些策略？"><a href="#4、-如何提升webpack的运行速度-开发环境-有哪些策略？" class="headerlink" title="4、 如何提升webpack的运行速度(开发环境) ,有哪些策略？"></a>4、 如何提升webpack的运行速度(开发环境) ,有哪些策略？</h2><p>多入口情况下，使用CommonsChunkPlugin来提取公共代码<br>通过externals配置来提取常用库<br>利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。<br>使用Happypack 实现多线程加速编译<br>使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度<br>使用Tree-shaking和Scope Hoisting来剔除多余代码<br>● JS代码压缩<br>● terser是一个JavaScript的解释、绞肉机、压缩机的工具集，可以帮助我们压缩、丑化我们的代码，让bundle更小。在production模式下，webpack 默认就是使用 TerserPlugin 来处理我们的代码的。如果想要自定义配置它，配置方法如下。<br>● TerserPlugin常用的属性如下： - extractComments：默认值为true，表示会将注释抽取到一个单独的文件中，开发阶段，我们可设置为 false ，不保留注释 - parallel：使用多进程并发运行提高构建的速度，默认值是true，并发运行的默认数量： os.cpus().length - 1 - terserOptions：设置我们的terser相关的配置： compress：设置压缩相关的选项，mangle：设置丑化相关的选项，可以直接设置为true mangle：设置丑化相关的选项，可以直接设置为true toplevel：底层变量是否进行转换keep_classnames：保留类的名称 keep_fnames：保留函数的名称<br>● 代码压缩<br>● cssCSS压缩通常用于去除无用的空格等，不过因为很难去修改选择器、属性的名称、值等，所以我们可以使用另外一个插件：css-minimizer-webpack-plugin<br>● Html文件代码压缩<br>● 文件大小压缩<br>● 对文件的大小进行压缩，可以有效减少http传输过程中宽带的损耗，文件压缩需要用到 compression-webpack-plugin插件<br>● 图片压缩<br>● 如果我们对bundle包进行分析，会发现图片等多媒体文件的大小是远远要比 js、css 文件要大的，所以图片压缩在打包方面也是很重要的</p>
<p>● Tree Shaking<br>● Tree Shaking 是一个术语，在计算机中表示消除死代码，依赖于ES Module的静态语法分析。在webpack实现Trss shaking有两种不同的方案： - usedExports：通过标记某些函数是否被使用，之后通过Terser来进行优化的 - sideEffects：跳过整个模块&#x2F;文件，直接查看该文件是否有副作用<br>● usedExports的配置方法很简单，只需要将usedExports设为true即可，如下。而sideEffects则用于告知webpack compiler在编译时哪些模块有副作用，配置方法是在package.json中设置sideEffects属性。如果sideEffects设置为false，就是告知webpack可以安全的删除未用到的exports，如果有些文件需要保留，可以设置为数组的形式。<br>● 代码分离<br>■ 默认情况下，所有的JavaScript代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度。如果可以分出出更小的bundle，以及控制资源加载优先级，从而优化加载性能。<br>■ 代码分离可以通过splitChunksPlugin来实现，该插件webpack已经默认安装和集成，只需要配置即可。<br>■ splitChunks有如下几个属性： - Chunks：对同步代码还是异步代码进行处理 - minSize： 拆分包的大小, 至少为minSize，如何包的大小不超过minSize，这个包不会拆分 - maxSize： 将大于maxSize的包，拆分为不小于minSize的包 - minChunks：被引入的次数，默认是1<br>● 内联 chunk<br>■ 可以通过InlineChunkHtmlPlugin插件将一些chunk的模块内联到html，如runtime的代码（对模块进行解析、加载、模块信息相关的代码），代码量并不大但是必须加载的，比如：总结一下，Webpack对前端性能的优化，主要是通过文件体积大小入手，主要的措施有分包、减少Http请求次数等。</p>
<p>用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。<br>1、压缩代码:删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS文件， 利用 cssnano （css-loader? minimize）来压缩css<br>2、利用CDN加速: 在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用 webpack对于 output 参数和各loader的 publicPath 参数来修改资源路径<br>3、Tree Shaking: 将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数 — optimize-minimize 来实现<br>4、Code Splitting: 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利用浏览 器缓存<br>5、提取公共第三方库: SplitChunksPlugin插件来进行公共模块抽取,利用浏览器缓存可以长期缓存这 些无需频繁变动的公共代码</p>
<h2 id="5、-npm打包时需要注意哪些？如何利用webpack来更好的构建？"><a href="#5、-npm打包时需要注意哪些？如何利用webpack来更好的构建？" class="headerlink" title="5、 npm打包时需要注意哪些？如何利用webpack来更好的构建？"></a>5、 npm打包时需要注意哪些？如何利用webpack来更好的构建？</h2><p>● Npm是目前最大的 JavaScript 模块仓库，里面有来自全世界开发者上传的可复用模块。你可能只是JS模块的使用者，但是有些情况你也会去选择上传自己开发的模块。关于NPM模块上传的方法可以去官网上进行学习，这里只讲解如何利用webpack来构建。<br>● NPM模块需要注意以下问题：要支持CommonJS模块化规范，所以要求打包后的最后结果也遵守该规则。Npm模块使用者的环境是不确定的，很有可能并不支持ES6，所以打包的最后结果应该是采用ES5编写的。并且如果ES5是经过转换的，请最好连同SourceMap一同上传。Npm包大小应该是尽量小（有些仓库会限制包大小）发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。UI组件类的模块应该将依赖的其它资源文件，例如.css文件也需要包含在发布的模块里。</p>
<h2 id="6、-什么是长缓存？在webpack中如何做到长缓存优化？"><a href="#6、-什么是长缓存？在webpack中如何做到长缓存优化？" class="headerlink" title="6、 什么是长缓存？在webpack中如何做到长缓存优化？"></a>6、 什么是长缓存？在webpack中如何做到长缓存优化？</h2><p>● 浏览器在用户访问页面的时候，为了加快加载速度，会对用户访问的静态资源进行存储，但是每一次代码升级或者更新，都需要浏览器去下载新的代码，最方便和最简单的更新方式就是引入新的文件名称。<br>● 在webpack中，可以在output给出输出的文件制定chunkhash，并且分离经常更新的代码和框架代码，通过NameModulesPlugin或者HashedModulesPlugin使再次打包文件名不变。</p>
<h2 id="7、-在项目中tree-shaking摇树不是很干净，有什么解决方案？"><a href="#7、-在项目中tree-shaking摇树不是很干净，有什么解决方案？" class="headerlink" title="7、 在项目中tree-shaking摇树不是很干净，有什么解决方案？"></a>7、 在项目中tree-shaking摇树不是很干净，有什么解决方案？</h2><p>在webpack.config.js中通过<br>来进行tree-shaking 但是单单指定这一个配置 不是很干净<br>有些模块导入，只要被引入，<br>就会对应用程序产生重要的影响。一个很好的例子就是全局样式表，或者设置全局配<br>置的JavaScript 文件。<br>如何告诉 Webpack 你的代码无副作用，可以通过 package.json 有一个特殊的属性<br>sideEffects，就是为此而存在的。<br>它有三个可能的值：<br>● true：如果不指定其他值的话。这意味着所有的文件都有副作用，也就是没有一个文件<br>可以 tree-shaking。<br>● false： 告诉 Webpack 没有文件有副作用，所有文件都可以 tree-shaking。<br>● 数组[…]：是文件路径数组。它告诉 webpack，除了数组中包含的文件外，你的任何文件<br>都没有副作用。因此，除了指定的文件之外，其他文件都可以安全地进行 tree-shaking。</p>
<h2 id="8、-怎么提高webpack的打包效率？"><a href="#8、-怎么提高webpack的打包效率？" class="headerlink" title="8、 怎么提高webpack的打包效率？"></a>8、 怎么提高webpack的打包效率？</h2><p>(29条消息) 提高webpack的打包速度方法<em>孙德海想进阿里的博客-CSDN博客</em>提升webpack打包速度<br>如何提高webpack的构建速度 - 简书 (jianshu.com)<br>开发环境优化</p>
<ol>
<li><p>开启热模块替换（HMR）</p>
</li>
<li><p>使用 source-map 进行源代码映射</p>
</li>
<li><p>将只需要被loader执行一次的规则放到 oneOf 里面去<br>生产环境优化</p>
</li>
<li><p>对资源进行缓存</p>
</li>
<li><p>使用tree shaking（树摇）</p>
</li>
<li><p>使用code split 进行代码分割</p>
</li>
<li><p>文件懒加载和预加载</p>
</li>
<li><p>多进程打包</p>
</li>
<li><p>使用PWA（离线加载）</p>
</li>
<li><p>使用externals 忽略某些包，然后通过cdn引入</p>
</li>
<li><p>使用dll 技术对某些库（第三方库）进行单独打包</p>
<h2 id="9、-按需加载的原理"><a href="#9、-按需加载的原理" class="headerlink" title="9、 按需加载的原理"></a>9、 按需加载的原理</h2><p>● 使用符合 ECMAScript 提案 的 import() 语法</p>
<p>● 使用 webpack 特定的 require.ensure</p>
<h2 id="10、-预获取-x2F-预加载模块"><a href="#10、-预获取-x2F-预加载模块" class="headerlink" title="10、 预获取&#x2F;预加载模块"></a>10、 预获取&#x2F;预加载模块</h2><p>Webpack v4.6.0+ 增加了对预获取和预加载的支持。</p>
<p>在声明 import 时，使用下面这些内置指令，可以让 webpack 输出 “resource hint(资源提示)”，来告知浏览器</p>
<p>● prefetch(预获取)：将来某些导航下可能需要的资源</p>
<p>● preload(预加载)：当前导航下可能需要资源</p>
<p>添加第二句魔法注释： webpackPrefetch: true</p>
<p>告诉 webpack 执行预获取。这会生成 <link rel="prefetch" href="math.js"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并追加到页面头部，指示着浏览器在闲置时间预取 math.js 文件。</span><br></pre></td></tr></table></figure>

<h2 id="11、-懒加载"><a href="#11、-懒加载" class="headerlink" title="11、 懒加载"></a>11、 懒加载</h2><p>懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把</p>
<p>你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用</p>
<p>或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体</p>
<p>体积，因为某些代码块可能永远不会被加载。</p>
<p>创建一个 math.js 文件，在主页面中通过点击按钮调用其中的函数：</p>
<p>button.addEventListener(‘click’, () &#x3D;&gt; {</p>
<p>import(&#x2F;</p>
<p> webpackChunkName: ‘math’ </p>
<p>&#x2F; ‘.&#x2F;math.js’).then(({ add</p>
<p>}) &#x3D;&gt; {</p>
<p>console.log(add(4, 5))</p>
<p>})</p>
<p>})</p>
</li>
</ol>
<p>这里有句注释，我们把它称为 webpack 魔法注释： webpackChunkName: ‘math’ ,告诉webpack打包生成的文件名为 math 。<br>第一次加载完页面， math.bundle.js 不会加载，当点击按钮后，才加载<br>math.bundle.js 文件。</p>
<ol>
<li>什么是Tree-sharking?<br>Tree是树，sharking是摇晃的意思。那么树摇晃的时候，肯定会’摇’下来一些无用的叶子。从编程的角度思考，如果假设我们的代码是一棵树（Tree），那么摇下来的无用的的叶子是什么呢？当然是无用的代码啦，他有个专业的术语，叫做dead-code（死码）<br>指打包中去除那些引入了但在代码中没用到的死代码。在wepack中js treeshaking通过UglifyJsPlugin来进行，css中通过purify-CSS来进行。</li>
</ol>
<h1 id="五、-构建流程"><a href="#五、-构建流程" class="headerlink" title="五、 构建流程"></a>五、 构建流程</h1><h2 id="1-webpack的构建流程是什么-从读取配置到输出文件这个过程尽量说全"><a href="#1-webpack的构建流程是什么-从读取配置到输出文件这个过程尽量说全" class="headerlink" title="1. webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全"></a>1. webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全</h2><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p>
<ol>
<li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</li>
<li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；</li>
<li>确定入口：根据配置中的 entry 找出所有的入口文件；</li>
<li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</li>
<li>完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</li>
<li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</li>
<li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。<br>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</li>
</ol>
<h2 id="2-解决ESLint报错常用的五种方案"><a href="#2-解决ESLint报错常用的五种方案" class="headerlink" title="2. 解决ESLint报错常用的五种方案"></a>2. 解决ESLint报错常用的五种方案</h2><p>（1）Strings must use singlequote quotes<br>表示变量使用了双引号，把表示变量的双引号改为单引号即可。<br>（2）Expected to be enclosed by double quotes (vue&#x2F;html-quotes)<br>这个报错代表让你要将单引号改为双引号<br>（3）Trailing spaces not allowed no-trailing-spaces<br>代表有的地方空格多余，比如标签结尾处，只要删除多余空格即可<br>（4）Unexpected tab character’<br>面意思理解呢就是意想不到的制表符，当时出现的时候就是我习惯的使用Tab键去打空格，但是eslint默认不认可Tab，所以解决方法很简单：<br>在eslint的配置文件中（.eslintrc）rules项中添加一行：“no-tabs”:“off”。如下：<br>（5）‘expected indentation of 2 spaces but found 1 tab’<br>字面意思就是预期缩进2个空格，但找到1个Tab。说实话，我一开始找了半天，没发现原因，后来想到可能是eslint不认可tab开头，因此我找到了我使用的编辑器VSCord的设置，添加了相应的文字：</p>
<p>大概的意思就是在格式话保存的时候按照1tab&#x3D;2space的计算量将tab替换成space，这样就不会有问题了。<br>（6）Unexpected trailing comma. (comma-dangle)<br>字面意思是尾随了一个多余的逗号<br>（7）There should be no space before this paren space-in-parens<br>结尾有多余的空格，去掉就好。</p>
<h2 id="3-什么是模块热更新？有什么优点？"><a href="#3-什么是模块热更新？有什么优点？" class="headerlink" title="3. 什么是模块热更新？有什么优点？"></a>3. 什么是模块热更新？有什么优点？</h2><p>HMR即Hot Module Replacement是指当你对代码修改并保存后，webpack将会对代码进行重新打包，并将改动的模块发送到浏览器端，浏览器用新的模块替换掉旧的模块，去实现局部更新页面而非整体刷新页面。<br>借助webpack.HotModuleReplacementPlugin()，devServer开启hot<br>场景1：实现只刷新css，不影响js场景2：js中实现热更新，只更新指定js模块<br>优点：<br>在开发阶段，可以提高开发效率，不用手动重新编译即可看到最新效果，webpack服务会通知页面驱动试图进行更新，不用在浏览器手动进行刷新页面</p>
<h2 id="4-Webpack-Proxy工作原理"><a href="#4-Webpack-Proxy工作原理" class="headerlink" title="4. Webpack Proxy工作原理"></a>4. Webpack Proxy工作原理</h2><p>4.1 代理<br>在项目开发中不可避免会遇到跨越问题，Webpack中的Proxy就是解决前端跨域的方法之一。所谓代理，指的是在接收客户端发送的请求后转发给其他服务器的行为，webpack中提供服务器的工具为webpack-dev-server。<br>4.1.1 webpack-dev-server<br>webpack-dev-server是 webpack 官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起。同时，为了提高开发者日常的开发效率，只适用在开发阶段。在webpack配置对象属性中配置代理的代码如下：<br>&#x2F;&#x2F; .&#x2F;webpack.config.js<br>const path &#x3D; require(‘path’)</p>
<p>module.exports &#x3D; {<br>&#x2F;&#x2F; …<br>devServer: {<br>contentBase: path.join(__dirname, ‘dist’),<br>compress: true,<br>port: 9000,<br>proxy: {<br>‘&#x2F;api’: {<br>target: ‘<a target="_blank" rel="noopener" href="https://api.github.com/">https://api.github.com</a>‘<br>}<br>}<br>&#x2F;&#x2F; …<br>}<br>}</p>
<p>其中，devServetr里面proxy则是关于代理的配置，该属性为对象的形式，对象中每一个属性就是一个代理的规则匹配。<br>属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为 &#x2F;api，值为对应的代理匹配规则，对应如下： - target：表示的是代理到的目标地址。 - pathRewrite：默认情况下，我们的 &#x2F;api-hy 也会被写入到URL中，如果希望删除，可以使用pathRewrite。 - secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false。 - changeOrigin：它表示是否更新代理后请求的 headers 中host地址。<br>4.2 原理<br>proxy工作原理实质上是利用http-proxy-middleware 这个http代理中间件，实现请求转发给其他服务器。比如下面的例子：<br>const express &#x3D; require(‘express’);<br>const proxy &#x3D; require(‘http-proxy-middleware’);<br>const app &#x3D; express();<br>app.use(‘&#x2F;api’, proxy({target: ‘<a target="_blank" rel="noopener" href="http://www.example.org/">http://www.example.org</a>‘, changeOrigin: true}));<br>app.listen(3000);<br>&#x2F;&#x2F; <a target="_blank" rel="noopener" href="http://localhost:3000/api/foo/bar">http://localhost:3000/api/foo/bar</a> -&gt; <a target="_blank" rel="noopener" href="http://www.example.org/api/foo/bar">http://www.example.org/api/foo/bar</a></p>
<p>在上面的例子中，本地地址为<a href="http://localhost:3000，该浏览器发送一个前缀带有/api标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中。">http://localhost:3000，该浏览器发送一个前缀带有/api标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中。</a><br>4.3 跨域<br>在开发阶段， webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上。所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题。<br>解决这种问题时，只需要设置webpack proxy代理即可。当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地，原理图如下：</p>
<p>在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能</p>
<h2 id="5-webpack-dev-server-和-http服务器的区别"><a href="#5-webpack-dev-server-和-http服务器的区别" class="headerlink" title="5. webpack-dev-server 和 http服务器的区别"></a>5. webpack-dev-server 和 http服务器的区别</h2><p>webpack-dev-server使用内存来存储webpack开发环境下的打包文件，并且可以使用模块热更新，比传统的http服务对开发更加有效。提高Webpack的构建速度</p>
<h2 id="6-webpack的热更新原理是怎样的？"><a href="#6-webpack的热更新原理是怎样的？" class="headerlink" title="6. webpack的热更新原理是怎样的？"></a>6. webpack的热更新原理是怎样的？</h2><ol>
<li>Webpack 通过 Watch 模式可以侦听文件的变化，当文件发生改变时，会根据配置进行重新编译（Compile），并将编译后的代码保存在内存中。</li>
<li>webpack-dev-server 也会对文件变化进行监控（需要配置 devServer.watchContentBase &#x3D; true），但不会进行重新编译，而是监听这些配置文件中静态文件的变化，变化后会通知浏览器进行直接刷新，而不是 HMR。</li>
<li>在浏览器和服务端之间有一个通过 SocketJs 建立的 websocket 长连接。webpack-dev-server 会将 Webpack 编译打包时的各个阶段的状态信息和 hash 值一并告知 webpack-dev-server&#x2F;client（位于浏览器端）。</li>
<li>但是 webpack-dev-server&#x2F;client 并不能够请求更新的代码，而是把这些工作交给了 webpack&#x2F;hot&#x2F;dev-server，webpack&#x2F;hot&#x2F;dev-server 的工作就是根据 webpack-dev-server&#x2F;client 传来的信息以及 dev-server 的配置决定是刷新浏览器还是 HMR。</li>
<li>HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到 webpack&#x2F;hot&#x2F;dev-server 传递的新模块的 hash 值，通过 JsonpMainTemplate.runtime 向 webpack-dev-server 发送 Ajax 请求获取到返回的 Json，该 Json 包含了所有要更新的模块的 hash 值，之后通过 Jsonp 请求，获取到最新的模块代码。</li>
<li>接下来，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。</li>
<li>如果 HMR 失败，则通过刷新浏览器来获取最新打包代码。</li>
</ol>
<h1 id="六、-基本配置"><a href="#六、-基本配置" class="headerlink" title="六、 基本配置"></a>六、 基本配置</h1><h2 id="1-entry的值有几种数据类型？"><a href="#1-entry的值有几种数据类型？" class="headerlink" title="1. entry的值有几种数据类型？"></a>1. entry的值有几种数据类型？</h2><p>字符串（单入口）<br>数组（多入口）<br>object(object中的key在webpack里相当于此入口的name)</p>
<h2 id="2-webpack如何配置多入口文件？"><a href="#2-webpack如何配置多入口文件？" class="headerlink" title="2. webpack如何配置多入口文件？"></a>2. webpack如何配置多入口文件？</h2><p>● 配置多入口entry<br>○<br>● 配置出口output<br>○ filename 中的 [name] 对应入口的文件名；<br>○ contentHash 会命中缓存，提高性能；<br>○<br>● 配置插件htmlWebpackPlugin，生成多页面<br>○ htmlWebpackPlugin 插件会生成页面。<br>○ chunk 为代码块，默认引入 entry 中所有文件。<br>○</p>
<h2 id="3-webpack-config-js能不能做拆分？"><a href="#3-webpack-config-js能不能做拆分？" class="headerlink" title="3. webpack.config.js能不能做拆分？"></a>3. webpack.config.js能不能做拆分？</h2><p>可以<br>将webpack.config.js 配置文件进行分开。分成三个配置文件，如下：</p>
<ol>
<li><p>webpack.base.config.js：两个环境公共的部分</p>
</li>
<li><p>webpack.dev.config.js：开发环境独有的配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack.prod.config.js`：生产环境独有的配置</span><br></pre></td></tr></table></figure>
</li>
<li><p>output的对象中的常见属性有哪些?</p>
<p>output 是一个 object 对象，其中包含一系列的配置项，其中比较重要的是 filename 和 path。</p>
<p>● output.filename：配置输出文件的名称，指定一个 string 类型的值。如果只有一个输出文件，则可以把它写成静态不变的。</p>
<p>● output.path ：配置输出文件存放在本地的目录，是一个 string 类型的绝对路径。通常通过 Node.js 的 path 模块去获取绝对路径。</p>
<p>在 webpack.config.js 配置文件中，一个 entry 对应一个 output。</p>
<h1 id="七、-区别"><a href="#七、-区别" class="headerlink" title="七、 区别"></a>七、 区别</h1><h2 id="1-babel-runtime和babel-polyfill的区别"><a href="#1-babel-runtime和babel-polyfill的区别" class="headerlink" title="1. babel-runtime和babel-polyfill的区别"></a>1. babel-runtime和babel-polyfill的区别</h2><p>● babel-polyfill</p>
<p>○ 原理是当运行环境中并没有实现的一些方法，babel-polyfill 会给其做兼容。 但是这样做也有一个缺点，就是会污染全局变量，而且项目打包以后体积会增大很多，因为把整个依赖包也搭了进去。所以并不推荐在一些方法类库中去使用。</p>
<p>○ babel-polyfill 可以用来转码，因为 babel-polyfill 是直接在原型链上增加方法。</p>
<p>● babel-runtime</p>
<p>○ 为了不污染全局对象和内置的对象原型，但是又想体验使用新鲜语法的快感。就可以配合使用babel-runtime和babel-plugin-transform-runtime。 比如当前运行环境不支持promise，可以通过引入babel-runtime&#x2F;core-js&#x2F;promise来获取promise， 或者通过babel-plugin-transform-runtime自动重写你的promise。也许有人会奇怪，为什么会有两个runtime插件，其实是有历史原因的：刚开始开始只有babel-runtime插件，但是用起来很不方便，在代码中直接引入helper 函数，意味着不能共享，造成最终打包出来的文件里有很多重复的helper代码。所以，Babel又开发了babel-plugin-transform-runtime，这个模块会将我们的代码重写，如将Promise重写成_Promise（只是打比方），然后引入_Promise helper函数。这样就避免了重复打包代码和手动引入模块的痛苦。</p>
<p>○ babel-runtime 不能转码实例方法</p>
</li>
</ol>
<h2 id="2-除了Webpack外，你还了解哪些模块管理工具"><a href="#2-除了Webpack外，你还了解哪些模块管理工具" class="headerlink" title="2. 除了Webpack外，你还了解哪些模块管理工具"></a>2. 除了Webpack外，你还了解哪些模块管理工具</h2><p>webpack:<br>就目前而言，webpack已是最常用的打包工具，webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。<br>gulp：<br>gulp是一个前端自动化构建工具，强调的是前端开发的工作流程，可以通过配置一系列的task，第一task处理的事情（如代码压缩，合并，编译以及浏览器实时更新等）。然后定义这些执行顺序，来让glup执行这些task，从而构建项目的整个开发流程。自动化构建工具并不能把所有的模块打包到一起，也不能构建不同模块之间的依赖关系。</p>
<p>grunt：<br>是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。<br>Rollup</p>
<ol>
<li>Rollup 是一款 ES Modules 打包器， 从作用上来看，Rollup 与 Webpack 非常类似。不过相比于 Webpack，Rollup要小巧的多<br>现在很多我们熟知的库都都使用它进行打包，比如：Vue、React和three.js等<br>Parcel<br>Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序<br>Parcel 跟 Webpack 一样都支持以任意类型文件作为打包入口，但建议使用 HTML文件作为入口，该HTML文件像平时一样正常编写代码、引用资源。<br>模块化是一种处理复杂系统分解为更好的可管理模块的方式。可以用来分割、组织和打包应用。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体。<br>在前端领域中，除了Webpack外，比较流行的模块打包工具还包括Rollup、Parcel、snowpack和最近风靡的Vite。<br>2.1. Rollup<br>Rollup 是一款 ES Modules 打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。从作用上来看，Rollup 与 Webpack 非常类似。不过相比于 Webpack，Rollup 要小巧的多。现在很多苦都使用它进行打包，比如：Vue、React和three.js等。<br>使用之前，可以使用npm install —global rollup 命令进行安装。Rollup 可以通过命令行接口(command line interface)配合可选配置文件(optional configuration file)来调用，或者可以通过 JavaScript API来调用。运行 rollup —help 可以查看可用的选项和参数。<br>2.2. Parcel<br>Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序。<br>2.3. Vite<br>Vite是Vue的作者尤雨溪开发的Web开发构建工具，它是一个基于浏览器原生ES模块导入的开发服务器，在开发环境下，利用浏览器去解析import，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随启随用。同时不仅对Vue文件提供了支持，还支持热更新，而且热更新的速度不会随着模块增多而变慢。<br>Vite具有以下特点： - 快速的冷启动 - 即时热模块更新（HMR，Hot Module Replacement） - 真正按需编译<br>Vite由两部分组成： - 一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的 [模块热更新HMR。 - 一套构建指令，它使用 Rollup打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源。<br>Vite在开发阶段可以直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快。当浏览器请求某个模块的时候，根据需要对模块的内容进行编译，大大缩短了编译时间。工作原理如下图所示。<br>在热模块HMR方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像Webpack那样需要把该模块的相关依赖模块全部编译一次，因此效率也更高。</li>
<li>webpack，rollup，parcel优劣？(了解)<br>对比<br>Webpack<br>Rollup<br>Parcel<br>功能</li>
</ol>
<p>为处理资源管理和分割代码而生，可以用来处理任何类型的文件，灵活，插件多。<br>用标准化的格式（es6）来写代码，通过减少死代码尽可能地缩小包体积。<br>用标准化的格式（es6）来写代码，通过减少死代码尽可能地缩小包体积。<br>配置<br>webpack需要配config文件，指明entry, output, plugin，transformations。<br>rollup需要配config文件，指明entry, output, plugin，transformations。rollup 有对import&#x2F;export所做的node polyfills，webpack没有。rollup支持相对路径，而webpack没有，所以得使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parcel则是完全开箱可用的，不用配置。</span><br></pre></td></tr></table></figure>

<p>入口文件<br>webpack只支持js文件作为入口文件，如果要以其他格式的文件作为入口，比如html文件为入口，如要加第三方Plugin。<br>rollup可以用html作为入口文件，但也需要plugin，比如rollup-plugin-html-entry。<br>parcel可以用index.html作为入口文件，而且它会通过看index.html的script tag里包含的什么自己找到要打包生成哪些js文件。<br>transformations<br>transformations指的是把其他文件转化成js文件的过程，需要经过transformation才能够被打包。webpack使用Loaders来处理。<br>rollup使用plugins来处理。<br>parcel会自动去转换，当找到配置文件比如.babelrc, .postcssrc后就会自动转。<br>摇树优化<br>摇树优化是webpack的一大特性。需要1，用import&#x2F;export语法，2，在package.json中加副作用的入口，3，加上支持去除死代码的缩小器（uglifyjsplugin）。<br>rollup会统计引入的代码并排除掉那些没有被用到的。这使您可以在现有工具和模块的基础上构建，而无需添加额外的依赖项或膨胀项目的大小。<br>parcel不支持摇树优化。<br>dev server<br>webpack用webpack-dev-server。</p>
<p>rollup用rollup-plugin-serve和rollup-plugin-livereload共同作用。<br>parcel内置的有dev server<br>热更新<br>webpack的 wepack-dev-server支持hot模式。<br>rollup不支持hmr。<br>parcel有内置的hmr。<br>代码分割<br>webpack通过在entry中手动设置，使用CommonsChunkPlugin，和模块内的内联函数动态引入来做代码分割。<br>rollup有实验性的代码分割特性。它是用es模块在浏览器中的模块加载机制本身来分割代码的。需要把experimentalCodeSplitting 和 experimentalDynamicImport 设为true。<br>parcel支持0配置的代码分割。主要是通过动态improt。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-webpack/webpack高级" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/11/28/webpack/webpack%E9%AB%98%E7%BA%A7/" class="article-date">
  	<time datetime="2020-11-28T03:57:49.000Z" itemprop="datePublished">2020-11-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/28/webpack/webpack%E9%AB%98%E7%BA%A7/">
        webpack高级
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="webpack高级篇"><a href="#webpack高级篇" class="headerlink" title="webpack高级篇"></a>webpack高级篇</h1><p>完善配置以及常用并强大的工具</p>
<h2 id="一-如何提高开发效率与完善团队开发规范"><a href="#一-如何提高开发效率与完善团队开发规范" class="headerlink" title="一.如何提高开发效率与完善团队开发规范"></a>一.如何提高开发效率与完善团队开发规范</h2><p><strong>source-map</strong><br>debug  将打包好的bundle.js里的报错内容和我们源代码index.js文件进行关联<br>webpack已经内置了source-map的功能   只要我们简单的配置一下就可以开启它了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtool:&quot;inline-source-map&quot;  //通过devtool去复制一个值就可以开启 source-map</span><br></pre></td></tr></table></figure>
<p>七种source-map：<br><img src="http://hghqz.vip/webpack/source-map.jpg" alt="source-map" title="source-map"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm install webpack webpack-cli webpack-dev-server html-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<p>eval模式：每个module会封装到eval里包裹起来执行，并且会在末尾追加注释 &#x2F;&#x2F;@sourceURL<br>默认情况下 没有配置source-map  webpack会帮助我们在开发环境下面去设置一个source-map默认值，eval。所以我们在浏览器上才能精准的锁定我们代码的行数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">devtool:false      // 关闭source-map   浏览器锁定的是在打包后bundle.js文件中的位置</span><br><span class="line">devtool:&#x27;eval&#x27;</span><br><span class="line">devtool:&#x27;source-map&#x27;    //它可以生成一个SourceMap我文件其他的功能会保持eval的功能</span><br><span class="line">devtool:&#x27;hidden-source-map&#x27;  //和source-map一样，但不会在bundle末尾追加注释      那么就不能有锁定代码行数了   但是它会生成一个.map文件  连着不关联了</span><br><span class="line">devtool:&#x27;inline-source-map&#x27;   //生成一个DataUrl形式的SourceMap文件  没有map文件了  指向data64格式</span><br><span class="line">devtool:&#x27;eval-source-map&#x27;   // 每个module会通过eval()来执行，并且生成一个DataUrl形式的SourceMap</span><br><span class="line">devtool:&#x27;cheap-source-map&#x27;   // 它会生成一个没有列信息的SourceMaps文件，不包含loader的sourcemap    只保留代码的行数不去记录代码的列数    可以减少生成的map文件的大小</span><br><span class="line">devtool:&#x27;cheap-module-source-map&#x27; //生成一个没有列信息的SourceMaps文件，同时loader的sourcemap也被简化为只包含对应行的信息。       **推荐使用**</span><br></pre></td></tr></table></figure>

<p><strong>devServer</strong><br>在开发环境下我们往往要启动一个web服务，方便我们模拟一个用户从浏览器中访问我们的web服务，读取我们的打包产物，以观测我们的代码在客户端的表现。webpack内置了这样的功能，我们只需要简单的配置就可以开启它了。<br>npm install webpack-dev-server -D</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">//为了在浏览器看到效果配置插件</span><br><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">devServer:&#123;</span><br><span class="line">	static: path.resolve(__dirname,&#x27;./dist&#x27;)  // 指向我们当前服务的物理路径</span><br><span class="line">	compress:true  // 可以设置我们是不是在服务器端进行代码压缩 使他在传输过程中可以减少传输的这个数据的大小浏览器请求头   Content-Encoding:gzip  保证我们从服务器到浏览器传输的过程中这个文件是压缩的。从而提高我们的传输效率。</span><br><span class="line">	port :3000  //  配置端口号</span><br><span class="line">	// 添加响应头 在有些场景需求下，我们需要通过http传输给我们浏览器，为所有响应添加headers，来对资源的请求和响应打入标志，以便做一些安全规范，或者方便发生异常后做请求的链路追踪</span><br><span class="line">	headers:&#123;</span><br><span class="line">		&#x27;X-Access-token&#x27;:&#x27;啊师傅撒大附件是辣的回复&#x27;</span><br><span class="line">	&#125;</span><br><span class="line">	//开启代理，在我们打包出来的js bundle里有时会含有一些对特定接口的网络请求(ajax/fetch),比如：我们的客户端地址实在http://localhost:3000下，加入我们的接口来自http://localhost:4001/,那么毫无疑问，此时的控制台会报错来提示你跨域。  解决：在开发环境下，我们可以使用devServer自带的proxy功能。</span><br><span class="line">	const http = require(&#x27;http&#x27;)</span><br><span class="line">	cosnt app = http.createServer((request,response)=&gt;&#123;</span><br><span class="line">		if (request.url===&#x27;/api/hello&#x27;)&#123;</span><br><span class="line">			response.end(&#x27;hello mode&#x27;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;) 创建服务</span><br><span class="line">	app.listen(9000，&#x27;服务器的名字域名localhost可以省略&#x27;,()=&gt;&#123;</span><br><span class="line">		console.log(&#x27;提醒用户  9000端口开放&#x27;)</span><br><span class="line">	&#125;)  //监听app</span><br><span class="line">	node server.js启动服务</span><br><span class="line">	fetch(&#x27;/api/hello&#x27;) //返回一个promise</span><br><span class="line">	.then(response=&gt;response.text) // 将返回内容变成一个文本</span><br><span class="line">	.then(reuslt=&gt;&#123;</span><br><span class="line">		console.log(&#x27;result&#x27;)</span><br><span class="line">	&#125;)</span><br><span class="line">	peoxy解决跨域</span><br><span class="line">	proxy:&#123;  //proxy对象 里边可以写很多的所谓的访问的路径（暗号）</span><br><span class="line">		&#x27;/api&#x27;:&#x27;http://localhost:9000&#x27;  //当用户请求资源为/api时  把它指向到一个新的服务器上去</span><br><span class="line">	&#125;</span><br><span class="line">	//  https配置  我们在本地访问时将http变为https</span><br><span class="line">	https:true   //由于默认配置使用的时自签名证书  所以有得浏览器会告诉你时不安全的，但我们依然可以继续访问它。当然我们也可以提供自己的证书</span><br><span class="line">	https:&#123;</span><br><span class="line">		cacert:&quot;./server.pem&quot;,</span><br><span class="line">		pfx:&quot;./server.pfx&quot;,</span><br><span class="line">		key:&quot;./server.key&quot;,</span><br><span class="line">		cert:&#x27;./server.crt&#x27;,</span><br><span class="line">		passphrase:&quot;webpack-dev-server&quot;,</span><br><span class="line">		requestCert:true</span><br><span class="line">	&#125;</span><br><span class="line">	// http2 自带https的自签名证书  仍然可以通过https来访问我们的项目</span><br><span class="line">	http2:true</span><br><span class="line">	// historyApiFallback  如果我们的应用是个SPA（单页面应用），但路由到/some时（可以直接在地址栏里输入），会发现此时刷新页面后，控制台会报错。  原因：浏览器把这个路由当作了静态资源地址去请求，然后我们并没有打包出/some这样的资源，所以这个访问时404。  解决：可以通过配置来提供页面代替任何404的静态资源。</span><br><span class="line">	historyApiFallback:true</span><br><span class="line">	// 此时重启服务刷新后发现请求变成了index.html。当然，在多数业务场景下，我们需要根据不同的访问路径定制替代的页面，  可以使用rewrites这个配置项</span><br><span class="line">	historyApiFallback:&#123;</span><br><span class="line">		rewrites:[</span><br><span class="line">			&#123;form:/^\/$/,to:&#x27;asd.html&#x27;&#125;,  //正则获取路径</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">	//开发服务器主机   如果你在开发环境中起了一个devserver服务，并期望你的同事能访问它，</span><br><span class="line">	devServer:&#123;</span><br><span class="line">		host:0.0.0.0</span><br><span class="line">	&#125;//这是如果你的同事和你处于一个局域网的话，就可以通过局域网ip来访问你的服务了</span><br><span class="line">&#125;</span><br><span class="line">plugins:[</span><br><span class="line">	new HtmlWebpackPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>模块热替换与热加载</strong><br>模块热替换：(HMR - hot module replacement)功能会在应用程序运行过程中，替换 添加或删除 模块，而无需重新加载整个页面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">	hot:true</span><br><span class="line">&#125;</span><br><span class="line">if (module.hot)&#123;</span><br><span class="line">	module.hot.accept(&#x27;./input.js&#x27;,()=&gt;&#123;</span><br><span class="line">		console.log(123)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line">//css并不需要做这个开关  是因为css-loader已经帮助我们完成这个工作了</span><br></pre></td></tr></table></figure>
<p>热加载（文件更新时，自动刷新我们的服务和页面）新版的webpack-dev-server默认开启热加载的功能，它对应的参数是devServer.liveReload ,默认为true。  如果想要关掉它,liveReload这是为false同时也要关掉hot</p>
<p><strong>Eslint</strong><br>eslint是用来扫描我们所写的代码是否符合规范的工具，往往我们的项目是多人协作开发的，我们期望同一的代码规范，这时候可以让eslint来对我们进行约束。严格意义上来说，eslint配置跟webpack无关，但在工程化环境中，它往往是不可或缺的。<br>npx exlint –init<br>会给我们三个选项（说明我们在使用的时候用那种方式）：1.仅仅检查语法错误，2.不但可以检查语法而且还可以发现问题，3.既可以检查语法，发现问题，还可以规范我们代码的格式。<br>之后是问我们在项目中到底使用那种模块化的开发方式：   es6  commonJS  什么都不用<br>我们在项目中使用的是那种框架：React  Vue.js  没有使用   第三篇讲解webpack如何与react  vue进行合作<br>项目中是否使用ts<br>代码是运行在哪里的   browser浏览器  还是node后端<br>在项目中到底如何去配置代码规范   1.选择一些流行的代码格式（使用第一个）， 2.实现一问一答的方式来配置，3.导入一个我们自有的文件<br>配置文件放在什么地方  javascript  yaml   json<br>生成.eslintrc.json文件<br><img src="http://hghqz.vip/webpack/exlint%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9.jpg" alt="exlint配置选项" title="exlint配置选项"><br>env：脚本的运行环境<br>extends  ：检查代码格式的文件<br>parserOptions ： 指定ecmaVersion的版本  sourceType：module<br>rules：启用规则以及各自的错误级<br>globals：可以在执行脚本的期间访问一些额外的全局变量，这些全局变量是不在环境中定义的变量。<br>npx eslint 文件夹或文件<br>使用vscode 的eslint插件  就会告诉我们哪里不符合规范 出现了问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;rules&quot;:&#123;</span><br><span class="line">		&quot;no-console&quot;:0, //关闭no-console提示</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合webpack来实现eslint<br>我们期望eslint能够实时提示报错而不必等待执行命令，这个功能可以通过给自己的IDE（代码编辑器）安装对应的eslint插件来实现，然而，不是每个IDE都有插件，如果不想使用插件，又想实现实时提示报错，那么我们可以结合webpack的打包编译功能来实现。<br>在打包js文件之前，通过eslint-loader以及babel-loader来进行处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">	client:&#123;</span><br><span class="line">		overlay:false,   // 浏览器不在有覆盖层eslint错误提示</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">module:&#123;</span><br><span class="line">	rules:[</span><br><span class="line">		&#123;</span><br><span class="line">			test:/\.js$/,</span><br><span class="line">			use:[&#x27;babel-loader&#x27;,&#x27;eslint-loader&#x27;]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>git-hooks与husky</strong><br>为了保证团队里的开发人员提交的代码符合规范，我们可以在开发者上传代码的时候进行校验。我们常用husky来协助进行代码提交时的eslint校验。在使用husky前，我们先来研究一下git-hooks.<br>husky时基于git-hooks git的钩子来实现的</p>
<p>git –version<br>git init<br>ls -la<br>.gitignore  在git提交时有一些文件不需要提交<br>**&#x2F;node_modules<br>git status  查看当前git的状态   可以看到文件都没有进行本地的仓库的添加的            可以查看到修改了那些文件<br>git add . 添加到缓存区   git commit -m ‘init’  所有代码添加到了本地仓库   并没有关联远端的仓库<br>cd .git  ls -la   cd hooks  ls -la<br>.sample的扩展名文件，这些文件都是git的hooks    hook就是我们在执行命令的时候需要提前或者之后去执行的一些命令这些命令时自动执行的   只要配置好   git会帮助我们运行。<br>需求：在每次git提交的时候来检查代码的问题。   可以运行eslint  钩子可以采用pre-commit-sample<br>cat pre-commit-sample   浏览文件   如果想要指定它或者时让他生效我们可以修改文件名  .sample是不能起作用的我们想要起作用必须重新创建一个文件pre-commit<br>touch  pre-commit   这个文件我们就可以事先写一写shell脚本  当commit实行的时候这些脚本就会被提前运行<br>vim pre&#x3D;commit       &#x2F;&#x2F;编辑这个文件   i进行输入  echo pre-commit   esc退出  :wq<br>修改文件的读写权限  chmod +x .&#x2F;pre-commit   &#x2F;&#x2F;添加写权限<br>脚本  ：  d+d删除当前行  i（insert）插入   npx eslint .&#x2F;src<br>在团队开发时不对代码做任何处理    只有在我们代码提交到git仓库时在进行校验<br>问题：如果把git的配置放在.git文件夹里那个文件夹每个人的配置都是不一样的   也没有办法把配置放到git仓库里   那我们需要把这个配置放置到项目的根目录下<br>文件以.开头表示这个文件是隐藏的<br>.mygithooks  .pre-commit   希望我们在git提交的时候读取的不是我们在git默认的hooks里面配置的pre-commit 而是读取我们项目中的pre-commit   通过git配置实现   git config core.hooksPash .mygithooks  会自动读取文件夹中约定好的pre-commit这个文件名<br>vim .git&#x2F;config   &#x2F;&#x2F;查看我们刚才通过命令行添加的命令<br>chmod +x .mygithooks&#x2F;pre-commit   ls -la查看文件权限<br>现在都是通过手工去完成的    我们可以通过现成的工具(husky)来完成<br>vim .git&#x2F;config   删除刚才的配置<br>npm install husky -D<br>npx husky install &#x2F;&#x2F;执行  让我们的命令行hook生效   会在当天目录下面创建.husky文件夹<br>自己配置一个脚本 “prepare” : husky install  它会实现到我们的一些命令执行之前去安装我们的husky<br>npx husky add .husky&#x2F;per-commit 在.husky下创建pre-commit文件   npx eslint .&#x2F;src<br>添加权限</p>
<h2 id="二-模块与依赖"><a href="#二-模块与依赖" class="headerlink" title="二.模块与依赖"></a>二.模块与依赖</h2><p>在模块化的编程中  开发者会将程序分解为功能离散的一些文件   我们把这些文件称之为模块  每个模块都很轻量  这使得我们项目的验证  调试以及测试会变得轻而易举。  这些精心编写得模块提供了可靠的抽象和封装界限。使得我们应用程序的每个模块都具备了调理清晰的设计和明确的目的。<br>nodejs从一开始就支持模块化的编程  但是浏览器端的模块化还在缓慢的支持中。大多数浏览器支持esm模块化。<br>能在webpack工程化的环境里成功导入的模块都应该视做为webpack模块。与nodejs项目webpack模块能以各种方式来表达它的利害关系。<br>es6 import from          nodejs  module  require              AMD   define  require<br>css,scss,less,assets这些文件里的@import语句     和样式里的url资源  这些都是webpack应用的模块<br>webpack模块解析简易原理：webpack将js,css,less,scss,img,html等文件  通过loader+module(内置模块)  的方法解析成模块化的文件。<br>这个打包编译的解析过程是怎么完成的：webpack执行会返回一个描述webpack打包编译的整个流程的一个对象我们将这个对象称之为compiler,compiler对象描述的是整个webpack打包的流程，它内置打包状态，随着打包过程的进行  状态也实施的发生变化。同时会触发相应状态的webpack生命周期钩子，我们可以将它类比成一个promise对象，这个状态从打包前，打包中到打包完成或者打包失败都是通过这个过程完成的，每一个webpack打包都是创建一个compiler对象，它会走完整个声明周期的过程。而webpack中所有的模块解析都是compiler对象内置模块的解析器去做的，通过这个对象的属性resolvers解析器主题主题功能就是解析模块它是基于enhanced-resolve这个包来实现的，在webpack中无论使用怎样的模块引用语句本质其实都是调用这个包的api来进行模块的构建解析的</p>
<p><strong>模块解析(resolve)</strong><br>webpack是通过Resolves实现了模块之间的依赖和引用。在打包的时候，webpack使用enhanced-resolve来解析文件路径（webpack_resolver的代码实现很有思想，webpack基于次进行treeshaking。）<br>webpack可以解析三种文件路径：1.绝对路径（相对于项目的根目录&#x2F;）    2.相对路径（相对于当前文件.&#x2F;）    3.模块路径（全局的node_modules文件）(不用&#x2F;  或  .&#x2F;它会自动到node_modules中找模块)<br>可以给某个路径或某个文件夹下的目录去起个别名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">resolve:&#123;</span><br><span class="line">	alias:&#123;</span><br><span class="line">		&#x27;@&#x27;: path.resulve(__dirname,&#x27;./src&#x27;)   // @指向src目录</span><br><span class="line">	&#125;,</span><br><span class="line">	extensions: [&#x27;.json&#x27;,&#x27;js&#x27;,&#x27;.vue&#x27;]   //优先请求 .json的后缀。(不配置该选项默认请求.js)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>外部扩展(Externals)</strong><br>有时候我们会为了减小bundle的体积，从而把一些不变的第三方库用cdn的形式引入进来，比如jquery：index.html。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">externalsType:&#x27;script&#x27;,</span><br><span class="line">externals:&#123;   //他是一个对象   可以去定义我们的外部一些第三方包</span><br><span class="line">	jquery:&#x27;jQuery($)&#x27;      //key 的名字一定要和  其他地方引用的报名一样，值是我们在window对象上面去暴露的一个对象        // 无法正常运行  jquery没有定义    需要在index.html收到导入script标签</span><br><span class="line">	jquery:[</span><br><span class="line">		&#x27;cdn地址&#x27;,   //jquery  script标签  将来要放到的页面的连接</span><br><span class="line">		&#x27;jQuery($)&#x27;   //表示  这个script在浏览器上面暴露的一个对象</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>依赖图(dependency graph)</strong><br>每当一个文件依赖另一个文件时，webpack会直接将文件视为存在依赖关系。这使得webpack可以获取非代码资源，如image或web字体等，并会把他们作为 依赖 提供给应用程序，当webpack开始工作时，它会根据我们写好的配置，从 入口（entry）开始，webpack会递归的构建一个 依赖关系图，这个依赖关系图包含着应用程序中所需的每个模块，然后将所有模块打包为bundle(也就是output配置项)<br>单纯将可能很抽象，我们更期望能够可视化打包产物的依赖图，  bundle分析工具：<br>官网分析工具   第三方工具：webpack-chart   webpack-visualizer    webpack-bundle-analyzer    webpack bundle  optimize helper       bundle-stats<br><img src="http://hghqz.vip/webpack/bundle%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7.jpg" alt="bundle分析工具" title="bundle分析工具"><br>npm install webpack-bundle-analyzer -D</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const &#123; BundleAnalyzerPlugin &#125; = require(&#x27;webpack-bundle-analyzer&#x27;)</span><br><span class="line">plugins:&#123;</span><br><span class="line">	new BundleAnalyzerPlugin()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三-扩展功能"><a href="#三-扩展功能" class="headerlink" title="三.扩展功能"></a>三.扩展功能</h2><p>PostCSS和css模块，Web Works,Typescript<br><img src="http://hghqz.vip/webpack/PostCSs%E4%B8%8Ecss%E6%A8%A1%E5%9D%97.jpg" alt="PostCSS与css模块" title="PostCSS与css模块"></p>
<p>postcss : 1.可以给样式添加前缀兼容浏览器   2.可以在样式里书写一些关于嵌套的功能  它可以编译成浏览器能够识别的样式。<br>css模块：解决页面class引用次数多，或引用别人的样式 名重复，可以使用css模块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss-loader -D</span><br><span class="line">npm install autoprefixer -D   //帮助我们去加载一些样式的前缀</span><br><span class="line">webpack.config.js</span><br><span class="line">module:&#123;</span><br><span class="line">	rules:[</span><br><span class="line">		&#123;</span><br><span class="line">			test:/\.css$/,</span><br><span class="line">			use:[</span><br><span class="line">				&#x27;style-loader&#x27;,</span><br><span class="line">				&#x27;css-loader&#x27;,</span><br><span class="line">				&#x27;postcss-loader&#x27;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line">postcss.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	plugins:[</span><br><span class="line">		require(&#x27;autoprefixer&#x27;),</span><br><span class="line">		require(&#x27;postcss-nested&#x27;)   //嵌套</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line">package.json</span><br><span class="line">&quot;browerlist&quot;:[</span><br><span class="line">	&quot;&gt;1%&quot;,   //应用在全球浏览器大于1%的浏览器上</span><br><span class="line">	&quot;last 2 versions&quot;  //每个浏览器的最新的两个版本</span><br><span class="line">]</span><br><span class="line">// css模块实现</span><br><span class="line">rules:[</span><br><span class="line">	&#123;</span><br><span class="line">		test:/\.css$/,</span><br><span class="line">		use:[</span><br><span class="line">			&#x27;tyle-loader&#x27;,</span><br><span class="line">			&#123;</span><br><span class="line">				loader:&#x27;css-loader&#x27;,</span><br><span class="line">				options:&#123;</span><br><span class="line">					modules:true        //开启css模块</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			&#x27;postcss-loader&#x27;,</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">//获取hash字符串  将css文件当成一个模块</span><br><span class="line">import style from &#x27;./asasd.css&#x27;</span><br><span class="line">console.log(style)</span><br><span class="line">样式为：style.class名</span><br><span class="line">配置部分开启css模块  css module模式  ，全局样式.global不开启css模块 不同模式。</span><br><span class="line"></span><br><span class="line">// css module</span><br><span class="line">&#123;</span><br><span class="line"> test: new RegExp(`^(?!.*\\.global).*\\.css`),</span><br><span class="line"> use: [</span><br><span class="line"> &#123;</span><br><span class="line">   loader: &#x27;style-loader&#x27;</span><br><span class="line"> &#125;，</span><br><span class="line"> &#123;</span><br><span class="line">   loader: &#x27;css-loader&#x27;,</span><br><span class="line">   options: &#123;</span><br><span class="line">    modules: true,</span><br><span class="line">    localIdentName: &#x27;[hash:base64:6]&#x27;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">   loader: &#x27;postcss-loader&#x27;</span><br><span class="line"> &#125;</span><br><span class="line">],</span><br><span class="line"> exclude:[path.resolve(__dirname, &#x27;..&#x27;, &#x27;node_modules&#x27;)]</span><br><span class="line">&#125;</span><br><span class="line">// 普通模式</span><br><span class="line">&#123;</span><br><span class="line"> test: new RegExp(`^(.*\\.global).*\\.css`),</span><br><span class="line"> use: [</span><br><span class="line"> &#123;</span><br><span class="line">   loader: &#x27;style-loader&#x27;</span><br><span class="line"> &#125;，</span><br><span class="line"> &#123;</span><br><span class="line">   loader: &#x27;css-loader&#x27;,</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">   loader: &#x27;postcss-loader&#x27;</span><br><span class="line"> &#125;</span><br><span class="line">],</span><br><span class="line"> exclude:[path.resolve(__dirname, &#x27;..&#x27;, &#x27;node_modules&#x27;)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Web Works</strong><br>有时我们需要在客户端进行大量的运算，但又不想让它阻塞我们的js主线程。你可能<br>第一时间考虑到的是异步。<br>但事实上，运算量过大(执行时间过长)的异步也会阻塞js事件循环，甚至会导致浏览<br>器假死状态。<br>这时候，HTML5的新特性 WebWorker就派上了用场。<br>在此之前，我们简单的了解下这个特性。<br>html5之前，打开一个常规的网页，浏览器会启用几个线程？<br>一般而言，至少存在三个线程(公用线程不计入在内):<br>分别是js引擎线程(处理js)、GUI渲染线程(渲染页面)、浏览器事件触发线程(控制交<br>互)。<br>当一段JS脚本长时间占用着处理机,就会挂起浏览器的GUI更新，而后面的事件响应也<br>被排在队列中得不到处理，从而造成了浏览器被锁定进入假死状态。<br>现在如果遇到了这种情况，我们可以做的不仅仅是优化代码————html5提供了解<br>决方案，webworker。<br>webWorkers提供了js的后台处理线程的API，它允许将复杂耗时的单纯js逻辑处理放<br>在浏览器后台线程中进行处理，让js线程不阻塞UI线程的渲染。<br>多个线程间也是可以通过相同的方法进行数据传递。<br>它的使用方式如下：<br>也就是说，需要单独写一个js脚本，然后使用new Worker来创建一个Work线程实<br>例。<br>这意味着并不是将这个脚本当做一个模块引入进来，而是单独开一个线程去执行这个<br>脚本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   loader: &#x27;css-loader&#x27;,</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">   loader: &#x27;postcss-loader&#x27;</span><br><span class="line"> &#125;</span><br><span class="line">],</span><br><span class="line"> exclude:[path.resolve(__dirname, &#x27;..&#x27;, &#x27;node_modules&#x27;)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;new Worker(scriptURL: string | URL, options?: WorkerOptions)<br>new Worker(“someWorker.js”);</p>
<p>我们知道，常规模式下，我们的webpack工程化环境只会打包出一个bundle.js，那<br>我们的worker脚本怎么办？<br>也许你会想到设置多入口(Entry)多出口(ouotput)的方式。<br>事实上不需要那么麻烦，webpack4的时候就提供了worker-loader专门配置<br>webWorker。<br>令人开心的是，webpack5之后就不需要用loader啦，因为webpack5内置了这个功<br>能。<br>我们来试验一下：<br>第一步<br>创建一个work脚本 work.js,我们甚至不需要写任何内容，我们的重点不是<br>webWorker的使用，而是在webpack环境中使用这个特性。<br>当然，也可以写点什么，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.onmessage = (&#123; data: &#123; question &#125; &#125;) =&gt; &#123;</span><br><span class="line"> self.postMessage(&#123;</span><br><span class="line">  answer: 42,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 index.js 中使用它</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 下面的代码属于业务逻辑</span><br><span class="line">const worker = new Worker(new URL(&#x27;./work.js&#x27;, import.meta.url));</span><br><span class="line">worker.postMessage(&#123;</span><br><span class="line"> question:</span><br><span class="line">  &#x27;hi，那边的workder线程，请告诉我今天的幸运数字是多少？&#x27;,</span><br><span class="line">&#125;);</span><br><span class="line">worker.onmessage = (&#123; data: &#123; answer &#125; &#125;) =&gt; &#123;</span><br><span class="line"> console.log(answer);</span><br><span class="line">&#125;;</span><br><span class="line">千</span><br></pre></td></tr></table></figure>
<p>(import.meta.url这个参数能够锁定我们当前的这个模块——注意，它不能在<br>commonjs中使用。)<br>这时候我们执行打包命令，会发现,dist目录下除了bundle.js之外，还有另外一个<br>xxx.bundle.js!<br>这说明我们的webpack5自动的将被new Work使用的脚本单独打出了一个bundle。<br>我们加上刚才的问答代码，执行npm run dev，发现它是能够正常工作。<br>并且在network里也可以发现多了一个src_worker_js.bundle.js。<br>总结：<br>webpack5以来内置了很多功能，让我们不需要过多的配置，比如之前讲过的hot模<br>式，和现在的web workder。</p>
<p><strong>Typescript</strong></p>
<p>在前端生态里，TS扮演着越来越重要的角色。<br>我们直入正题，讲下如何在webpack工程化环境中集成TS。<br>首先，当然是安装我们的ts和对应的loader。<br>npm install –save-dev typescript ts-loader</p>
<p>接下来我们需要在项目根目录下添加一个ts的配置文件————tsconfig.json，我们<br>可以用ts自带的工具来自动化生成它。<br>npx tsc –init<br>我们发现生成了一个tsconfig.json，里面注释掉了绝大多数配置。<br>现在，根据我们想要的效果来打开对应的配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;compilerOptions&quot;: &#123;</span><br><span class="line">  &quot;outDir&quot;: &quot;./dist/&quot;,</span><br><span class="line">  &quot;noImplicitAny&quot;: true,</span><br><span class="line">  &quot;sourceMap&quot;: true,</span><br><span class="line">  &quot;module&quot;: &quot;es6&quot;,</span><br><span class="line">  &quot;target&quot;: &quot;es5&quot;,</span><br><span class="line">  &quot;jsx&quot;: &quot;react&quot;,</span><br><span class="line">  &quot;allowJs&quot;: true,</span><br><span class="line">  &quot;moduleResolution&quot;: &quot;node&quot; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> const path = require(&#x27;path&#x27;);</span><br><span class="line"> module.exports = &#123;</span><br><span class="line"> entry: &#x27;./src/index.ts&#x27;,</span><br><span class="line"> devtool: &#x27;inline-source-map&#x27;,</span><br><span class="line">千</span><br></pre></td></tr></table></figure>
<p>好了，接下来我们新增一个src&#x2F;index.ts，内置一些内容。<br>然后我们别忘了更改我们的entry及配置对应的loder。<br>当然，还有resolve.extensions，将.ts放在.js之前，这样它会先找.ts。<br>注意，如果我们使用了sourceMap，一定记得和上面的ts配置一样，设置<br>sourcemap为true。<br>也别忘记在我们的webpack.config.js里，添加sourcemap,就像我们之前课程里讲的<br>那样。<br>更改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"> module.exports = &#123;</span><br><span class="line"> entry: &#x27;./src/index.ts&#x27;,</span><br><span class="line"> devtool: &#x27;inline-source-map&#x27;,</span><br><span class="line"></span><br><span class="line">  module: &#123;</span><br><span class="line">   rules: [</span><br><span class="line">   &#123;</span><br><span class="line">     test: /\.(ts|tsx)$/,</span><br><span class="line">     use: &#x27;ts-loader&#x27;,</span><br><span class="line">     exclude: /node_modules/,</span><br><span class="line">   &#125;,</span><br><span class="line">  ],</span><br><span class="line"> &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">   extensions: [ &#x27;.tsx&#x27;, &#x27;.ts&#x27;, &#x27;.js&#x27; ],</span><br><span class="line"> &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">   filename: &#x27;bundle.js&#x27;,</span><br><span class="line">   path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>运行我们的项目，我们发现完全没有问题呢！<br>使用第三方类库<br>在从 npm 上安装第三方库时，一定要记得同时安装这个库的类型声明文件(typing<br>definition)。<br>我们可以从 TypeSearch中找到并安装这些第三方库的类型声明文件(<a target="_blank" rel="noopener" href="https://www.ty/">https://www.ty</a><br>pescriptlang.org&#x2F;dt&#x2F;search?search&#x3D;) 。<br>举个例子，如果想安装 lodash 类型声明文件，我们可以运行下面的命令：<br>npm install –save-dev @types&#x2F;lodash</p>
<p>eslint &amp; ts<br>注意，如果要使用eslint，使用初始化命令的时候，记得选择“使用了typesctipt”。<br>如果已经配置了eslint，但没有配置ts相关的配置，那么我们需要先安装对应的<br>plugin<br>注意如果需要用到react的话，记得也要安装</p>
<p>yarn add -D  @typescript-eslint&#x2F;eslint-plugin@latest</p>
<p>vue或者其他常用框架同样如此，一般都会有专门的plugin。<br>然后我们队.esilntrc进行更改~</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;env&quot;: &#123;</span><br><span class="line">    &quot;browser&quot;: true,</span><br><span class="line">    &quot;es2021&quot;: true</span><br><span class="line"> &#125;,</span><br><span class="line">  &quot;extends&quot;: [</span><br><span class="line">    &quot;eslint:recommended&quot;, // 如果需要react的话</span><br><span class="line">    &quot;plugin:react/recommended&quot;,</span><br><span class="line">    &quot;plugin:@typescript-eslint/recommended&quot;</span><br><span class="line"> ],</span><br><span class="line">  &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;,</span><br><span class="line">  &quot;parserOptions&quot;: &#123;</span><br><span class="line">    &quot;ecmaFeatures&quot;: &#123;</span><br><span class="line">      &quot;jsx&quot;: true</span><br><span class="line">   &#125;, // 如果需要react的话</span><br><span class="line">    &quot;ecmaVersion&quot;: 13,</span><br><span class="line">    &quot;sourceType&quot;: &quot;module&quot;</span><br><span class="line"> &#125;,</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &quot;react&quot;,</span><br><span class="line">    &quot;@typescript-eslint&quot;</span><br><span class="line"> ],</span><br><span class="line">  &quot;rules&quot;: &#123;</span><br><span class="line">   // ...一些自定义的rules</span><br><span class="line">    &quot;no-console&quot;: &quot;error&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>执行npm run eslint试一下！</p>
<h2 id="四-多页面应用"><a href="#四-多页面应用" class="headerlink" title="四.多页面应用"></a>四.多页面应用</h2><p><strong>entry配置</strong><br>在实际项目的开发中一个完整的系统不会将所有的功能都放在一个网页上，因为这样会导致网页的性能不佳，实际可以按照功能模块划分多个单页应用每个单页应用又生处一个html文件并且随着业务的发展更多的单页应用可以被逐渐的加入到这个项目里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">entry: [&#x27;./src/file_1.js&#x27;, &#x27;./src/file_2.js&#x27;，&#x27;node_modules里的模块 lodash&#x27;],</span><br><span class="line">entry:&#123;</span><br><span class="line">	main:[&#x27;./src/file_1.js&#x27;, &#x27;./src/file_2.js&#x27;],    //这里使用lodash  还会打包在这里打包一遍</span><br><span class="line">	lodash:&#x27;lodash&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">entry:&#123;</span><br><span class="line">	main:&#123;</span><br><span class="line">	import :[&#x27;./src/file_1.js&#x27;, &#x27;./src/file_2.js&#x27;],  //这两个文件可能依赖于lodash，而lodash单独打包了，所以dependOn这个依赖可以把公共的lodash给抽离出来            lodash  就不会在打包一遍了</span><br><span class="line">	dependOn:&#x27;lodash&#x27;,           // 做依赖  这里的lodash  是下面的对应名  可以随意起</span><br><span class="line">	&#125;,    //这里使用lodash  还会打包在这里打包一遍</span><br><span class="line">	lodash:&#x27;lodash&#x27;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象语法会比较繁琐。然而，这是应用程序中定义入口的最可扩展的方式。<br>描述入口的对象：<br>用于描述入口的对象。你可以使用如下属性：<br>dependOn : 当前入口所依赖的入口。它们必须在该入口被加载前被加载。<br>filename : 指定要输出的文件名称。<br>import : 启动时需加载的模块。<br>library : 指定 library 选项，为当前 entry 构建一个 library。<br>runtime : 运行时 chunk 的名字。如果设置了，就会创建一个新的运行时<br>chunk。在 webpack 5.43.0 之后可将其设为 false 以避免一个新的运行时<br>chunk。<br>publicPath : 当该入口的输出文件在浏览器中被引用时，为它们指定一个公共<br>URL 地址。请查看 output.publicPath。<br>webpack.config.js<br>runtime 和 dependOn 不应在同一个入口上同时使用，所以如下配置无效，并且会<br>抛出错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line">  a2: &#x27;dependingfile.js&#x27;,</span><br><span class="line">  b2: &#123;</span><br><span class="line">   dependOn: &#x27;a2&#x27;,</span><br><span class="line">   import: &#x27;./src/app.js&#x27;,</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line">  a2: &#x27;./a&#x27;,</span><br><span class="line">  b2: &#123;</span><br><span class="line">   runtime: &#x27;x2&#x27;,</span><br><span class="line">   dependOn: &#x27;a2&#x27;,</span><br><span class="line">   import: &#x27;./b&#x27;,</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>确保 runtime 不能指向已存在的入口名称，例如下面配置会抛出一个错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line">  a1: &#x27;./a&#x27;,</span><br><span class="line">  b1: &#123;</span><br><span class="line">   runtime: &#x27;a1&#x27;,</span><br><span class="line">   import: &#x27;./b&#x27;,</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另外 dependOn 不能是循环引用的，下面的例子也会出现错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line">  a3: &#123;</span><br><span class="line">   import: &#x27;./a&#x27;,</span><br><span class="line">   dependOn: &#x27;b3&#x27;,</span><br><span class="line"> &#125;,</span><br><span class="line">  b3: &#123;</span><br><span class="line">   import: &#x27;./b&#x27;,</span><br><span class="line">   dependOn: &#x27;a3&#x27;,</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>配置index.html模板</strong><br>要生成多个HTML文件，请在插件数组中多次声明插件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line"> 	main:&#123;</span><br><span class="line">		import :[],</span><br><span class="line">		dependOn:&#x27;lodash2&#x27;,</span><br><span class="line">		filename:&#x27;chanel1.[name].js&#x27;</span><br><span class="line">	&#125;,</span><br><span class="line">	lodash2:&#123;</span><br><span class="line">		import :&#x27;lodash&#x27;,</span><br><span class="line">		filename:&#x27;common/[name].js&#x27;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line"> plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(), // Generates default index.html</span><br><span class="line">  new HtmlWebpackPlugin(&#123;  // Also generate a test.html</span><br><span class="line">   title:   &#x27;ejs&#x27;,     //在页面可以使用ejs模板语法获取数据</span><br><span class="line">   filename: &#x27;chanel1/test.html&#x27;,                      //执行打包后的页面文件     输出的文件名</span><br><span class="line">   template: &#x27;src/assets/test.html&#x27;       //指定模板的路径</span><br><span class="line">   inject:&#x27;body/head&#x27;,                       // 定义当前所生成的script标签的位置</span><br><span class="line">   chunks:[&#x27;自定义那个入口  如：main.js&#x27;]，              //规定当前页面到底打包那些chunk   如何实现多个页面去载入不同的chunk   chunk就是我们在路口配置的项    每一项就是一个chunk  默认会把所有chunk都放进去</span><br><span class="line">   publicPash:&#x27;http://www.a.com/&#x27;        //包的前缀</span><br><span class="line"> &#125;)</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title  %&gt;&lt;/title&gt;  options.就是我们在HtmlWebpackPlugin定制的选项</span><br><span class="line">index.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;/&gt;</span><br><span class="line">  &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>多页面应用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line">  pageOne: &#x27;./src/pageOne/index.js&#x27;,</span><br><span class="line">  pageTwo: &#x27;./src/pageTwo/index.js&#x27;,</span><br><span class="line">  pageThree: &#x27;./src/pageThree/index.js&#x27;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是什么？ 我们告诉 webpack 需要三个独立分离的依赖图（如上面的示例）</p>
<p>为什么？ 在多页面应用程序中，server 会拉取一个新的 HTML 文档给你的客户端。<br>页面重新加载此新文档，并且资源被重新下载。然而，这给了我们特殊的机会去做很<br>多事，例如使用 optimization.splitChunks 为页面间共享的应用程序代码创建<br>bundle。由于入口起点数量的增多，多页应用能够复用多个入口起点之间的大量代<br>码&#x2F;模块，从而可以极大地从这些技术中受益。</p>
<h2 id="五-Tree-Shaking"><a href="#五-Tree-Shaking" class="headerlink" title="五.Tree Shaking"></a>五.Tree Shaking</h2><p>tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块语法的 静态结构 特性，例如 import 和export 。这个术语和概念实际上是由 ES2015 模块打包工具 rollup 普及起来的。webpack 2 正式版本内置支持 ES2015 模块（也叫做 harmony modules）和未使用模块检测能力。新的 webpack4 正式版本扩展了此检测能力，通过 package.json的 “sideEffects” 属性作为标记，向 compiler 提供提示，表明项目中的哪些文件是 “pure(纯正 ES2015 模块)”，由此可以安全地删除文件中未使用的部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line"> usedExports: true,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>webpack5打包更加精简化           只打包用到的方法或属性      tree shaking  优化到了极质，把一些没有用的代码全部摇掉只是给我们用到了的数据<br>理论：只要是我认为这个代码在项目中没有使用  那么就给摇掉。它基于es  module</p>
<p><strong>sideEffects</strong><br>注意 Webpack 不能百分百安全地进行 tree-shaking。有些模块导入，只要被引入，就会对应用程序产生重要的影响。一个很好的例子就是全局样式表，或者设置全局配置的JavaScript 文件。</p>
<p>Webpack 认为这样的文件有“副作用”。具有副作用的文件不应该做 tree-shaking，因为这将破坏整个应用程序。<br>Webpack 的设计者清楚地认识到不知道哪些文件有副作用的情况下打包代码的风险，因此webpack4默认地将所有代码视为有副作用。这可以保护你免于删除必要的文件，但这意味着 Webpack 的默认行为实际上是不进行 tree-shaking。值得注意的是webpack5默认会进行 tree-shaking。<br>如何告诉 Webpack 你的代码无副作用，可以通过 package.json 有一个特殊的属性<br>sideEffects，就是为此而存在的。<br>它有三个可能的值：<br>true<br>如果不指定其他值的话。这意味着所有的文件都有副作用，也就是没有一个文件<br>可以 tree-shaking。<br>false<br>告诉 Webpack 没有文件有副作用，所有文件都可以 tree-shaking。<br>数组[…]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">package.json</span><br><span class="line">&#x27;sideEffects&#x27;:true/false,</span><br><span class="line">&#x27;sideEffects&#x27;:[&#x27;*.css&#x27;,&#x27;*.global.js&#x27;],</span><br></pre></td></tr></table></figure>
<p>是文件路径数组。它告诉 webpack，除了数组中包含的文件外，你的任何文件<br>都没有副作用。因此，除了指定的文件之外，其他文件都可以安全地进行 tree-<br>shaking。<br>webpack4 曾经不进行对 CommonJs 导出和 require() 调用时的导出使用分析。<br>webpack 5 增加了对一些 CommonJs 构造的支持，允许消除未使用的 CommonJs<br>导出，并从 require() 调用中跟踪引用的导出名称。</p>
<h2 id="六-渐进式网络应用程序PWA"><a href="#六-渐进式网络应用程序PWA" class="headerlink" title="六.渐进式网络应用程序PWA"></a>六.渐进式网络应用程序PWA</h2><p>渐进式网络应用程序(progressive web application - PWA)，是一种可以提供类似于native app(原生应用程序) 体验的 web app(网络应用程序)，就是说我们在浏览器端能够实现类似于原生应用程序的体验。PWA 可以用来做很多事。其中最重要的是，在离线(offline)时应用程序能够继续运行功能。这是通过使用名为 Service Workers 的 web 技术来实现的。</p>
<p><strong>非离线环境下运行</strong></p>
<p>到目前为止，我们一直是直接查看本地文件系统的输出结果。通常情况下，真正的用户是通过网络访问 web app；用户的浏览器会与一个提供所需资源（例如， .html ,.js 和 .css 文件）的 server 通讯。<br>我们通过搭建一个拥有更多基础特性的 server 来测试下这种离线体验。这里使用http-server package： npm install http-server –save-dev 。还要修改package.json 的 scripts 部分，来添加一个 start script：</p>
<p>不使用webpack-dev-server，使用第三方server，相当于我们把dist已经打包出来准备发布了<br>npm install http-server -D</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"> &quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;start&quot;: &quot;http-server dist&quot;</span><br><span class="line">&#125;,</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line">//注意：webpack-dev-server 是一个非离线 在线的server。 默认情况下，webpack DevServer 会写入到内存（当我们修改代码的时候重新启动服务它并不能够把我们的文件打包到dist下面，因为他是直接放到内存里的。）。我们需要启用devserverdevmiddleware.writeToDisk 配置项，来让 http-server 处理 ./dist 目录中的文件。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line"> devMiddleware: &#123;    //开发环境的server的中间件</span><br><span class="line">  writeToDisk:true,    // 写入到硬盘里</span><br><span class="line">  index: true,</span><br><span class="line">  writeToDisk: true,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你打开浏览器访问 <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a> (即 <a target="_blank" rel="noopener" href="http://127.0.0.1/">http://127.0.0.1</a> )，你应该会看到 webpack 应用程序被 serve 到 dist 目录。如果停止 server 然后刷新，则 webpack 应用程序不再可访问。这就是我们为实现离线体验所需要的改变。在本章结束时，我们应该要实现的是，停止 server 然后刷新，仍然可以看到应用程序正常运行。</p>
<p><strong>添加 Workbox</strong><br>添加 workbox-webpack-plugin 插件，然后调整 webpack.config.js 文件：    实现PWA<br>npm install workbox-webpack-plugin –save-dev</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);</span><br><span class="line">const WorkboxPlugin = require(&#x27;workbox-webpack-plugin&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line">  app: &#x27;./src/index.js&#x27;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"> plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(),</span><br><span class="line">  new WorkboxPlugin.GenerateSW(&#123;</span><br><span class="line">   // 这些选项帮助快速启用 ServiceWorkers</span><br><span class="line">   // 不允许遗留任何“旧的” ServiceWorkers</span><br><span class="line">   clientsClaim: true,  // 快速的启用ServiceWorkers</span><br><span class="line">   skipWaiting: true,     // 跳出等待</span><br><span class="line"> &#125;),</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line"> output: &#123;</span><br><span class="line">  filename: &#x27;[name].bundle.js&#x27;,</span><br><span class="line">  path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">  clean: true,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你可以看到，生成了两个额外的文件： service-worker.js 和名称冗长的workbox-718aa5be.js 。 service-worker.js 是 Service Worker 文件， workbox-718aa5be.js 是 service-worker.js 引用的文件，所以它也可以运行。你本地生成的文件可能会有所不同；但是应该会有一个 service-worker.js 文件。所以，值得高兴的是，我们现在已经创建出一个 Service Worker。接下来该做什么？</p>
<p><strong>注册 Service Worker  实现离线浏览页面的功能</strong><br>接下来我们注册 Service Worker，使其出场并开始表演。通过添加以下注册代码来<br>完成此操作：<br>index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (&#x27;serviceWorker&#x27; in navigator) &#123;    //浏览器是否支持serviceWorker</span><br><span class="line"> window.addEventListener(&#x27;load&#x27;, () =&gt; &#123;   //绑定事件load在页面加载完之后执行</span><br><span class="line">  navigator.serviceWorker.register(&#x27;/service-     // 方法传入刚刚打包好的service-worker.js。</span><br><span class="line">worker.js&#x27;).then(registration =&gt; &#123;                  // 拿到注册以后的成功的结果</span><br><span class="line">   console.log(&#x27;SW 注册成功: &#x27;, registration);</span><br><span class="line"> &#125;).catch(registrationError =&gt; &#123;</span><br><span class="line">   console.log(&#x27;SW 注册失败: &#x27;, registrationError);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于在浏览器里我们的页面被缓存下来了<br>chrome:&#x2F;&#x2F;serviceworker-internals    清除http-server缓存。   服务就跑不起来了。</p>
<p>再次运行 npx webpack 来构建包含注册代码版本的应用程序。然后用 npm start启动服务。访<a href="http://localhost:8080并查看">http://localhost:8080并查看</a> console 控制台。在那里你应该看到：<br>SW registered<br>现在来进行测试。停止 server 并刷新页面。如果浏览器能够支持 Service Worker，应该可以看到你的应用程序还在正常运行。然而，server 已经停止 serve 整个 dist文件夹，此刻是 Service Worker 在进行 serve。</p>
<h2 id="七-Shimming预置依赖"><a href="#七-Shimming预置依赖" class="headerlink" title="七.Shimming预置依赖"></a>七.Shimming预置依赖</h2><p>不导入直接就可以使用一些变量</p>
<p>webpack compiler 能够识别遵循 ES2015 模块语法、CommonJS 或 AMD 规范编写的模块。然而，一些 third party(第三方库) 可能会引用一些全局依赖（例如 jQuery中的 $ ）。因此这些 library 也可能会创建一些需要导出的全局变量这些 “brokenmodules(不符合规范的模块)” 就是 shimming(预置依赖) 发挥作用的地方。<br>shim 另外一个极其有用的使用场景就是：当你希望 polyfill 扩展浏览器能力，来支持到更多用户时。在这种情况下，你可能只是想要将这些 polyfills 提供给需要修补(patch)的浏览器（也就是实现按需加载）。</p>
<p><strong>Shimming 预置全局变量</strong></p>
<p>让我们开始第一个 shimming 全局变量的用例。还记得我们之前用过的 lodash吗？出于演示目的，例如把这个应用程序中的模块依赖，改为一个全局变量依赖。要实现这些，我们需要使用 ProvidePlugin 插件。使用 ProvidePlugin 后，能够在 webpack 编译的每个模块中，通过访问一个变量来获取一个 package。如果 webpack 看到模块中用到这个变量，它将在最终bundle 中引入给定的 package。让我们先移除 lodash 的 import 语句，改为通过插件提供它：<br>src&#x2F;index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">console.log(_.join([&#x27;hello&#x27;, &#x27;webpack&#x27;], &#x27; &#x27;))</span><br><span class="line">webpack.config.js</span><br><span class="line"></span><br><span class="line">const webpack = require(&#x27;webpack&#x27;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode: &#x27;development&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> plugins: [</span><br><span class="line">  new webpack.ProvidePlugin(&#123;</span><br><span class="line">   _: &#x27;lodash&#x27;     // lodash变成全局  遇到_将lodash包引进来</span><br><span class="line"> &#125;)</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们本质上所做的，就是告诉 webpack……如果你遇到了至少一处用到 _ 变量的模块实例，那请你将 lodash package 引入进来，并将其提供给需要用到它的模块。运行我们的构建脚本，将会看到同样的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[felix] 01-third-party-shimming $ npx webpack</span><br><span class="line">asset main.js 549 KiB [emitted] (name: main)</span><br><span class="line">runtime modules 344 bytes 2 modules</span><br><span class="line">cacheable modules 528 KiB</span><br><span class="line">./src/index.js 46 bytes [built] [code generated]</span><br><span class="line">../../../../../node_modules/lodash/lodash.js 528 KiB [built]</span><br><span class="line">[code generated]</span><br><span class="line">webpack 5.61.0 compiled successfully in 275 ms</span><br></pre></td></tr></table></figure>
<p>还可以使用 ProvidePlugin 暴露出某个模块中单个导出，通过配置一个“数组路径”（例如 [module, child, …children?] ）实现此功能。所以，我们假想如下，无论 join 方法在何处调用，我们都只会获取到 lodash 中提供的 join 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">src/index.js</span><br><span class="line">console.log(join([&#x27;hello&#x27;, &#x27;webpack&#x27;], &#x27; &#x27;))</span><br><span class="line">webpack.config.js</span><br><span class="line">const webpack = require(&#x27;webpack&#x27;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode: &#x27;development&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> plugins: [</span><br><span class="line">  new webpack.ProvidePlugin(&#123;</span><br><span class="line">   // _: &#x27;lodash&#x27;</span><br><span class="line">   join: [&#x27;lodash&#x27;, &#x27;join&#x27;],</span><br><span class="line"> &#125;)</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就能很好的与 tree shaking 配合，将 lodash library 中的其余没有用到的导出<br>去除</p>
<p><strong>细粒度 Shimming</strong><br>一些遗留模块依赖的 this 指向的是 window 对象。在接下来的用例中，调整我们的 index.js ：<br>npm istall imports-loader -D</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.alert(&#x27;hello webpack&#x27;)</span><br></pre></td></tr></table></figure>
<p>当模块运行在 CommonJS 上下文中，这将会变成一个问题，也就是说此时的 this指向的是 module.exports 。在这种情况下，你可以通过使用 imports-loader 覆盖 this 指向：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(&#x27;webpack&#x27;)</span><br><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode: &#x27;production&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: require.resolve(&#x27;./src/index.js&#x27;),     // 调用require.resolve去调用  文件。</span><br><span class="line">    use: &#x27;imports-loader?wrapper=window&#x27;,     //webpack解析到  这个文件时使用的loader  wrapper=window  指明包里面的this指向浏览器的window。</span><br><span class="line">  &#125;,</span><br><span class="line"> ]</span><br><span class="line">&#125;,</span><br><span class="line"> plugins: [</span><br><span class="line">  new webpack.ProvidePlugin(&#123;</span><br><span class="line">   _: &#x27;lodash&#x27;</span><br><span class="line"> &#125;),</span><br><span class="line">  new HtmlWebpackPlugin()</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>全局 Exports</strong></p>
<p>让我们假设，某个 library 创建出一个全局变量，它期望 consumer(使用者) 使用这个变量。为此，我们可以在项目配置中，添加一个小模块来演示说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">src/globals.js</span><br><span class="line">const file = &#x27;example.txt&#x27;;</span><br><span class="line">const helpers = &#123;</span><br><span class="line"> test: function () &#123;</span><br><span class="line">  console.log(&#x27;test something&#x27;)</span><br><span class="line">&#125;,</span><br><span class="line"> parse: function () &#123;</span><br><span class="line">  console.log(&#x27;parse something&#x27;)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">npm install exports-loader -D</span><br><span class="line"></span><br><span class="line">webpack.config.js</span><br><span class="line">const webpack = require(&#x27;webpack&#x27;)</span><br><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode: &#x27;production&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: require.resolve(&#x27;./src/index.js&#x27;),</span><br><span class="line">    use: &#x27;imports-loader?wrapper=window&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    test: require.resolve(&#x27;./src/globals.js&#x27;),</span><br><span class="line">    use: &#x27;exports-loader?type=commonjs&amp;exports=file,multiple|helpers.parse（value）|parse（key）&#x27;,   //  type：类型为模块导出的类型commonjs    导出的变量file  js文件中的File    ，multiple表示导出一个key|value的形式。</span><br><span class="line">  &#125;,</span><br><span class="line"> ]</span><br><span class="line">&#125;,</span><br><span class="line"> plugins: [</span><br><span class="line">  new webpack.ProvidePlugin(&#123;</span><br><span class="line">   _: &#x27;lodash&#x27;</span><br><span class="line"> &#125;),</span><br><span class="line">  new HtmlWebpackPlugin()</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const &#123;file,parse&#125; = require(&#x27;./globals&#x27;)   //  那我直接导入不就行了，前提条件globals.js是外部的一个文件，一般情况下我们并不知道它是如何导出的   所有我们在配置文件里边做一个  一些内容的导出   这样我们就可以单独的去使用我们想要的一些模块了</span><br></pre></td></tr></table></figure>

<p>此时，在我们的 entry 入口文件中（即 src&#x2F;index.js ），可以使用 const {file, parse } &#x3D; require(‘.&#x2F;globals.js’); ，可以保证一切将顺利运行。</p>
<p><strong>加载 Polyfills</strong><br>目前为止，我们讨论的所有内容 都是处理那些遗留的 package，让我们进入到第二个话题：polyfill。<br>有很多方法来加载 polyfill。例如，想要引入 @babel&#x2F;polyfill 我们只需如下操作：<br>npm install –save @babel&#x2F;polyfill<br>然后，使用 import 将其引入到我们的主 bundle 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index.js</span><br><span class="line">import &#x27;@babel/polyfill&#x27;    //polyfill俗称垫片   在执行下面的语句之前，把所有的可能需要降级的代码都放在了我们代码的前面</span><br><span class="line">console.log(Array.from([1, 2, 3], x =&gt; x + x))    //from方法不是所有的浏览器都支持的   如果是我们不告诉webpack那么他就纯粹八Array.from直接的打到我们的页面上去了，即使是我们可能会使用一些@babal/loader,但是他也不会  100%的将我们的代码全部转换为低版本的浏览器能够识别的所有代码。所以我们得告诉浏览器 在某些版本里面得把他转成低版本的代码比如  es6=&gt;es3.1  这是我们就需要一个垫片来完成。</span><br></pre></td></tr></table></figure>
<p>注意，这种方式优先考虑正确性，而不考虑 bundle 体积大小。为了安全和可靠，polyfill&#x2F;shim 必须运行于所有其他代码之前，而且需要同步加载，或者说，需要在所有 polyfill&#x2F;shim 加载之后，再去加载所有应用程序代码。 社区中存在许多误解，即现代浏览器“不需要”polyfill，或者 polyfill&#x2F;shim 仅用于添加缺失功能 - 实际上，它们通常用于修复损坏实现(repair broken implementation)，即使是在最现代的浏览器中，也会出现这种情况。 因此，最佳实践仍然是，不加选择地和同步地加载所有polyfill&#x2F;shim，尽管这会导致额外的 bundle 体积成本。</p>
<p><strong>进一步优化 Polyfills</strong><br>不建议使用 import @babel&#x2F;polyfilll 。因为这样做的缺点是会全局引入整个polyfill包，比如 Array.from 会全局引入，不但包的体积大，而且还会污染全局环境。<br>babel-preset-env package 通过 browserslist 来指定来对那些浏览器那些浏览器的版本进行转换，来转译那些你浏览器中不支持的特性。这个 preset 使用 useBuiltIns 选项，默认值是 false ，这种方式可以将全局babel-polyfill 导入，改进为更细粒度的 import 格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;core-js/modules/es7.string.pad-start&#x27;;</span><br><span class="line">import &#x27;core-js/modules/es7.string.pad-end&#x27;;</span><br><span class="line">import &#x27;core-js/modules/web.timers&#x27;;</span><br><span class="line">import &#x27;core-js/modules/web.immediate&#x27;;</span><br><span class="line">import &#x27;core-js/modules/web.dom.iterable&#x27;;</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;安装 @babel&#x2F;preset-env 及 相关的包<br>npm i babel-loader @babel&#x2F;core @babel&#x2F;preset-env -D<br>&#x2F;&#x2F; webpack.config.js<br>const HtmlWebpackPlugin &#x3D; require(‘html-webpack-plugin’)<br>module.exports &#x3D; {<br> mode: ‘production’,<br> entry: ‘.&#x2F;src&#x2F;index.js’,<br> plugins: [<br>  new HtmlWebpackPlugin()<br>],<br> module: {<br>  rules: [<br>  {<br>    test: &#x2F;.js$&#x2F;,<br>    exclude: &#x2F;node_modules&#x2F;,<br>    use: {<br>     loader: ‘babel-loader’,<br>     options: {<br>      presets: [<br>      [<br>        ‘@babel&#x2F;preset-env’,<br>       {<br>         targets: [  &#x2F;&#x2F;也可以顶知道package.json中  符合这个条件的代码都需要通过Polyfill来进行垫片的添加<br>          “last 1 version”,<br>          “&gt; 1%”,<br>         ],<br>         useBuiltIns: ‘usage’ ，    &#x2F;&#x2F;  这里这个@babel&#x2F;preset-env  后我们就不需要手动的导入  import ‘@babel&#x2F;polyfill’了。        使用这个选项需要 Core.js翻译器，这是优雅降级的一些库<br>         &#x2F;&#x2F;添加corejs配置<br>           corejs: 3,     &#x2F;&#x2F;定义core.js的版本魏三<br>       }<br>      ]<br>     ]<br>    }<br>   }<br>  }<br> ]<br>}<br>}<br>useBuiltIns: 参数有 “entry”、”usage”、false 三个值默认值是 false ，此参数决定了babel打包时如何处理@babel&#x2F;polyfilll 语句。<br>“entry”: 会将文件中 import @babel&#x2F;polyfilll 语句 结合 targets ，转换为一系列引入语句，去掉目标浏览器已支持的 polyfilll 模块，不管代码里有没有用到，只要目标浏览器不支持都会引入对应的 polyfilll 模块。<br>“usage”: 不需要手动在代码里写 import @babel&#x2F;polyfilll ，打包时会自动根据实际代码的使用情况，结合 targets 引入代码里实际用到部分 polyfilll 模块<br>false: 对 import‘@babel&#x2F;polyfilll’不作任何处理，也不会自动引入 polyfilll 模块。需要注意的是在 webpack 打包文件配置的 entry 中引入的 @babel&#x2F;polyfill 不会根据useBuiltIns 配置任何转换处理。</p>
<p>由于@babel&#x2F;polyfill在7.4.0中被弃用，我们建议直接添加corejs并通过corejs选项设置版本。<br>执行编译 npx webpack</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[felix] 02-polyfill $ npx webpack</span><br><span class="line">WARNING (@babel/preset-env): We noticed you&#x27;re using the</span><br><span class="line">`useBuiltIns` option without declaring a core-js version.</span><br><span class="line">Currently, we assume version 2.x when no version is passed. Since</span><br><span class="line">this default version will likely change in future versions of</span><br><span class="line">Babel, we recommend explicitly setting the core-js version you</span><br><span class="line">are using via the `corejs` option.</span><br><span class="line">You should also be sure that the version you pass to the `corejs`</span><br><span class="line">option matches the version specified in your `package.json`&#x27;s</span><br><span class="line">`dependencies` section. If it doesn&#x27;t, you need to run one of the</span><br><span class="line">following commands:</span><br><span class="line">npm install --save core-js@2   npm install --save core-js@3</span><br><span class="line">yarn add core-js@2       yarn add core-js@3</span><br><span class="line">More info about useBuiltIns: https://babeljs.io/docs/en/babel-</span><br><span class="line">preset-env#usebuiltins</span><br><span class="line">More info about core-js: https://babeljs.io/docs/en/babel-preset-</span><br><span class="line">env#corejs</span><br><span class="line">asset main.js 16.7 KiB [emitted] [minimized] (name: main)</span><br><span class="line">asset index.html 214 bytes [compared for emit]</span><br><span class="line">runtime modules 663 bytes 3 modules</span><br><span class="line">modules by path ./node_modules/core-js/modules/*.js 38.9 KiB 68</span><br><span class="line">modules</span><br><span class="line">./src/index.js 374 bytes [built] [code generated]</span><br><span class="line">webpack 5.61.0 compiled successfully in 1613 ms</span><br></pre></td></tr></table></figure>
<p>提示我们需要安装 core-js 。<br>npm i core-js@3 -S<br>此时还需要 添加一个配置：<br>&#x2F;&#x2F; 添加corejs配置<br>corejs: 3,<br>成功优化</p>
<h2 id="八-创建-library"><a href="#八-创建-library" class="headerlink" title="八.创建 library"></a>八.创建 library</h2><p>除了打包应用程序，webpack 还可以用于打包 JavaScript library。<br>例如：当我们想要自己开发一个组件库工具或者框架的时候也就是说我们自己造一个轮子给别人用的时候我们免不了要开发很多的模块，最终都可以请webpack来帮我们打包。</p>
<p><strong>创建一个 library</strong><br>假设我们正在编写一个名为 webpack-numbers 的小的 library，可以将数字 1 到 5转换为文本表示，反之亦然，例如将 2 转换为 ‘two’。<br>使用 npm 初始化项目，然后安装 webpack ， webpack-cli 和 lodash ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack webpack-cli lodash -D</span><br></pre></td></tr></table></figure>
<p>我们将 lodash 安装为 devDependencies 而不是 dependencies ，因为我们不需要将其打包到我们的库中，否则我们的库体积很容易变大。</p>
<p>src&#x2F;ref.json</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num&quot;: 1,</span><br><span class="line">  &quot;word&quot;: &quot;One&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num&quot;: 2,</span><br><span class="line">  &quot;word&quot;: &quot;Two&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num&quot;: 3,</span><br><span class="line">  &quot;word&quot;: &quot;Three&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num&quot;: 4,</span><br><span class="line">  &quot;word&quot;: &quot;Four&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num&quot;: 5,</span><br><span class="line">  &quot;word&quot;: &quot;Five&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num&quot;: 0,</span><br><span class="line">  &quot;word&quot;: &quot;Zero&quot;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>src&#x2F;index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import _ from &#x27;lodash&#x27;;</span><br><span class="line">import numRef from &#x27;./ref.json&#x27;;</span><br><span class="line">export function numToWord(num) &#123;</span><br><span class="line"> return _.reduce(</span><br><span class="line">  numRef,</span><br><span class="line"> (accum, ref) =&gt; &#123;</span><br><span class="line">   return ref.num === num ? ref.word : accum;</span><br><span class="line"> &#125;,</span><br><span class="line">  &#x27;&#x27;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">export function wordToNum(word) &#123;</span><br><span class="line"> return _.reduce(</span><br><span class="line">  numRef,</span><br><span class="line"> (accum, ref) =&gt; &#123;</span><br><span class="line">   return ref.word === word &amp;&amp; word.toLowerCase() ? ref.num :</span><br><span class="line">accum;</span><br><span class="line"> &#125;,</span><br><span class="line">  -1</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode:&#x27;production&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">  filename: &#x27;webpack-numbers.js&#x27;,</span><br><span class="line">  library:&#123;</span><br><span class="line">    name:&#x27;webpackNumbers&#x27;,</span><br><span class="line">	type&#x27;umd&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  globalObject:&#x27;globalThis&#x27;</span><br><span class="line">&#125;,</span><br><span class="line"> externals:&#123;</span><br><span class="line"> 	lodash:&#123;   lodash  引入包的名字</span><br><span class="line">		commonjs:&#x27;lodash&#x27;,   //  兼容引入形式</span><br><span class="line">		commonjs2:&#x27;lodash&#x27;,</span><br><span class="line">		amd:&#x27;lodash&#x27;,</span><br><span class="line">		root:&#x27;_&#x27;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>发布到线上</strong><br>拥有npm账号<br>npm config get registry   &#x2F;&#x2F; 一定要保证本地的registry的地址是<a target="_blank" rel="noopener" href="https://registry.npmjs.org/">https://registry.npmjs.org/</a>    因为这样的话才是真正的连接到npm官网的地址上   有些人可能是淘宝  那么就访问不上去了<br>npm adduser  &#x2F;&#x2F;添加用户   输入用户名密码<br>包的名字必须是全球唯一的。   npm publish    上传时package.json中的main入口必须对应：dist&#x2F;文件名   因为别人通过 require去载入包的时候  会读取 这个main这是的暴露的包的名字<br>npm install 包名就可以下载了</p>
<p><strong>Webpack 配置</strong></p>
<p>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">	path:&#x27;&#x27;,</span><br><span class="line">	filname:&#x27;&#x27;,</span><br><span class="line">	library:&#x27;&#x27;,    //我们只是定义了导出 并且没有使用它  所以webpack认为这个代码是没有用的。   如何让他作为一个library来进行一个对外的打包   让代码不被 Webpack Tree shaking   配置 library:&#x27;包的名字&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到目前为止，一切都应该与打包应用程序一样，这里是不同的部分 - 我们需要通过output.library 配置项暴露从入口导出的内容。<br>我们暴露了 webpackNumbers ，以便用户可以通过 script 标签使用。	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://example.org/webpack-numbers.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> window.webpackNumbers.wordToNum(&#x27;Five&#x27;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>然而它只能通过被 script 标签引用而发挥作用，它不能运行在 CommonJS、AMD、Node.js 等环境中。<br>作为一个库作者，我们希望它能够兼容不同的环境，也就是说，用户应该能够通过以下方式使用打包后的库：<br>CommonJS module require:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const webpackNumbers = require(&#x27;webpack-numbers&#x27;);</span><br><span class="line">// ...</span><br><span class="line">webpackNumbers.wordToNum(&#x27;Two&#x27;);</span><br></pre></td></tr></table></figure>
<p>AMD module require:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require([&#x27;webpackNumbers&#x27;], function (webpackNumbers) &#123;</span><br><span class="line"> // ...</span><br><span class="line"> webpackNumbers.wordToNum(&#x27;Two&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>script tag:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br><span class="line"> &lt;script src=&quot;https://example.org/webpack-numbers.js&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">  // ...</span><br><span class="line">  // Global variable</span><br><span class="line">  webpackNumbers.wordToNum(&#x27;Five&#x27;);</span><br><span class="line">  // Property in the window object</span><br><span class="line">  window.webpackNumbers.wordToNum(&#x27;Five&#x27;);</span><br><span class="line">  // ...</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>我们更新 output.library 配置项，将其 type 设置为 ‘umd’ ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">  filename: &#x27;webpack-numbers.js&#x27;,</span><br><span class="line">  library: &#123;</span><br><span class="line">   name: &#x27;webpackNumbers&#x27;,</span><br><span class="line">   type: &#x27;umd&#x27;,   //  window&#x27;(es module)   &#x27;commonjs&#x27;   &#x27;module&#x27; 它在experiments:&#123;outputModule:true&#125;才能使用，他是一个实验性的功能，就不需要这个name了。&lt;script type=&quot;module&quot;&gt;    &#x27;umd&#x27;支持所有的类型。  esmodule 有问题</span><br><span class="line">  &#125;,</span><br><span class="line">  globalObject:&#x27;globalThis&#x27;    //需要全局的this来去  代替self   否则浏览器会self  undefined报错</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在 webpack 将打包一个库，其可以与 CommonJS、AMD 以及 script 标签使用</p>
<h2 id="九-模块联邦-Module-Federation"><a href="#九-模块联邦-Module-Federation" class="headerlink" title="九.模块联邦(Module Federation)"></a>九.模块联邦(Module Federation)</h2><p>多个独立的构建可以组成一个应用程序，这些独立的构建之间不应该存在依赖关系，因此可以单独开发和部署它们。<br>这通常被称作微前端，但并不仅限于此。<br>Webpack5 模块联邦可以让 Webpack 达到了线上 Runtime 的效果，让代码直接在项目间利用 CDN 直接共享，不再需要本地安装 Npm 包、构建再发布了！<br>我们知道 Webpack 可以通过 DLL 或者 Externals 做代码共享时 Common Chunk，但不同应用和项目间这个任务就变得困难了，我们几乎无法在项目之间做到按需热插拔。</p>
<p>早期NPM方式共享模块   代码的共享是将依赖作为library安装到我们的项目里进行webpack打包并且构建上线<br>对于项目 Home 与 Search，需要共享一个模块时，最常见的办法就是将其抽成通用依赖并分别安装在各自项目中。虽然 Monorepo 可以一定程度解决重复安装和修改困难的问题，但依然需要走本地编译。</p>
<p>真正 Runtime 的方式可能是 UMD 方式共享代码模块，即将模块用 Webpack UMD模式打包，并输出到其他项目中。这是非常普遍的模块共享方式：<br>对于项目 Home 与 Search，直接利用 UMD 包复用一个模块。但这种技术方案问题也很明显，就是包体积无法达到本地编译时的优化效果，且库之间容易冲突。</p>
<p>微前端：micro-frontends (MFE) 也是最近比较火的模块共享管理方式，微前端就是要解决多项目并存问题，多项目并存的最大问题就是模块共享，模块之间是不能有冲突。  对于微前端我们还要考虑样式冲突，声明周期管理冲突等问题，我们先不考虑这些   想把问题聚焦在资源加载的方式上   微前端一般有两种打包方式：1.子应用独立打包，模块实现解耦，但这种方式无法抽取公共的依赖，2.整体应用打一个打包 很好的解决我们上面第一种方式的问题，但是打包效率速度实在是太慢了。不具备水平的扩展能力。<br>由于微前端还要考虑样式冲突、生命周期管理，所以本文只聚焦在资源加载方式上。微前端一般有两种打包方式：</p>
<ol>
<li>子应用独立打包，模块更解耦，但无法抽取公共依赖等。</li>
<li>整体应用一起打包，很好解决上面的问题，但打包速度实在是太慢了，不具备水平扩展能力。</li>
</ol>
<p>终于提到本文的主角了，模块联邦方式作为 Webpack5 内置核心特性之一的 FederatedModule：<br>这个方案是直接将一个应用的包应用于另一个应用，同时具备整体应用一起打包的公共依赖抽取能力。  比如：我们直接可以在Search应用里直接使用已经发布到线上的Home应用的组件。</p>
<p><strong>应用案例</strong><br>本案例模拟三个应用： Nav 、 Search 及 Home 。每个应用都是独立的，又通过模块邦联系到了一起。<br>比如Home需要使用Nav组件共享出来的header，Search可能要使用Header和Home组件构建出来的HomeList。<br>模块联邦将他们共享的模块暴露出来进行引用。<br>1、Nav 导航<br>src&#x2F;header.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const Header = () =&gt; &#123;</span><br><span class="line"> const header = document.createElement(&#x27;h1&#x27;)</span><br><span class="line"> header.textContent = &#x27;公共头部内容&#x27;</span><br><span class="line"> return header</span><br><span class="line">&#125;</span><br><span class="line">export default Header</span><br></pre></td></tr></table></figure>
<p>src&#x2F;index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import Header from &#x27;./Header&#x27;</span><br><span class="line">const div = document.createElement(&#x27;div&#x27;)</span><br><span class="line">div.appendChild(Header())</span><br><span class="line">document.body.appendChild(div)</span><br></pre></td></tr></table></figure>
<p>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">const &#123;</span><br><span class="line"> ModuleFederationPlugin</span><br><span class="line">&#125; = require(&#x27;webpack&#x27;).container</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode: &#x27;production&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(),</span><br><span class="line">  new ModuleFederationPlugin(&#123;</span><br><span class="line">   // 模块联邦名字</span><br><span class="line">   name: &#x27;nav&#x27;,</span><br><span class="line">   // 外部访问的资源名字</span><br><span class="line">   filename: &#x27;remoteEntry.js&#x27;,</span><br><span class="line">   // 引用的外部资源列表</span><br><span class="line">   remotes: &#123;&#125;,</span><br><span class="line">   // 暴露给外部资源列表</span><br><span class="line">   exposes: &#123;</span><br><span class="line">    &#x27;./Header&#x27;: &#x27;./src/Header.js&#x27;,   // 暴露 Header组件  key：可以定义成./Header 这个./Header并不代表是我当前引用下的某个路径   而是将来在别人用的时候基于这个路径来拼接url，值是正真的我们本地项目的应用</span><br><span class="line">  &#125;,</span><br><span class="line">   // 共享模块，如lodash</span><br><span class="line">   shared: &#123;&#125;,   // 如果我们的 header模块里有共享的第三方模块比如：lodash等，我们可以把他放到这里在打包的时候可以把第三方的共享的模块打到单独的一个包里。</span><br><span class="line"> &#125;),</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用 webpack 运行服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[felix] nav $ npx webpack serve --port 3003</span><br></pre></td></tr></table></figure>

<p>2、Home 首页<br>src&#x2F;HomeList</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const HomeList = (num) =&gt; &#123;</span><br><span class="line"> let str = &#x27;&lt;ul&gt;&#x27;</span><br><span class="line"> for (let i = 0; i &lt; num; i++) &#123;</span><br><span class="line">  str += &#x27;&lt;li&gt;item &#x27; + i + &#x27;&lt;/li&gt;&#x27;</span><br><span class="line">&#125;</span><br><span class="line"> str += &#x27;&lt;/ul&gt;&#x27;</span><br><span class="line"> return str</span><br><span class="line">&#125;</span><br><span class="line">export default HomeList</span><br></pre></td></tr></table></figure>
<p>src&#x2F;index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import HomeList from &#x27;./HomeList&#x27;</span><br><span class="line">remotes: &#123;</span><br><span class="line">    nav</span><br><span class="line">	(&#x27;nav/Header&#x27;)：remotes: &#123; nav &#125;Header    exposes: &#123;./Header&#x27;:&#x27;&#x27;&#125;</span><br><span class="line">import(&#x27;nav/Header&#x27;).then((Header) =&gt; &#123;  //引用模块联邦的组件  这样导入别人组件的时候需要通过异步的方式因为 网络共享或者是模块载入 是由延迟的，所以要通过promise的方式（异步模块加载的形式）去引用它。</span><br><span class="line"> const body = document.createElement(&#x27;div&#x27;)</span><br><span class="line"> body.appendChild(Header.default())</span><br><span class="line"> document.body.appendChild(body)</span><br><span class="line"> document.body.innerHTML += HomeList(5)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">const &#123;</span><br><span class="line"> ModuleFederationPlugin</span><br><span class="line">&#125; = require(&#x27;webpack&#x27;).container</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode: &#x27;production&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(),</span><br><span class="line">  new ModuleFederationPlugin(&#123;</span><br><span class="line">   name: &quot;home&quot;,</span><br><span class="line">   filename: &quot;remoteEntry.js&quot;,</span><br><span class="line">   remotes: &#123;</span><br><span class="line">    nav: &quot;nav@http://localhost:3003/remoteEntry.js&quot;,    // 引用第三方或别人写好的应用的路径。远端的服务路径</span><br><span class="line">  &#125;,</span><br><span class="line">   exposes: &#123;</span><br><span class="line">    &#x27;./HomeList&#x27;: &#x27;./src/HomeList.js&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">   shared: &#123;&#125;,</span><br><span class="line"> &#125;),</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用 webpack 运行服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[felix] nav $ npx webpack serve --port 3001</span><br></pre></td></tr></table></figure>

<p>3、search 搜索<br>src&#x2F;index</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([import(&#x27;nav/Header&#x27;), import(&#x27;home/HomeList&#x27;)])</span><br><span class="line">.then(([&#123;</span><br><span class="line">  default: Header</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  default: HomeList</span><br><span class="line">&#125;]) =&gt; &#123;</span><br><span class="line">  document.body.appendChild(Header())</span><br><span class="line">  document.body.innerHTML += HomeList(4)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">const &#123;</span><br><span class="line"> ModuleFederationPlugin</span><br><span class="line">&#125; = require(&#x27;webpack&#x27;).container</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode: &#x27;production&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(),</span><br><span class="line">  new ModuleFederationPlugin(&#123;</span><br><span class="line">   name: &#x27;search&#x27;,</span><br><span class="line">   filename: &#x27;remoteEntry.js&#x27;,</span><br><span class="line">   remotes: &#123;</span><br><span class="line">    nav: &quot;nav@http://localhost:3003/remoteEntry.js&quot;,</span><br><span class="line">    home: &quot;home@http://localhost:3001/remoteEntry.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">   exposes: &#123;&#125;,</span><br><span class="line">   shared: &#123;&#125;,</span><br><span class="line"> &#125;),</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用 webpack 运行服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[felix] nav $ npx webpack serve --port 3002</span><br></pre></td></tr></table></figure>
<h2 id="十-提升构建性能"><a href="#十-提升构建性能" class="headerlink" title="十. 提升构建性能"></a>十. 提升构建性能</h2><p>澄清：有时候我们会笼统的说webpack的性能提升，实际上webpack的性能提升可以分为两类  第一类是通过webpack来提升我们项目性能  如：网站的首屏到达时间，这个优化的受益者是c端的用户  ，2.提升webpack的构建编译性能，如：提高打包速度，降低打包时间，这个优化的受益者是我们的开发人员。   本章讲的是第二种<br>把官网上提出的webpack5 提升构建性能的点  列：<br><strong>注意：</strong>  webpack 每个版本的优化点都是不一样的<br>通用环境：这些优化既适用于开发化境也适用于生产环境。<br>开发环境：<br>生产环境：<br><strong>通用环境</strong><br>无论你是在 开发环境 还是在 生产环境 下运行构建脚本，以下最佳实践都会有所帮助。</p>
<p>1、更新到最新版本<br>使用最新的 webpack 版本。我们会经常进行性能优化。webpack 的最新稳定版本是：<br>将 Node.js 更新到最新版本，也有助于提高性能。除此之外，将你的 package 管理工具（例如 npm 或者 yarn ）更新到最新版本，也有助于提高性能。较新的版本能够建立更高效的模块树以及提高解析速度。</p>
<p>2、loader<br>将 loader 应用于最少数量的必要模块。而非如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> //...</span><br><span class="line"> module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: /\.js$/,</span><br><span class="line">    loader: &#x27;babel-loader&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line"> ],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过使用 include 字段，仅将 loader 应用在实际需要将其转换的模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> //...</span><br><span class="line"> module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: /\.js$/,</span><br><span class="line">    include: path.resolve(__dirname, &#x27;src&#x27;),</span><br><span class="line">    loader: &#x27;babel-loader&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line"> ],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>3、引导(bootstrap)<br>每个额外的 loader&#x2F;plugin 都有其启动时间。尽量少地使用工具。</p>
<p>4、解析<br>以下步骤可以提高解析速度：<br>减少 resolve.modules , resolve.extensions , resolve.mainFiles ,resolve.descriptionFiles 中条目数量，因为他们会增加文件系统调用的次数。</p>
<p>如果你不使用 symlinks（例如 npm link 或者 yarn link ），可以设置resolve.symlinks: false 。</p>
<p>如果你使用自定义 resolve plugin 规则，并且没有指定 context 上下文，可以设置 resolve.cacheWithContext: false 。</p>
<p>5、小即是快(smaller &#x3D; faster)<br>减少编译结果的整体大小，以提高构建性能。尽量保持 chunk 体积小。使用数量更少&#x2F;体积更小的 library。</p>
<p>在多页面应用程序中使用 SplitChunksPlugin 。<br>在多页面应用程序中使用 SplitChunksPlugin ，并开启 async 模式。<br>移除未引用代码。<br>只编译你当前正在开发的那些代码。</p>
<p>6、持久化缓存<br>在 webpack 配置中使用 cache 选项。使用 package.json 中的 “postinstall”清除缓存目录。<br>将 cache 类型设置为内存或者文件系统。 memory 选项很简单，它告诉 webpack在内存中存储缓存，不允许额外的配置：<br>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> //...</span><br><span class="line"> cache: &#123;</span><br><span class="line">  type: &#x27;memory&#x27;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>7、自定义 plugin&#x2F;loader<br>对它们进行概要分析，以免在此处引入性能问题。<br>8、dll<br>使用 DllPlugin 为更改不频繁的代码生成单独的编译结果。这可以提高应用程序的编译速度，尽管它增加了构建过程的复杂度。</p>
<p>webpack.all.config.js  配置关于dll相关的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">const webpack = require(&#x27;webpack&#x27;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	mode:&#x27;production&#x27;   // 在生产环境下面去做事情</span><br><span class="line">	entry:&#123;</span><br><span class="line">		jquery:[&#x27;jquery&#x27;],</span><br><span class="line">	&#125;,  //注意：这个entry不是配置本地的包，而是要配置我们在node_modules里面安装的第三方的包</span><br><span class="line">	output:&#123;</span><br><span class="line">		filename:&#x27;[name].js&#x27;     // [name]  取到的是本身的jquery的chunk的名字</span><br><span class="line">		path:path.resolve(__dirname,&#x27;dll&#x27;),</span><br><span class="line">		library:&#x27;[name]_[hash]&#x27;    // 把他导出一个库    给这个包起了一个名字，打他导出一个第三方的包。</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins:[</span><br><span class="line">		new webpack.DllPlugin(&#123;</span><br><span class="line">			name:&#x27;[name]_[hash]&#x27;,     //名字和上面library取的名字是一样的</span><br><span class="line">			path:path.resolve(__dirname,&#x27;dll/manifest.json&#x27;)      // 把一个manifest的文件给生成出来</span><br><span class="line">		&#125;)</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package.json</span><br><span class="line">&#123;</span><br><span class="line">	&quot;scripts&quot;:&#123;</span><br><span class="line">		&quot;all&quot;:&quot;webpack --config ./webpack.dll.config.js&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">webpack.config.js</span><br><span class="line">const webpack = require(&#x27;webpack&#x27;)</span><br><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">plugins:[</span><br><span class="line">	new webpack.DllReferencePlugin(&#123;</span><br><span class="line">		manifest:path.resolve(__dirname,&#x27;./all/manifest.json&#x27;)     // 它的值就是刚刚生成的manifest</span><br><span class="line">	&#125;)    //和刚才的DllPlugin做了一个呼应</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>仅仅是提高了构建速度  如果想把jquery放到页面上显示的话还是有些问题的。   还需要对dll文件进行一次打包   可以使用插件来完成<br>npm install add-asset-html-webpack-plugin -D<br>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const AddAssetHtmlPlugin = require(&#x27;add-asset-html-webpack-plugin&#x27;)</span><br><span class="line">plugins:[</span><br><span class="line">	new AddAssetHtmlPlugin(&#123;</span><br><span class="line">		filepath:path.resolve(__dirname,&#x27;./dll/jquery.js&#x27;),</span><br><span class="line">		publicPath:&#x27;./&#x27;</span><br><span class="line">	&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>编译大小有右边回来之前的大小，但是jquery会单独做成一个文件打出来，那我们可以在最后的时候在做一次打包，之前打包的时候可以使用dll这个所谓的link，实时上他还是通过link去加载的我们的jquery.js文件</p>
<p>9、worker 池(worker pool)<br>thread-loader 可以将非常消耗资源的 loader 分流给一个 worker pool。</p>
<p>该怎么去测试worker pool  ，定义：它的实现原理就是我们可以把他定义在其他的loader前面然后把其他的loader放在另外一个worker pool的池里面去运行来提高我们的打包速度，其实就是把他放到另外一个cpu去运行了，来利用我们电脑的cpu。<br>npm install thread-loader -D</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">	rules:[</span><br><span class="line">		&#123;</span><br><span class="line">			test:/\.js$/,</span><br><span class="line">			exclude:/node_modules/,</span><br><span class="line">			use:[</span><br><span class="line">				&#123;</span><br><span class="line">					loader:&#x27;babel-loader&#x27;   //问了提高Babel-loader的打包速度可以把他放在 worker pool里运行（可以在单独的cpu里去运行）</span><br><span class="line">				options:&#123;</span><br><span class="line">					presets:[&#x27;@babel/preset-env&#x27;]   //这样他就可以解析我们js里面的一些es6的代码了</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				&#123;  // thread-loader启动需要大概耗费600ms的时间（有开销），这个loader对耗时非常打的loader有意义。</span><br><span class="line">					loader:&#x27;thread-loader&#x27;,</span><br><span class="line">					options:&#123;</span><br><span class="line">						workers:2    // cpu的数量</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要使用太多的 worker，因为 Node.js 的 runtime 和 loader 都有启动开销。最小化 worker 和 mainprocess(主进程) 之间的模块传输。进程间通讯(IPC,inter process communication)是非常消耗资源的。</p>
<p>10、Progress plugin<br>将 ProgressPlugin 从 webpack 中删除，可以缩短构建时间。请注意，<br>ProgressPlugin 可能不会为快速构建提供太多价值，因此，请权衡利弊再使用。</p>
<p><strong>开发环境</strong><br>以下步骤对于 开发环境 特别有帮助。<br>1、增量编译<br>使用 webpack 的 watch mode(监听模式)。而不使用其他工具来 watch 文件和调用webpack 。内置的 watch mode 会记录时间戳并将此信息传递给 compilation 以使缓存失效。</p>
<p>在某些配置环境中，watch mode 会回退到 poll mode(轮询模式)。监听许多文件会导致 CPU 大量负载。在这些情况下，可以使用 watchOptions.poll 来增加轮询的间隔时间。</p>
<p>2、在内存中编译<br>下面几个工具通过在内存中（而不是写入磁盘）编译和 serve 资源来提高性能：</p>
<p>webpack-dev-server<br>webpack-hot-middleware<br>webpack-dev-middleware<br>3、stats.toJson 加速<br>webpack 4 默认使用 stats.toJson() 输出大量数据。除非在增量步骤中做必要的统计，否则请避免获取 stats 对象的部分内容。 webpack-dev-server 在 v3.1.3 以后的版本，包含一个重要的性能修复，即最小化每个增量构建步骤中，从 stats 对象获取的数据量。</p>
<p>4、Devtool<br>需要注意的是不同的 devtool 设置，会导致性能差异。</p>
<p>“eval” 具有最好的性能，但并不能帮助你转译代码。<br>如果你能接受稍差一些的 map 质量，可以使用 cheap-source-map 变体配置来提高性能<br>使用 eval-source-map 变体配置进行增量编译。</p>
<p>在大多数情况下，最佳选择是 eval-cheap-module-source-map 。</p>
<p>5、避免在生产环境下才会用到的工具<br>某些 utility, plugin 和 loader 都只用于生产环境。例如，在开发环境下使用TerserPlugin 来 minify(压缩) 和 mangle(混淆破坏) 代码是没有意义的。通常在开发环境下，应该排除以下这些工具：</p>
<p>TerserPlugin<br>[fullhash] &#x2F; [chunkhash] &#x2F; [contenthash]<br>AggressiveSplittingPlugin<br>AggressiveMergingPlugin<br>ModuleConcatenationPlugin</p>
<p>6、最小化 entry chunk<br>Webpack 只会在文件系统中输出已经更新的 chunk。某些配置选项（HMR,output.chunkFilename 的 [name] &#x2F; [chunkhash]&#x2F;[contenthash] ，[fullhash] ）来说，除了对已经更新的 chunk 无效之外，对于 entry chunk 也不会生效。<br>确保在生成 entry chunk 时，尽量减少其体积以提高性能。下面的配置为运行时代码创建了一个额外的 chunk，所以它的生成代价较低：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> // ...</span><br><span class="line"> optimization: &#123;</span><br><span class="line">  runtimeChunk: true,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>7、避免额外的优化步骤<br>Webpack 通过执行额外的算法任务，来优化输出结果的体积和加载性能。这些优化适用于小型代码库，但是在大型代码库中却非常耗费性能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> // ...</span><br><span class="line"> optimization: &#123;</span><br><span class="line">  removeAvailableModules: false,</span><br><span class="line">  removeEmptyChunks: false,</span><br><span class="line">  splitChunks: false,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>8、输出结果不携带路径信息<br>Webpack 会在输出的 bundle 中生成路径信息。然而，在打包数千个模块的项目中，这会导致造成垃圾回收性能压力。在 options.output.pathinfo 设置中关闭：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> // ...</span><br><span class="line"> output: &#123;</span><br><span class="line">  pathinfo: false,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>9、Node.js 版本 8.9.10-9.11.1<br>Node.js v8.9.10 - v9.11.1 中的 ES2015 Map 和 Set 实现，存在 性能回退。Webpack 大量地使用这些数据结构，因此这次回退也会影响编译时间。<br>之前和之后的 Node.js 版本不受影响。</p>
<p>10、TypeScript loader<br>你可以为 loader 传入 transpileOnly 选项，以缩短使用 ts-loader 时的构建时间。使用此选项，会关闭类型检查。如果要再次开启类型检查，请使用<br>ForkTsCheckerWebpackPlugin 。使用此插件会将检查过程移至单独的进程，可以加快 TypeScript 的类型检查和 ESLint 插入的速度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> // ...</span><br><span class="line"> test: /\.tsx?$/,</span><br><span class="line"> use: [</span><br><span class="line"> &#123;</span><br><span class="line">   loader: &#x27;ts-loader&#x27;,</span><br><span class="line">   options: &#123;</span><br><span class="line">    transpileOnly: true,</span><br><span class="line">  &#125;,</span><br><span class="line"> &#125;,</span><br><span class="line">],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>生产环境</strong><br>以下步骤对于 生产环境 特别有帮助。<br>Source Maps<br>source map 相当消耗资源。你真的需要它们？</p>
<h2 id="本篇完–"><a href="#本篇完–" class="headerlink" title="-本篇完–"></a>-本篇完–</h2><p><strong>三、项目实战篇</strong></p>
<p>Webpack与React<br>Webpack与Vue<br>Webpack与jQuery<br>Webpck与Node&#x2F;Express</p>
<p><strong>四、内部原理篇</strong><br>webpack原理<br>开发loader plugin</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-webpack/webpack基础" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/11/24/webpack/webpack%E5%9F%BA%E7%A1%80/" class="article-date">
  	<time datetime="2020-11-24T02:08:48.000Z" itemprop="datePublished">2020-11-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/24/webpack/webpack%E5%9F%BA%E7%A1%80/">
        webpack基础
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一-基础感念"><a href="#一-基础感念" class="headerlink" title="一.基础感念"></a>一.基础感念</h2><p>webpack是运行在nodejs中的<br>webpack 的 why 与how</p>
<p>为什么学   （原先script要按顺序）<br>构建打包？习惯使用开箱即用的脚手架来完成项目配置，对开发环境和生产环境的搭建了解知之甚少，前端架构最重要的点在于 前端工程化（webpack就是我们搭建前端环境的技术选型，也是最主流的）</p>
<p>为什么需要使用webpack<br>问题：作用域，文件大（网络瓶颈，短暂白屏），可读性差，可维护性弱</p>
<p>解决：<br>1.作用域：使用grunt和gulp管理项目资源，称之为任务执行器，将所有的项目文件拼接在一起，（利用js的立即调用表达式IIFE）<br>    当函数变成一个立即调用表达式时，表达式的变量是不能在外部访问的，不会污染我们的window环境，解决了作用域问题。<br>    可以通过赋值变量 函数中通过return暴露出来变量获取数据<br><img src="http://hghqz.vip/webpack/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98.jpg" alt="作用域问题" title="作用域问题"></p>
<pre><code>问题使用十行代码可能就要加载万行代码（通过代码拆分解决,模块化，commonjs,amd,cmd,es6）
</code></pre>
<p>node环境语法在浏览器无法加载它不支持commonjs  以及一些其他的语法<br>早期解决方案（页面导入require  define,script标签data-main）<br>现在ECMAscript  通过es6拥有自己的模块化  export default  import from (script 标签指定type&#x3D;”module”)<br>通过http-server搭建一个http请求</p>
<p>es6可能还不太兼容所以使用webpack帮我们打包（vs竞品 parcel称零配置用户一般无需做其他的配置开即聚用 rollup.js用标准化的格式来编写代码es6通过减少无用的代码来尽可能的缩小包的体积，一般只用来打包js  黑马vite vue3使用  有petite vue框架 从开发 编译 发布 demo 几乎全部都是Vite完成的 基于esmodule的构建方式 按需编译 热模块更新  丝滑体验 与vue3原理结合）<br>不会谁取代谁  各有各的应用场景</p>
<h2 id="二-基础应用"><a href="#二-基础应用" class="headerlink" title="二.基础应用"></a>二.基础应用</h2><p><strong>安装使用</strong>（要注意webpack与nodejs版本兼容问题）<br>1.要有nodejs 运行环境<br>2.全局与工作目录下安装<br>    npm install webpack webpack-cli –global  全局 在任何目录都可以运行webpack(不推荐全局使用)<br>    本地安装需要先有npm的包管理的配置文件npm init -y  npm install webpack webpack-cli –save-dev<br><strong>运行</strong><br>1.直接使用 webpack  默认打包  （入口：.&#x2F;src&#x2F;index 出口：dist&#x2F;main.js）<br>2.webpack –stats detailed 可以看到详细的打包信息<br>npx 执行没有找到命令会到上层目录查找</p>
<p><strong>自定义webpack配置</strong><br>webpack –help查看 配置<br>npx 工具概念：<br>命令配置：<br>npx webpack –entry .&#x2F;src&#x2F;index.js –mode production</p>
<p>配置文件配置(webpack.config.js文件名不允许随意起，他是webpack自动读取的)<br><img src="http://hghqz.vip/webpack/%E5%87%BA%E5%85%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE.jpg" alt="出入口基本配置" title="出入口基本配置"><br>path需是绝对路径</p>
<h2 id="三-自动引入资源（插件）（html中引入资源）"><a href="#三-自动引入资源（插件）（html中引入资源）" class="headerlink" title="三.自动引入资源（插件）（html中引入资源）"></a>三.自动引入资源（插件）（html中引入资源）</h2><p><strong>什么是插件：</strong><br>webpack就像是一条生产线，需要经过一系列的流程后才能将源文件（入口文件，可以相互依赖（js,css-loaders加载器））经过编译（工具插件plugins 帮助webpack来执行一些特定的任务（打包优化，资源管理））转化成输出的结果</p>
<p>插件：三组（community社区插件   webpack内置官方插件   webpack contrib 第三方插件）</p>
<p><strong>如何使用htmlWebpackPlugin?</strong><br>npm install html-webpack-plugin -D</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin)</span></span><br><span class="line"><span class="string">module.exports=&#123;</span></span><br><span class="line"><span class="string">	plugins:[</span></span><br><span class="line"><span class="string">		new HtmlWebpackPlugin(&#123;</span></span><br><span class="line"><span class="string">			template:&#x27;</span>./index.<span class="property">html</span><span class="string">&#x27;,</span></span><br><span class="line"><span class="string">			filename:&#x27;</span>app.<span class="property">html</span><span class="string">&#x27;,</span></span><br><span class="line"><span class="string">			inject:&#x27;</span>body<span class="string">&#x27;</span></span><br><span class="line"><span class="string">		&#125;)</span></span><br><span class="line"><span class="string">	]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>清理上次dist里的垃圾</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output</span>:&#123;</span><br><span class="line">	<span class="attr">filename</span>:    ,</span><br><span class="line">	<span class="attr">path</span>:    ,</span><br><span class="line">	<span class="attr">clean</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-搭建开发环境"><a href="#四-搭建开发环境" class="headerlink" title="四.搭建开发环境"></a>四.搭建开发环境</h2><p>解决手工工作：复制index.html路径到地址栏才能访问页面，每次更新代码都需要刷新页面。通过搭建开发环境来解决，提高开发体验</p>
<p>mode:’development’  开发模式   通过代码对环境进行调试（core.js模块）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;build&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=production webpack --config webpack.config.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;start&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=development webpack serve&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">const</span> isDev = process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&quot;development&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>精准锁定代码出错的位置</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devtool</span>:<span class="string">&#x27;inline-source-map&#x27;</span>,</span><br></pre></td></tr></table></figure>
<p><strong>使用watch mode(观察模式)</strong><br>每次编译都要手动运行npx webpack<br>npx webpack –watch   实时监测编译变化 （需要重新刷新页面）</p>
<p><strong>webpack-dev-server</strong><br>为我们提供了一个最基本的web server，并具有live reloading（实时重新加载）功能。当页面修改了编译后浏览器会监听到文件的修改实现自动刷新<br>npm install webpack-dev-server -D</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins</span>:&#123;</span><br><span class="line">	<span class="attr">devServer</span>:&#123;</span><br><span class="line">		<span class="attr">static</span>: <span class="string">&#x27;./dist&#x27;</span> #server的根目录</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>npx debpack-dev-server –open(自动打开一个页面)  启动项目   实际是吧数据的打包以后的bundle文件放到了内存里。提高开发效率和webpack的编译效率</p>
<h2 id="五-资源模块加载"><a href="#五-资源模块加载" class="headerlink" title="五.资源模块加载"></a>五.资源模块加载</h2><p>内置资源模块asset modules来引入任何的其他类型资源   是一种模块类型  它允许我们用webpack来打包其他的资源文件 如：字体，图标等<br>资源模块类型：asset module type   会通过四种新的类型模块来替换所有的loader<br>1.asset&#x2F;resource他会发送一个单独的文件并导出URL  2.asset&#x2F;inline 它会导出一个资源的Data URL<br>3.asset&#x2F;source 会导出资源的源代码<br>4.asset 通用资源类型 会在导出一个Data URL 和发送一个单独的文件之间自动进行选择</p>
<p>module配置模块</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output</span>:&#123;</span><br><span class="line">	<span class="attr">assetModuleFilename</span>:<span class="string">&#x27;images/[contenthash].[ext]&#x27;</span> <span class="comment">//自动生成一个文件名//根据文件的内容来生成一个哈希的字符串</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">module</span>:&#123;</span><br><span class="line">	<span class="attr">rules</span>:&#123; <span class="comment">//规则</span></span><br><span class="line">		&#123;  <span class="comment">//配置对象来去加载不同类型的文件</span></span><br><span class="line">			<span class="attr">test</span>: <span class="string">&#x27;/\.png$/&#x27;</span>, <span class="comment">//test 更正则表达式 来加载定义文件的类型</span></span><br><span class="line">		 	<span class="attr">type</span>:<span class="string">&#x27;asset/resource&#x27;</span>,<span class="comment">// 图片为URL格式</span></span><br><span class="line">			<span class="attr">generator</span>:&#123; <span class="comment">// 优先级高于在output 配置的优先级</span></span><br><span class="line">				<span class="attr">filename</span>:<span class="string">&#x27;images/[contenthash].[ext]&#x27;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">test</span>: <span class="string">&#x27;/\.svg$/&#x27;</span>,</span><br><span class="line">			<span class="attr">type</span>: <span class="string">&#x27;asset/inline&#x27;</span> <span class="comment">//图片为base64格式</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">test</span>: <span class="string">&#x27;/\.txt$/&#x27;</span>,</span><br><span class="line">			<span class="attr">type</span>: <span class="string">&#x27;asset/source&#x27;</span> <span class="comment">// 加载文件的源内容</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">test</span>: <span class="string">&#x27;/\.jpg$/&#x27;</span>,</span><br><span class="line">			<span class="attr">type</span>: <span class="string">&#x27;asset&#x27;</span>, <span class="comment">//会在导出一个Data URL 和发送一个单独的文件之间自动进行选择   小于8k生成base64  大于8k创建资源</span></span><br><span class="line">			<span class="attr">parser</span>:&#123;</span><br><span class="line">				<span class="attr">dataUrlCondition</span>:&#123;</span><br><span class="line">					<span class="attr">maxSize</span>:<span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>  <span class="comment">// 当突变大于4兆在生成一个资源文件  否则的话就是base64</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六-loader"><a href="#六-loader" class="headerlink" title="六.loader"></a>六.loader</h2><p>上面采用四种资源模块来引入外部资源<br>webpack还可以通过loader引入其他类型的文件<br>webpack智能理解js和json这样的文件<br>loader可以让webpack去解析其他的类型的文件  并且将这些文件转化为有效的模块  以供我们应用程序的使用  例如加载css</p>
<p><strong>如何使用</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>:&#123;</span><br><span class="line">	<span class="attr">rules</span>:&#123;</span><br><span class="line">		&#123; <span class="comment">//当碰到通过require或import去解析 .txt文件时在对文件进行打包之前先使用raw-loader进行转化</span></span><br><span class="line">			<span class="attr">test</span>: <span class="string">&#x27;/\.txt$/&#x27;</span>, <span class="comment">// 定义那种类型的文件被转换</span></span><br><span class="line">		 	<span class="attr">use</span>:<span class="string">&#x27;raw-loader&#x27;</span>,  <span class="comment">// 在定义转化的时候应该使用哪个loader来进行转换</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何配置</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>:&#123;</span><br><span class="line">	<span class="attr">rules</span>:&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">test</span>: <span class="string">&#x27;/\.css$/&#x27;</span>,</span><br><span class="line">		 	<span class="attr">use</span>:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>],  <span class="comment">// 自下而上 loader链式调用  先需要用css-loader让我们打包没有问题识别我们css文件   在通过style-loader把css放置到我们的页面上</span></span><br><span class="line">		&#125;，</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">test</span>: <span class="string">&#x27;/\.(css|less)/$&#x27;</span>,</span><br><span class="line">		 	<span class="attr">use</span>:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;less-loader&#x27;</span>],</span><br><span class="line">		&#125;，</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>抽离和压缩css</strong><br>抽离：npm install mini-css-extract-plugin -D   这个插件时基于webpack5构建的<br>压缩：npm install css-minimizer-webpack-plugin -D  这个属于优化插件在optimization选项配置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CssMinimizerWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;css-minimizer-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="attr">mode</span>:<span class="string">&#x27;production&#x27;</span>,   <span class="comment">//使用压缩环境必须时这个</span></span><br><span class="line"><span class="attr">plugins</span>:&#123;</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">		<span class="attr">filename</span>:<span class="string">&#x27;style/[contenthash].css&#x27;</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="attr">module</span>:&#123;</span><br><span class="line">	<span class="attr">rules</span>:&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">test</span>: <span class="string">&#x27;/\.(css|less)/$&#x27;</span>,</span><br><span class="line">		 	<span class="attr">use</span>:[<span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;less-loader&#x27;</span>],  <span class="comment">//之前通过style-loader 将样式放到页面的style 更改为通过link引入的css文件</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attr">optimization</span>:&#123;</span><br><span class="line">	<span class="attr">minimizer</span>:[</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">CssMinimizerWebpackPlugin</span>()</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>加载image图像</strong><br>如何在css里加载图片资源<br>mode:’development’   清除提示</p>
<p><strong>加载fonts字体</strong><br>css3中新增webfont功能可以在css3中去加载一个font字库  然后在代码中就可以定义自己的icon图标了<br>如何去加载字体这样的资源（asset module资源模块）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">test</span>:<span class="string">&#x27;/\.(woff|woff2|eot|ttf|otf)$/&#x27;</span>,  <span class="comment">//字体文件会有很多种类型</span></span><br><span class="line">	<span class="attr">type</span>:<span class="string">&#x27;asset/resource&#x27;</span>  <span class="comment">//载入任何类型的资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://hghqz.vip/webpack/%E5%AD%97%E4%BD%93%E9%85%8D%E7%BD%AE.jpg" alt="字体配置" title="字体配置"></p>
<p>之后向文本一样去加载一个文本代码  <span class='icon'>&amp;#xe668;</span>(操作dom时必须是innerhtml不能使innertext)</p>
<p><strong>加载数据</strong><br>之前图片  cion图标  文本文件等等都数据<br>还有类似于json，csv，tsv，xml等，json和nodejs类似webpack可以直接支持但是像csv，tsv和xml我都没需要使用loader才能处理他们<br>npm install csv-loader xml-loader -D</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">text</span>:<span class="string">&#x27;/\.(tsv|csv)$/&#x27;</span>, <span class="comment">//会转换成 数组 </span></span><br><span class="line">	<span class="attr">use</span>:<span class="string">&#x27;csv-loader&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">text</span>:<span class="string">&#x27;/\.xml$/&#x27;</span>,  <span class="comment">//会转换成 js对象</span></span><br><span class="line">	<span class="attr">use</span>:<span class="string">&#x27;xml-loader&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自定义JSON模块parser</strong><br>通过使用自定义parser替代指定的webpack loader，可以将任何toml，yaml，或json5文件作为JSON模块导入。<br>npm install toml yaml json5 -D</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const toml = require(&#x27;toml&#x27;)</span><br><span class="line">const yaml = require(&#x27;yaml&#x27;)</span><br><span class="line">const json5 = require(&#x27;json5&#x27;)</span><br><span class="line">&#123;</span><br><span class="line">	text:&#x27;/\.toml$/&#x27;,  //会转换成 js对象</span><br><span class="line">	type:&#x27;json&#x27;,</span><br><span class="line">	parser:&#123;</span><br><span class="line">		parse:toml.parse</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">	text:&#x27;/\.yaml$/&#x27;,  //会转换成 js对象</span><br><span class="line">	type:&#x27;json&#x27;,</span><br><span class="line">	parser:&#123;</span><br><span class="line">		parse:yaml.parse</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">	text:&#x27;/\.json5$/&#x27;,  //会转换成 js对象</span><br><span class="line">	type:&#x27;json&#x27;,</span><br><span class="line">	parser:&#123;</span><br><span class="line">		parse:json5.parse</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七-如何使用babel-loader"><a href="#七-如何使用babel-loader" class="headerlink" title="七.如何使用babel-loader"></a>七.如何使用babel-loader</h2><p>webpack默认转换  是源代码原封不动进行转换的  那么如果浏览器不兼容呢？<br>使用babel-loader将es6 转换成低版本浏览器能够识别的js代码<br>npm install babel-loader @babal&#x2F;core @babel&#x2F;preset-env -D<br>babel-loader: 解析es6的桥梁<br>@babal&#x2F;core babel： 核心模块<br>@babel&#x2F;preset-env： babel预设，一组Babel插件的集合</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">test</span>:<span class="string">&#x27;/\.js$/&#x27;</span>,</span><br><span class="line">	<span class="attr">exclude</span>:<span class="string">&#x27;/node_modules/&#x27;</span>,<span class="comment">//业务里既可以加载本地js也可以加载全局里的node modules里面的js  对于全局的node modules里的js我们是不需要进行babel-loader的编译的  所以需要排除 node modules 里的代码</span></span><br><span class="line">	<span class="attr">use</span>:&#123;</span><br><span class="line">		<span class="attr">loader</span>:<span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">			<span class="attr">options</span>:&#123;</span><br><span class="line">				<span class="attr">presets</span>:[<span class="string">&#x27;@babel/preset-env&#x27;</span>],</span><br><span class="line">				<span class="attr">plugins</span>:[</span><br><span class="line">					[<span class="string">&#x27;@babel/plugin-transform-runtime&#x27;</span>]</span><br><span class="line">				]</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>regeneratorRuntime是webpack打包生成的全局辅助函数，有babel生成，用于兼容async&#x2F;await的语法<br>npm install @babel&#x2F;runtime -D<br>插件： npm install @babel&#x2F;plugin-transform-runtime -D<br>@babel&#x2F;runtime： 包含了regeneratorRuntime运行时需要的内容<br>@babel&#x2F;plugin-transform-runtime： 会在需要regeneratorRuntime的地方自动require打包然后编译的时候就会需要它</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">					[&#x27;@babel/plugin-transform-runtime&#x27;]</span><br><span class="line">				]</span><br></pre></td></tr></table></figure>

<h2 id="八-代码分离"><a href="#八-代码分离" class="headerlink" title="八.代码分离"></a>八.代码分离</h2><p>能够把代码分离到不同的bundle中<br>bundle就是我们打包分离出来的文件然后我们把这些文件按需加载或者是并行加载<br>代码分离可以用于获取更小的bundle以及控制资源加载的优先级，如果使用合理会极大的影响加载事件<br>常用的代码分离：1.配置入口节点，使用entry来手动配置分离代码（如果是多个入口那么这些多个入口共享的文件会分别在每个包里面去重复打包）<br>2.防止重的分离方法：在entry（入口）的地方通过entry dependencies或者 SplitChunksPlagin去重和分离代码<br>3.动态导入 通过模块的内联函数import来调用这个函数分离代码</p>
<p><strong>第一种</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">entry</span>:&#123;</span><br><span class="line">	<span class="attr">index</span>:<span class="string">&#x27;./src/index&#x27;</span>,</span><br><span class="line">	<span class="attr">another</span>:<span class="string">&#x27;./src/another-module.js&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attr">output</span>:&#123;</span><br><span class="line">	<span class="attr">filename</span>:<span class="string">&#x27;[name]&#x27;</span>.<span class="property">bundle</span>.<span class="property">js</span>,   <span class="comment">//方式多个入口打包出口文件冲突，使用[&#x27;name&#x27;]可以拿到我们入口里面的key的名字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="property">log</span>（_.<span class="title function_">join</span>([<span class="string">&#x27;Vue&#x27;</span>,<span class="string">&#x27;React!&#x27;</span>],<span class="string">&#x27;-&#x27;</span>)）</span><br></pre></td></tr></table></figure>
<p><strong>第二种 防止重复</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 1.entry dependencies</span><br><span class="line">entry:&#123;</span><br><span class="line">	index:&#123;</span><br><span class="line">		import :&#x27;./src/index&#x27;,</span><br><span class="line">		dependOn:&#x27;shared&#x27;,  //可以把一些共享的文件给定义出来</span><br><span class="line">	&#125;,</span><br><span class="line">	another:&#123;</span><br><span class="line">		import :&#x27;./src/another-module.js&#x27;,</span><br><span class="line">		dependOn:&#x27;shared&#x27;,  //可以把一些共享的文件给定义出来</span><br><span class="line">	&#125;</span><br><span class="line">	shared:&#x27;lodash&#x27; //当我们这两个模块里边 有lodash这个模块的时候  他就会把他抽离出来  并且把他取名为叫shared这样的一个chunk。</span><br><span class="line">&#125;</span><br><span class="line">//2.SplitChunksPlagin插件</span><br><span class="line">entry:&#123;</span><br><span class="line">	index:&#x27;./src/index&#x27;,</span><br><span class="line">	another:&#x27;./src/another-module.js&#x27;</span><br><span class="line">&#125;</span><br><span class="line">optimization:&#123;</span><br><span class="line">	splitChunks:&#123;</span><br><span class="line">		chunks:&#x27;all&#x27;  //实现代码分割并把公共的代码 抽离到一个单独的文件里</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>第三种</strong><br>使用  ECMAScript提案的import()函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function getComponent()&#123;</span><br><span class="line">	return import(&#x27;lodash&#x27;)   // 返回的是一个Promise对象</span><br><span class="line">	.then((&#123;default:_&#125;)=&gt;&#123;    // .then的回调函数拿到的是 载入的lodash的一个引用</span><br><span class="line">		const element = document.createElement(&#x27;div&#x27;)</span><br><span class="line">		element.innerHTML = _.join([&#x27;Vue&#x27;,&#x27;React!&#x27;],&#x27;-&#x27;)</span><br><span class="line">		return element</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"> // 这样写的目的是为了让 import 来去帮助我们去抽离一个单独的lodash文件</span><br><span class="line">getComponent().then((element)=&gt;&#123;</span><br><span class="line">	document.body.appendChild(element)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 静态导入的内容和动态导入的内容一起来 去做代码抽离</span><br><span class="line">optimization:&#123;</span><br><span class="line">	splitChunks:&#123;</span><br><span class="line">		chunks:&#x27;all&#x27;  //实现代码分割并把公共的代码 抽离到一个单独的文件里</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>为什么使用动态导入，静态导入不就行了吗？动态导入的应用</strong><br>1.可以实现懒加载： 按需加载，是一种很好的优化页面或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会加载。<br><img src="http://hghqz.vip/webpack/import%E6%87%92%E5%8A%A0%E8%BD%BD.jpg" alt="import懒加载" title="import懒加载"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//懒加载</span><br><span class="line">import(/* webpackChunkName: &#x27;打包后的文件名&#x27;*/&#x27;文件地址&#x27;).then(回调)//通过注释 控制懒加载打包后的文件名  +bundle.js</span><br></pre></td></tr></table></figure>

<p>2.可以实现预获取&#x2F;预加载模块<br>webpack v4.6.0+ 增加了对预获取和预加载的支持。<br>在声明import时，使用下面这些内置指令，可以让webpack输出”resource hint(资源提示)”,来告诉浏览器：<br>prefetch(预获取)：将来某些导航下可能需要的资源<br>preload(预加载)：当前导航下可能需要资源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 预获取   意义首页面的内容都加载完毕在网络空闲的时候再去加载我们打包好的 文件     比懒加载还要优秀</span><br><span class="line">import(/* webpackChunkName: &#x27;打包后的文件名&#x27;, webpackPrefetch:true*/&#x27;文件地址&#x27;)</span><br><span class="line">// 预加载   和懒加载类似   实现页面模块的并行加载</span><br><span class="line">import(/* webpackChunkName: &#x27;打包后的文件名&#x27;, webpackPreload:true*/&#x27;文件地址&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="九-缓存"><a href="#九-缓存" class="headerlink" title="九.缓存"></a>九.缓存</h2><p>以前我们使用webpack来打包我们模块化以后的应用程序，webpack会生成一个可以部署的dist目录。然后我们把打包好的内容放置到这个目录里将来我们把这个目录的内容部署到server上也就是服务器上，浏览器就可以访问我们这个服务器上的网站和资源了，而最后一步获取资源是比较耗时间的，这就是为什么浏览器会使用缓存的技术，可以通过命中缓存以降低网络流量，使网站加载速度更快，然而我们在部署新版本的时候不更改资源的文件名，浏览器可能会认为你没有更新，那就会使用它的缓存版本，由于缓存的存在，我们需要获取新的代码的时候，就会显的很棘手，<br>现在我们通过webpack配置来确保编译生成的文件能够被客户端缓存而在文件优化的时候又能够请求新的文件。<br>问题：在dist文件里看到打包好以后的文件，浏览器有缓存特性会把文件缓存下来，但是如果我们修改了这个文件里的内容，而文件名没有变，浏览器会认为我们没有修改这个文件，所以我们必须在打包的时候把这个文件的名字也一同给重新打包</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output</span>:&#123;</span><br><span class="line">	<span class="attr">filename</span>:<span class="string">&#x27;[name].[contenthash].js&#x27;</span>  <span class="comment">//文件名 会跟随这我们文件内容的变化而变化，这样的话就不怕浏览器缓存了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>缓存第三方库代码，如：lodash需不需要缓存</strong><br>缓存自己的业务逻辑代码，第三方的代码比如lodash需不需要缓存。<br>如果我们把lodash单独提取到一个vendor chunk里边，是比较推荐的方法，这是因为他们很少像本地源代码那样频繁修改。因此通过以上的步骤，我们利用client或浏览器的长效缓存的机制，命中的缓存来消除请求。从而减少向server获取资源的次数同时还能保证client代码和server代码版本的一致。<br>把第三方库的代码像lodash单独打包缓存到浏览器里，这样只有我们自己代码发生变化的时候我们可以去更新但是第三方的代码始终可以是浏览器缓存的内容，那就需要对第三方的代码做一个缓存。<br>对文件进行单独打包并缓存到浏览器里，代码（文件内容以及文件名都是不变的）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">optimization</span>:&#123;</span><br><span class="line">	splitChunks：&#123;</span><br><span class="line">		<span class="attr">cacheGroups</span>:&#123;    <span class="comment">//定义缓存组    缓存第三方文件（node_modules里的）</span></span><br><span class="line">			<span class="attr">vendor</span>:&#123;</span><br><span class="line">				<span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>  <span class="comment">//通过文件目录的文件名去识别   这个目录的前面后面可能会有斜线</span></span><br><span class="line">				<span class="attr">name</span>:<span class="string">&#x27;vendors&#x27;</span>,</span><br><span class="line">				<span class="attr">chunks</span>:<span class="string">&#x27;all&#x27;</span>         <span class="comment">// 定义那些chunk做处理</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>将所有的js文件，放到一个文件夹中</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">	filename:&#x27;scripts/[name].[contenthash].js&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结：缓存业务代码：当我们的项目部署到服务器上的时候，浏览器加载完我们服务器上的文件会缓存我们打包好的模块。这样如果我们修改了js代码，文件名如果没变，浏览器会使用用户本地缓存的内容，就获取不到新的内容了。因此我们通过修改输出文件的文件名来解决   使用可替换模板字符串方法来定义contenthash   实现只要文件的内容不变哈希的字符串也不变<br>缓存第三方代码：这些文件不频繁更新  可以提高我们首屏的打开速度 节省我们网络流量</p>
<h2 id="十-拆分开发环境和生产环境的配置-让打包变得更灵活"><a href="#十-拆分开发环境和生产环境的配置-让打包变得更灵活" class="headerlink" title="十.拆分开发环境和生产环境的配置  让打包变得更灵活"></a>十.拆分开发环境和生产环境的配置  让打包变得更灵活</h2><p>平常我们都是手动的调整mode选项  实现生产环境和开发环境的切换<br>很多配置在生产环境和开发环境存在不一致的情况如：开发环境没有必要设置缓存，生产环境还需要设置公共路径等</p>
<p><strong>公共路径</strong><br>publicPash 配置选项在各种场景中都非常有用，可以通过它来指定应用程序中所有资源的基础路径</p>
<p>现在所有的资源都是通过相对路径来去引用的。我们可不可以根据cdn的路径或者当前服务器的某个路径 来去修改我们link上面的这个路径的前缀。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">	publicPash: &#x27;http://localhost:8080/&#x27;    // 指定一个域名    这个域名可以指定为项目的前端域名，或者cdn服务器的域名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>环境变量</strong><br>可以帮助我们清除webpack.config.js这个配置文件里边的开发环境和生产环境之间的差异<br>在命令行 npx webpack –env production (–env goal&#x3D;local)    知道用户在开发环境使用还是生产环境使用  配置对应的mode选项<br>将导出的对象变为函数，函数拿到env   生产环境代码压缩  开发环境代码不压缩</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mode:env.production?&#x27;production&#x27;:&#x27;development&#x27;</span><br></pre></td></tr></table></figure>
<p>webpack开箱即用的terser插件进行压缩js代码  当我们配置minimizer压缩css代码时  terser功能失效<br>npm install terser-webpack-plugin -D</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const TerserPlugin = require(&#x27;terser-webpack-plugin&#x27;)</span><br><span class="line">optimization:&#123;</span><br><span class="line">	minimizer:&#123;</span><br><span class="line">		//此处时压缩css的插件</span><br><span class="line">		new TerserPlugin()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>拆分配置文件</strong><br>我们使用环境变量将webpack中的生产环境和开发环境的区别都通过三元运算符判断  很糟糕<br>我们将配置文件拆分成两个配置  一个生产环境  一个开发环境<br>只当启动配置文件 npx webpack -c .&#x2F;config&#x2F;webpack.config.dev.js</p>
<p><strong>npm脚本</strong><br>每次打包或者启动服务的时候 都需要在命令行里输入一长串的命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package.json文件</span><br><span class="line">&#123;</span><br><span class="line">	&quot;scripts&quot;:&#123;</span><br><span class="line">		&quot;start&quot;:&quot;npx webpack serve -c ./config/webpack.config.dev.js --env development&quot;,</span><br><span class="line">		&quot;build&quot;:&quot;npx wenpack -c ./config/webpack.config.prod.js --env production&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产环境进行打包  提示我们在打包的时候超过了打包的预期</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">performance:&#123;   // 性能方面配置</span><br><span class="line">	hints:false   //性能提示去掉</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>提取公共配置</strong><br>开发环境和生产环境  配置有大量的重复代码   把这些重复代码单独抽到一个配置文件里<br>npm install webpack-merge -D</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">webpack.config.common.js   //通过深merge进行合并三个文件   插件：webpack-merge</span><br><span class="line">webpack.config.js   //这里合并三个文件</span><br><span class="line">const &#123;merge&#125; = require(&#x27;webpack-merge&#x27;)</span><br><span class="line">const commonConfig = require(&#x27;./webpack.config.common.js&#x27;)</span><br><span class="line">const developmentConfig = require(&#x27;./webpack.config.dev.js&#x27;)</span><br><span class="line">const productionConfig = require(&#x27;./webpack.config.prod.js&#x27;)</span><br><span class="line">module.exports = (env)=&gt;&#123;</span><br><span class="line">	switch(true)&#123;</span><br><span class="line">		case env.development:</span><br><span class="line">			return merge(commonConfig,developmentConfig)</span><br><span class="line">		case env.production:</span><br><span class="line">			return merge(commonConfig,productionConfig)</span><br><span class="line">		default:</span><br><span class="line">			return new Error(&#x27;没有找到对应的配置环境&#x27;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-webpack/webpack构建流程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/11/20/webpack/webpack%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/" class="article-date">
  	<time datetime="2020-11-20T08:31:42.000Z" itemprop="datePublished">2020-11-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/20/webpack/webpack%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/">
        webpack构建流程
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、运行流程"><a href="#一、运行流程" class="headerlink" title="一、运行流程"></a>一、运行流程</h2><p><code>webpack</code> 的运行流程是一个串行的过程，它的工作流程就是将各个插件串联起来</p>
<p>在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条<code>webpack</code>机制中，去改变<code>webpack</code>的运作，使得整个系统扩展性良好</p>
<p>从启动到结束会依次执行以下三大步骤：</p>
<ul>
<li>初始化流程：从配置文件和 <code>Shell</code> 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数</li>
<li>编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理</li>
<li>输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统</li>
</ul>
<p><img src="https://static.vue-js.com/b566d400-a658-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><p>从配置文件和 <code>Shell</code> 语句中读取与合并参数，得出最终的参数</p>
<p>配置文件默认下为<code>webpack.config.js</code>，也或者通过命令的形式指定配置文件，主要作用是用于激活<code>webpack</code>的加载项和插件</p>
<p>关于文件配置内容分析，如下注释：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> node_modules = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;node_modules&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> pathToReact = path.<span class="title function_">resolve</span>(node_modules, <span class="string">&#x27;react/dist/react.min.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 入口文件，是模块构建的起点，同时每一个入口文件对应最后生成的一个 chunk。</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./path/to/my/entry/file.js&#x27;</span>，</span><br><span class="line">  <span class="comment">// 文件路径指向(可加快打包过程)。</span></span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;react&#x27;</span>: pathToReact</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 生成文件，是模块构建的终点，包括输出文件与输出路径。</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 这里配置了处理各模块的 loader ，包括 css 预处理 loader ，es6 编译 loader，图片处理 loader。</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">loaders</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;babel&#x27;</span>,</span><br><span class="line">        <span class="attr">query</span>: &#123;</span><br><span class="line">          <span class="attr">presets</span>: [<span class="string">&#x27;es2015&#x27;</span>, <span class="string">&#x27;react&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">noParse</span>: [pathToReact]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// webpack 各插件对象，在 webpack 的事件流中执行对应的方法。</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">HotModuleReplacementPlugin</span>()</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack` 将 `webpack.config.js` 中的各个配置项拷贝到 `options` 对象中，并加载用户配置的 `plugins</span><br></pre></td></tr></table></figure>

<p>完成上述步骤之后，则开始初始化<code>Compiler</code>编译对象，该对象掌控者<code>webpack</code>声明周期，不执行具体的任务，只是进行一些调度工作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Compiler</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Tapable</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">context</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">hooks</span> = &#123;</span><br><span class="line">            <span class="attr">beforeCompile</span>: <span class="keyword">new</span> <span class="title class_">AsyncSeriesHook</span>([<span class="string">&quot;params&quot;</span>]),</span><br><span class="line">            <span class="attr">compile</span>: <span class="keyword">new</span> <span class="title class_">SyncHook</span>([<span class="string">&quot;params&quot;</span>]),</span><br><span class="line">            <span class="attr">afterCompile</span>: <span class="keyword">new</span> <span class="title class_">AsyncSeriesHook</span>([<span class="string">&quot;compilation&quot;</span>]),</span><br><span class="line">            <span class="attr">make</span>: <span class="keyword">new</span> <span class="title class_">AsyncParallelHook</span>([<span class="string">&quot;compilation&quot;</span>]),</span><br><span class="line">            <span class="attr">entryOption</span>: <span class="keyword">new</span> <span class="title class_">SyncBailHook</span>([<span class="string">&quot;context&quot;</span>, <span class="string">&quot;entry&quot;</span>])</span><br><span class="line">            <span class="comment">// 定义了很多不同类型的钩子</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">webpack</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> compiler = <span class="keyword">new</span> <span class="title class_">Compiler</span>();</span><br><span class="line">  ...<span class="comment">// 检查options,若watch字段为true,则开启watch线程</span></span><br><span class="line">  <span class="keyword">return</span> compiler;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>Compiler</code> 对象继承自 <code>Tapable</code>，初始化时定义了很多钩子函数</p>
<h3 id="编译构建流程"><a href="#编译构建流程" class="headerlink" title="编译构建流程"></a>编译构建流程</h3><p>根据配置中的 <code>entry</code> 找出所有的入口文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/file.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化完成后会调用<code>Compiler</code>的<code>run</code>来真正启动<code>webpack</code>编译构建流程，主要流程如下：</p>
<ul>
<li><code>compile</code> 开始编译</li>
<li><code>make</code> 从入口点分析模块及其依赖的模块，创建这些模块对象</li>
<li><code>build-module</code> 构建模块</li>
<li><code>seal</code> 封装构建结果</li>
<li><code>emit</code> 把各个chunk输出到结果文件</li>
</ul>
<h4 id="compile-编译"><a href="#compile-编译" class="headerlink" title="compile 编译"></a>compile 编译</h4><p>执行了<code>run</code>方法后，首先会触发<code>compile</code>，主要是构建一个<code>Compilation</code>对象</p>
<p>该对象是编译阶段的主要执行者，主要会依次下述流程：执行模块创建、依赖收集、分块、打包等主要任务的对象</p>
<h4 id="make-编译模块"><a href="#make-编译模块" class="headerlink" title="make 编译模块"></a>make 编译模块</h4><p>当完成了上述的<code>compilation</code>对象后，就开始从<code>Entry</code>入口文件开始读取，主要执行<code>_addModuleChain()</code>函数，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">_addModuleChain</span>(<span class="params">context, dependency, onModule, callback</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 根据依赖查找对应的工厂函数</span></span><br><span class="line">   <span class="keyword">const</span> <span class="title class_">Dep</span> = <span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">DepConstructor</span>&#125; */</span> (dependency.<span class="property">constructor</span>);</span><br><span class="line">   <span class="keyword">const</span> moduleFactory = <span class="variable language_">this</span>.<span class="property">dependencyFactories</span>.<span class="title function_">get</span>(<span class="title class_">Dep</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 调用工厂函数NormalModuleFactory的create来生成一个空的NormalModule对象</span></span><br><span class="line">   moduleFactory.<span class="title function_">create</span>(&#123;</span><br><span class="line">       <span class="attr">dependencies</span>: [dependency]</span><br><span class="line">       ...</span><br><span class="line">   &#125;, <span class="function">(<span class="params">err, <span class="variable language_">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">const</span> <span class="title function_">afterBuild</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">processModuleDependencies</span>(<span class="variable language_">module</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">callback</span>(err);</span><br><span class="line">         <span class="title function_">callback</span>(<span class="literal">null</span>, <span class="variable language_">module</span>);</span><br><span class="line">           &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">       </span><br><span class="line">       <span class="variable language_">this</span>.<span class="title function_">buildModule</span>(<span class="variable language_">module</span>, <span class="literal">false</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">           ...</span><br><span class="line">           <span class="title function_">afterBuild</span>();</span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过程如下：</p>
<p><code>_addModuleChain</code>中接收参数<code>dependency</code>传入的入口依赖，使用对应的工厂函数<code>NormalModuleFactory.create</code>方法生成一个空的<code>module</code>对象</p>
<p>回调中会把此<code>module</code>存入<code>compilation.modules</code>对象和<code>dependencies.module</code>对象中，由于是入口文件，也会存入<code>compilation.entries</code>中</p>
<p>随后执行<code>buildModule</code>进入真正的构建模块<code>module</code>内容的过程</p>
<h4 id="build-module-完成模块编译"><a href="#build-module-完成模块编译" class="headerlink" title="build module 完成模块编译"></a>build module 完成模块编译</h4><p>这里主要调用配置的<code>loaders</code>，将我们的模块转成标准的<code>JS</code>模块</p>
<p>在用<code>Loader</code> 对一个模块转换完后，使用 <code>acorn</code> 解析转换后的内容，输出对应的抽象语法树（<code>AST</code>），以方便 <code>Webpack</code>后面对代码的分析</p>
<p>从配置的入口模块开始，分析其 <code>AST</code>，当遇到<code>require</code>等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系</p>
<h3 id="输出流程"><a href="#输出流程" class="headerlink" title="输出流程"></a>输出流程</h3><h4 id="seal-输出资源"><a href="#seal-输出资源" class="headerlink" title="seal 输出资源"></a>seal 输出资源</h4><p><code>seal</code>方法主要是要生成<code>chunks</code>，对<code>chunks</code>进行一系列的优化操作，并生成要输出的代码</p>
<p><code>webpack</code> 中的 <code>chunk</code> ，可以理解为配置在 <code>entry</code> 中的模块，或者是动态引入的模块</p>
<p>根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>Chunk</code>，再把每个 <code>Chunk</code> 转换成一个单独的文件加入到输出列表</p>
<h4 id="emit-输出完成"><a href="#emit-输出完成" class="headerlink" title="emit 输出完成"></a>emit 输出完成</h4><p>在确定好输出内容后，根据配置确定输出的路径和文件名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>Compiler</code> 开始生成文件前，钩子 <code>emit</code> 会被执行，这是我们修改最终文件的最后一个机会</p>
<p>从而<code>webpack</code>整个打包过程则结束了</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="https://static.vue-js.com/d77fc560-a658-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-webpack/webpack概念" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/11/14/webpack/webpack%E6%A6%82%E5%BF%B5/" class="article-date">
  	<time datetime="2020-11-14T07:31:05.000Z" itemprop="datePublished">2020-11-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/14/webpack/webpack%E6%A6%82%E5%BF%B5/">
        webpack概念
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、webpack概述"><a href="#一、webpack概述" class="headerlink" title="一、webpack概述"></a>一、webpack概述</h1><h2 id="1-什么是webpack？"><a href="#1-什么是webpack？" class="headerlink" title="1. 什么是webpack？"></a>1. 什么是webpack？</h2><p>webpack被定义为现代 JavaScript 应用程序的静态模块打包器(module bundler)，是目前最为流行的JavaScript打包工具之一。</p>
<p>webpack会以一个或多个js文件为入口，递归检查每个js模块的依赖，从而构建一个依赖关系图(dependency graph)，然后依据该关系图，将整个应用程序打包成一个或多个bundle。</p>
<p>由于webpack是用nodejs编写的，所以它依赖的运行环境就是nodejs。也正因为这一点，webpack只能识别JavaScript，所有非JavaScript（包括HTML，CSS，Typescript等）编写的文件都需要经过处理，这是借助对应的loader实现的。</p>
<p>webpack使用的是nodejs默认的模块系统：commonjs，借助nodejs提供的API来操作待打包项目的源文件（如fs模块、path模块等）。webpack将这些文件整合压缩后，输出到一个特定的目录下（通常是dist）。处理过的dist一般会被直接上传到静态资源服务器使用。</p>
<p>webpack 是一个开源的前端包工具。webpack 提供了前端开发缺乏的模块化开发方式,将各种静态资源视为模块,并从它生成优化过的代码。 要使用 webpack 前须先安装 node.js。</p>
<p>webpack是前端的一个自动化工具,有了它可以大大提高写项目的效率,可以对css,js文件进行自动压缩,把sass代码自动解析成对应的css文件,让你的代码和样式实时的显示在浏览器上,当然,我们使用webpack的目的还是为了项目完成后进行打包,webpack并不强制使用AMD或者CMD这之中的某一种方案,而是通过兼容所有模块化方案让你可以按需接入项目，有了webpack，你可以随意选择你喜欢的模块化方案，至于怎么处理模块之间的依赖关系及如何按需打包，webpack会帮你处理好。</p>
<h2 id="2-为什么要使用webpack？"><a href="#2-为什么要使用webpack？" class="headerlink" title="2. 为什么要使用webpack？"></a>2. 为什么要使用webpack？</h2><p>第一，未打包的项目通常体积庞大，文件数量众多。如果将其直接上传到服务器，用户访问网站时，浏览器会发送大量的http请求来下载这些文件，这会给服务器带来很大的压力，同时客户端的体验也非常不好。</p>
<p>第二，浏览器本身不支持任何模块系统。因此，使用模块系统开发出的JavaScript代码无法直接在浏览器中运行，而模块系统对现代JavaScript开发是非常重要的。这样，我们需要有一个工具，将模块系统编写出的代码转化为浏览器所能识别的代码。webpack就可以完成这一任务。</p>
<p>第三，大多数情况下，我们不希望源代码暴露给用户，即使是保密性要求不那么高的前端代码。我们知道，PC端浏览器通常都提供开发者工具，可以方便地查看和调试前端代码，这在开发环境下意义重大。但对于生产环境，暴露源代码不仅没有太大意义，反而存在安全隐患（如果黑客比你更先发现代码中的bug，你可能面临严重损失）。因此，我们可以借助webpack重组和混淆源代码，增加黑客阅读源代码的难度，以提升系统的安全性。</p>
<p>第四，借助webpack提供的dev-server，可以实现前后端分离。dev-server本质上就是一个node服务。当通过命令行启用dev-server时，webpack会在本地启动一个node服务，将打包后的文件作为静态资源注入该服务，这样就可以在不依赖后台（这种说法并不完全准确，实际上webpack是通过node为你提供后台服务）的情况下进行前端开发了。</p>
<p>除了以上这些，webpack还有很多强大的功能，这里暂不详述。</p>
<h2 id="3-工作原理"><a href="#3-工作原理" class="headerlink" title="3. 工作原理"></a>3. 工作原理</h2><p>简单的说就是分析代码，找到“require”、“exports”、“define”等关键词，并替换成对应模块的引用。</p>
<p>在一个配置文件中，指明对某些文件进行编译、压缩、组合等任务。把你的项目当成一个整体，通过一个给定的主文件 （index.js），webpack将从这个文件开始找到你的项目的所有的依赖文件，使用loaders处理他们，最后打包为一个浏览器可以识别的js文件。</p>
<p>流程细节<br>Webpack的构建流程可以分为以下三个阶段：</p>
<ol>
<li>初始化：启动构建，读取与合并配置参数，加载Plugin，实例化Complier.</li>
<li>编译：从Entry出发，针对每个Module串行调用对应的Loader去翻译文件内容，再找到该Module依赖的Module，递归地进行编译处理。</li>
<li>输出： 对编译后的Module组合成Chunk，把Chunk转换成文件，输出到文件系统。<br> 如果只执行一次构建，以上阶段将会按照顺序各执行一次。但在开启监听模式下，流程将变为如下：<br> <img src="http://hghqz.vip/webpack/%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B.jpg" alt="打包流程" title="打包流程"></li>
</ol>
<h2 id="4-webpack的优缺点？"><a href="#4-webpack的优缺点？" class="headerlink" title="4. webpack的优缺点？"></a>4. webpack的优缺点？</h2><p>优点：<br>（1） webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD&#x2F;CMD 的支持也很全面，方便旧项目进行代码迁移。<br>（2）能被模块化的不仅仅是 JS 了。<br>（3） 开发便捷，能替代部分 grunt&#x2F;gulp 的工作，比如打包、压缩混淆、图片转base64等。<br>（4）扩展性强，插件机制完善<br>缺点：<br>● 配置复杂<br>● 不分包bundle.js体积庞大<br>● 只能用于采用模块化开发的项目<br>● 打包慢<br>● ES模块除Module外全用babel转换，但是一部分ES2015 语法的 firefox 与 chrome 浏览器中能直接跑的代码，无法用 webpack 编译</p>
<h2 id="5-基本配置"><a href="#5-基本配置" class="headerlink" title="5. 基本配置"></a>5. 基本配置</h2><p>要在项目中使用webpack，需要首先安装nodejs，它是webpack的运行环境。nodejs安装成功后，就可以通过npm install webpack -g来全局安装webpack。这样就可以在你的项目中使用webpack了。</p>
<p>在项目中使用webpack的核心是编写配置文件。配置文件通常命名为webpack.config.js，是一个符合commonjs规范的js文件。该文件通过module.exports暴露出一个js对象，我们称这个对象为webpack的配置对象（options）。webpack会根据这个配置对象来决定如何打包项目。</p>
<p>配置对象中包含四个核心参数：</p>
<p>入口（entry）Entry:入口指示webpack以哪个文件为入口起点开始打包，分析构建内部依赖图<br>出口（output）output:输出指示webpack的打包后的资源bundles输出到哪里去，以及如何命名<br>加载器（loader）Loader:让webpack能够去处理哪些非JavaScrip文件（webpack自身只理解javaScript)<br>插件（plugin） plugin:插件可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等<br>插件（mode） mode:模式指示webpack使用相应模式的配置</p>
<h3 id="1-入口（entry）"><a href="#1-入口（entry）" class="headerlink" title="1. 入口（entry）"></a>1. 入口（entry）</h3><p>顾名思义，它定义了webpack的打包入口，也就是webpack从哪个js开始打包。</p>
<p>一个应用程序可以有一个或多个入口，由entry属性指定，通常是一个对象。如果这个对象内只包含了一个入口，也可以简写为一个字符串（或字符串数组）。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &quot;./src/main.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可以简写为:</span><br><span class="line">  entry: &quot;./src/main.js&quot;</span><br></pre></td></tr></table></figure>
<p>上述配置定义src目录下的main.js为打包入口，webpack将从这个文件开始，构建整个项目的依赖关系图。</p>
<p>一个应用程序可以有多个打包入口，常见的场景如多页应用，独立打包第三方库等：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  app: &#x27;./src/app.js&#x27;,</span><br><span class="line">  vendors: &#x27;./src/vendors.js&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的配置，要求webpack分别以app.js和vendors.js为打包入口，独立构建依赖关系图。最终，项目代码和第三方代码将被独立打包出来。构建多页应用时，也是分别为每个页面提供一个入口文件，独立构建依赖图。</p>
<p>此外，入口参数允许传入字符串数组。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry: [&quot;./src/main1.js&quot;, &quot;./src/main2.js&quot;]</span><br></pre></td></tr></table></figure>
<p>这两个文件都是应用的主入口，它们会被打包生成到同一个chunk文件中。当主入口文件过于庞大，需要拆分成多个，但希望它们输出到同一个打包文件时可以使用。</p>
<h3 id="2-出口（output）"><a href="#2-出口（output）" class="headerlink" title="2. 出口（output）"></a>2. 出口（output）</h3><p>也就是webpack的输出，由output属性定义。</p>
<p>与入口不同的是，一个应用程序只能有一个出口。出口是一个对象，包含两个属性：filename和path，分别定义打包结果的文件名和输出位置。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &quot;./src/main.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;bundle.js&#x27;,</span><br><span class="line">    path: path.resolve(__dirname + &#x27;/dist&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上配置定义main.js为应用的入口文件，最终输出的文件名为bundle.js，输出位置是当前路径下的dist文件夹。</p>
<p>当应用程序由多个打包入口时，产生的输出结果也会有很多个，一一为每个文件指定文件名非常不灵活。为此，webpack允许使用占位符来定义文件名。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &#x27;./src/app.js&#x27;,</span><br><span class="line">    search: &#x27;./src/search.js&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;[name].js&#x27;,</span><br><span class="line">    path: path.resolve(__dirname + &#x27;/dist&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打包将输出app.js和search.js两个文件</span><br></pre></td></tr></table></figure>
<p>这里filename的值中[name]就是使用了占位符，webpack会将其替换成入口文件的文件名。因此，app.js和search.js这两个入口文件在打包后会在dist文件夹下生成两个同名文件。</p>
<p>当然，我们几乎从来不会这样定义filename，因为固定的文件名无法用于热更新（HMR，Hot Module Replacement，直译为模块热替换）。热更新的实现机制如下：</p>
<p>在一份清单文件（manifest文件）中列举所有依赖的模块，每个模块对应的文件名中带有一个版本号，如chunk.1.0.0.js。<br>当某个模块发生修改，就重新打包该模块，并修改对应文件名中的版本号，如chunk.1.0.1.js。此时文件名就发生了变化。<br>热更新机制检测到清单文件中的文件名发生变化，就会重新下载和更新该模块，文件名没有变化的模块不会被重新下载。这样应用就得到了更新。<br>由于webpack不需要对每次的代码修改都进行版本管理，所以它只需要向文件名中插入一个随机的hash值即可。这个hash值每次重新打包都会变化，以保证热更新机制可以正确更新。假如某次打包后的文件名为app.23j3j2366842h76ewhd.js，随后我们对该模块进行了修改，重新打包后webpack插入了一个新的hash值，得到app.er234hh9hydyt586.js。热更新模块检测到文件名变化，就会自动下载这个新的js文件，来更新应用的状态。</p>
<p>此时的出口一般写成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &#x27;./src/app.js&#x27;,</span><br><span class="line">    search: &#x27;./src/search.js&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;[name].[hash].js&#x27;,</span><br><span class="line">    path: path.resolve(__dirname + &#x27;/dist&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这会输出两个类似于app.57bjs8k8rfht7.js和search.su774fju83jur.js的打包结果，它们会被添加到一份清单文件。每当修改模块的内容，webpack都会重新打包，生成新的hash值，并更新清单文件，这样热更新机制就可以生效了。</p>
<p>注意，使用splitChunk进行代码分割时，被分割出来的代码默认命名为chunk.[hash].js。</p>
<h3 id="3-加载器（loader）"><a href="#3-加载器（loader）" class="headerlink" title="3. 加载器（loader）"></a>3. 加载器（loader）</h3><p>在介绍加载器之前，我们先来看webpack打包时会遇到的一个问题。</p>
<p>在概述中我们已经讲到，webpack的运行环境是nodejs，因此它只能识别JavaScript。但是我们的项目中可能存在大量的非JavaScript文件，如HTML、CSS、Typescript、txt，甚至图片文件等。</p>
<p>有人可能会说，webpack又不需要执行这些文件，直接输出到dist目录下不就行了吗？</p>
<p>如果这些非JavaScript文件只被js文件引用，而他们之间互相没有依赖关系，webpack确实没必要解析他们。但当它们存在依赖关系时，问题就不这么简单了，如：<br>index.css</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;./color.css&quot;</span><br></pre></td></tr></table></figure>
<p>这里index.css中引入了color.css。我们假设index.css是在js中引入的，那么webpack在解析js时自然会把index.css添加到依赖关系图中。</p>
<p>可是webpack运行在nodejs环境下，它无法解析index.css的内容，因此它不知道index.css内部还依赖了color.css。这样，color.css就无法被添加到依赖关系图中，而不在依赖关系图中的文件在打包时将被舍弃。也即是说，webpack最终打包出的代码中不会包含color.css。</p>
<p>这显然是错误的，我们需要color.css。</p>
<p>为了解决这个问题，我们需要一些额外的代码帮助webpack识别css文件中的依赖。我们会编写一个函数，它将index.css读取为一个字符串，然后转化成js（注意，转化成js只是为了让webpack解析依赖关系，因此转化出的js与原css并不等价）输出出来，这样webpack就可以解析了。而这个用于转换的函数，就称为一个loader。</p>
<p>所以，一个加载器（loader）实际上就是一个将特定的字符串转化成JavaScript代码的函数。换个角度来说，一个loader就是一个字符串处理函数。</p>
<p>通常，为了保证loader便于测试和复用，每个loader不会写的很复杂，实现的功能也有限。所以一个文件通常需要多个loader来处理。比如对于一个css文件，我们至少需要两个loader：css-loader和style-loader。前者用于解析css文件，后者用于将css注入到HTML文件中。style-loader会把css添加为页内样式（即直接把样式放在head中的<style>标签内），如果你希望打包出单独的css文件，需要使用extract-loader。</p>
<p>如果你希望为css文件定义loader，可以这样写（当然你需要使用npm先安装这些loader）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; </span><br><span class="line">        test: /\.css$/, </span><br><span class="line">        use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] </span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它的含义是，对.css结尾的文件，使用’css-loader’和’style-loader’这两个loader。webpack将依次从后向前执行每个loader。比如在解析到index.css时，它将经历以下步骤：</p>
<p>使用nodejs的fs模块读取index.css，将读取到的字符串交给css-loader。<br>执行css-loader。它是一个函数，将原始字符串进行一定的处理，输出一个新的字符串。<br>将上一步输出的字符串交给style-loader，进行第二步处理，最终仍然输出一个字符串。<br>由webpack解析最终的处理结果。<br>因为webpack采用的是流式处理，所以loader的书写顺序非常重要，最先需要执行的loader必须放在数组的最后。</p>
<p>基于这个原理，我们也可以自行手写loader，来满足特定的需求。比如官方没有关于.txt文本文件的loader，所以webpack不能解析文本文件中所包含的依赖（因为文本文件没有任何格式约定，所以无法定义一个普适的loader）。如果你的项目中有需要解析的文本文件，并且它们有严格的格式要求，那么你就可以自行实现一个loader，实现对这类资源的打包。具体实现方法见webpack中文网 - 编写一个 loader。</p>
<h3 id="4-插件（plugin）"><a href="#4-插件（plugin）" class="headerlink" title="4. 插件（plugin）"></a>4. 插件（plugin）</h3><p>一个插件就是一个对webpack功能的定制或扩展。</p>
<p>loader的使用场景是有限的，它只能用来帮助webpack加载非js文件。如果我们想在webpack打包的任何一个过程中添加某些特定的功能，就需要借助插件来实现。它是webpack灵活性的一大体现，也是webpack的支柱功能，因为webpack自身就是构建于插件系统之上的。</p>
<p>比如，我们想要在webpack开始构建时执行某些操作，就可以定义一个像下面的插件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const pluginName = &#x27;ConsoleLogOnBuildWebpackPlugin&#x27;;</span><br><span class="line"></span><br><span class="line">class ConsoleLogOnBuildWebpackPlugin &#123;</span><br><span class="line">    apply(compiler) &#123;</span><br><span class="line">        compiler.hooks.run.tap(pluginName, compilation =&gt; &#123;</span><br><span class="line">            console.log(&quot;webpack 构建过程开始！&quot;);</span><br><span class="line">            console.log(&quot;当前时间：&quot; + new Date());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在webpack配置文件中这样使用插件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const ConsoleLogOnBuildWebpackPlugin = require(&#x27;ConsoleLogOnBuildWebpackPlugin&#x27;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line">    new ConsoleLogOnBuildWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，webpack在开始构建时，就会执行我们的console.log方法。当然，你可以定制的功能远不止这些，这里只是向你展示插件的基本用法。</p>
<p>我们看到，一个插件就是一个带有apply原型方法的类（也可以是一个构造函数，并且它的原型对象上有apply方法，两者是等价的）。在配置文件中使用new关键字会创建一个插件实例，webpack将所有插件定义的回调函数注册到对应的生命周期钩子上。当webpack执行到对应的阶段时，就会调用这些钩子函数，实现插件定制的功能。</p>
<p>插件可以传入一个配置对象，用于构造插件实例。而插件上的原型方法apply会被webpack所调用，webpack会将编译器对象compiler传入apply方法。该对象在整个编译过程中都是可用的。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function HelloWorldPlugin(options) &#123;</span><br><span class="line">  // 使用 options 设置插件实例</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HelloWorldPlugin.prototype.apply = function(compiler) &#123;</span><br><span class="line">  compiler.plugin(&#x27;done&#x27;, function(compilation) &#123;</span><br><span class="line">    console.log(&#x27;Hello World!&#x27;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = HelloWorldPlugin;</span><br></pre></td></tr></table></figure>
<p>我们在配置文件中传入的配置对象options会被构造函数接收，用于构造插件实例，在apply方法中可以通过this获得。</p>
<p>然后我们在插件的原型上定义了一个apply方法，webpack解析配置文件时会执行它，并传入webpack的编译器对象。我们通过语句compiler.plugin(‘done’,function(compilation){…}为webpack的编译器对象注册了一个done阶段（即打包完成）的回调函数。当webpack打包完成时，会调用这个函数，并传入当前webpack的编译器状态对象：compilation。</p>
<p>我们可以借助compiler和compilation这两个对象，在任何一个阶段执行我们想执行的操作。前者是编译器对象，后者是当前状态对象。具体编写插件的方法请参考webpack中文网 - 编写一个插件。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-webpack/webpack多页面应用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/11/09/webpack/webpack%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8/" class="article-date">
  	<time datetime="2020-11-09T15:48:17.000Z" itemprop="datePublished">2020-11-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/09/webpack/webpack%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8/">
        webpack多页面应用
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>entry配置</strong><br>在实际项目的开发中一个完整的系统不会将所有的功能都放在一个网页上，因为这样会导致网页的性能不佳，实际可以按照功能模块划分多个单页应用每个单页应用又生处一个html文件并且随着业务的发展更多的单页应用可以被逐渐的加入到这个项目里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">entry: [&#x27;./src/file_1.js&#x27;, &#x27;./src/file_2.js&#x27;，&#x27;node_modules里的模块 lodash&#x27;],</span><br><span class="line">entry:&#123;</span><br><span class="line">	main:[&#x27;./src/file_1.js&#x27;, &#x27;./src/file_2.js&#x27;],    //这里使用lodash  还会打包在这里打包一遍</span><br><span class="line">	lodash:&#x27;lodash&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">entry:&#123;</span><br><span class="line">	main:&#123;</span><br><span class="line">	import :[&#x27;./src/file_1.js&#x27;, &#x27;./src/file_2.js&#x27;],  //这两个文件可能依赖于lodash，而lodash单独打包了，所以dependOn这个依赖可以把公共的lodash给抽离出来            lodash  就不会在打包一遍了</span><br><span class="line">	dependOn:&#x27;lodash&#x27;,           // 做依赖  这里的lodash  是下面的对应名  可以随意起</span><br><span class="line">	&#125;,    //这里使用lodash  还会打包在这里打包一遍</span><br><span class="line">	lodash:&#x27;lodash&#x27;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象语法会比较繁琐。然而，这是应用程序中定义入口的最可扩展的方式。<br>描述入口的对象：<br>用于描述入口的对象。你可以使用如下属性：<br>dependOn : 当前入口所依赖的入口。它们必须在该入口被加载前被加载。<br>filename : 指定要输出的文件名称。<br>import : 启动时需加载的模块。<br>library : 指定 library 选项，为当前 entry 构建一个 library。<br>runtime : 运行时 chunk 的名字。如果设置了，就会创建一个新的运行时<br>chunk。在 webpack 5.43.0 之后可将其设为 false 以避免一个新的运行时<br>chunk。<br>publicPath : 当该入口的输出文件在浏览器中被引用时，为它们指定一个公共<br>URL 地址。请查看 output.publicPath。<br>webpack.config.js<br>runtime 和 dependOn 不应在同一个入口上同时使用，所以如下配置无效，并且会<br>抛出错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line">  a2: &#x27;dependingfile.js&#x27;,</span><br><span class="line">  b2: &#123;</span><br><span class="line">   dependOn: &#x27;a2&#x27;,</span><br><span class="line">   import: &#x27;./src/app.js&#x27;,</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line">  a2: &#x27;./a&#x27;,</span><br><span class="line">  b2: &#123;</span><br><span class="line">   runtime: &#x27;x2&#x27;,</span><br><span class="line">   dependOn: &#x27;a2&#x27;,</span><br><span class="line">   import: &#x27;./b&#x27;,</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>确保 runtime 不能指向已存在的入口名称，例如下面配置会抛出一个错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line">  a1: &#x27;./a&#x27;,</span><br><span class="line">  b1: &#123;</span><br><span class="line">   runtime: &#x27;a1&#x27;,</span><br><span class="line">   import: &#x27;./b&#x27;,</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另外 dependOn 不能是循环引用的，下面的例子也会出现错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line">  a3: &#123;</span><br><span class="line">   import: &#x27;./a&#x27;,</span><br><span class="line">   dependOn: &#x27;b3&#x27;,</span><br><span class="line"> &#125;,</span><br><span class="line">  b3: &#123;</span><br><span class="line">   import: &#x27;./b&#x27;,</span><br><span class="line">   dependOn: &#x27;a3&#x27;,</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>配置index.html模板</strong><br>要生成多个HTML文件，请在插件数组中多次声明插件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line"> 	main:&#123;</span><br><span class="line">		import :[],</span><br><span class="line">		dependOn:&#x27;lodash2&#x27;,</span><br><span class="line">		filename:&#x27;chanel1.[name].js&#x27;</span><br><span class="line">	&#125;,</span><br><span class="line">	lodash2:&#123;</span><br><span class="line">		import :&#x27;lodash&#x27;,</span><br><span class="line">		filename:&#x27;common/[name].js&#x27;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line"> plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(), // Generates default index.html</span><br><span class="line">  new HtmlWebpackPlugin(&#123;  // Also generate a test.html</span><br><span class="line">   title:   &#x27;ejs&#x27;,     //在页面可以使用ejs模板语法获取数据</span><br><span class="line">   filename: &#x27;chanel1/test.html&#x27;,                      //执行打包后的页面文件     输出的文件名</span><br><span class="line">   template: &#x27;src/assets/test.html&#x27;       //指定模板的路径</span><br><span class="line">   inject:&#x27;body/head&#x27;,                       // 定义当前所生成的script标签的位置</span><br><span class="line">   chunks:[&#x27;自定义那个入口  如：main.js&#x27;]，              //规定当前页面到底打包那些chunk   如何实现多个页面去载入不同的chunk   chunk就是我们在路口配置的项    每一项就是一个chunk  默认会把所有chunk都放进去</span><br><span class="line">   publicPash:&#x27;http://www.a.com/&#x27;        //包的前缀</span><br><span class="line"> &#125;)</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title  %&gt;&lt;/title&gt;  options.就是我们在HtmlWebpackPlugin定制的选项</span><br><span class="line">index.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;/&gt;</span><br><span class="line">  &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>多页面应用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#123;</span><br><span class="line">  pageOne: &#x27;./src/pageOne/index.js&#x27;,</span><br><span class="line">  pageTwo: &#x27;./src/pageTwo/index.js&#x27;,</span><br><span class="line">  pageThree: &#x27;./src/pageThree/index.js&#x27;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是什么？ 我们告诉 webpack 需要三个独立分离的依赖图（如上面的示例）</p>
<p>为什么？ 在多页面应用程序中，server 会拉取一个新的 HTML 文档给你的客户端。<br>页面重新加载此新文档，并且资源被重新下载。然而，这给了我们特殊的机会去做很<br>多事，例如使用 optimization.splitChunks 为页面间共享的应用程序代码创建<br>bundle。由于入口起点数量的增多，多页应用能够复用多个入口起点之间的大量代<br>码&#x2F;模块，从而可以极大地从这些技术中受益。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-webpack/webpack的理解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/11/01/webpack/webpack%E7%9A%84%E7%90%86%E8%A7%A3/" class="article-date">
  	<time datetime="2020-11-01T02:06:57.000Z" itemprop="datePublished">2020-11-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/01/webpack/webpack%E7%9A%84%E7%90%86%E8%A7%A3/">
        webpack的理解
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p><code>Webpack</code> 最初的目标是实现前端项目的模块化，旨在更高效地管理和维护项目中的每一个资源</p>
<h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>最早的时候，我们会通过文件划分的形式实现模块化，也就是将每个功能及其相关状态数据各自单独放到不同的<code>JS</code> 文件中</p>
<p>约定每个文件是一个独立的模块，然后再将这些<code>js</code>文件引入到页面，一个<code>script</code>标签对应一个模块，然后调用模块化的成员</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;module-a.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;module-b.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但这种模块弊端十分的明显，模块都是在全局中工作，大量模块成员污染了环境，模块与模块之间并没有依赖关系、维护困难、没有私有空间等问题</p>
<p>项目一旦变大，上述问题会尤其明显</p>
<p>随后，就出现了命名空间方式，规定每个模块只暴露一个全局对象，然后模块的内容都挂载到这个对象中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">moduleA</span> = &#123;</span><br><span class="line">  <span class="attr">method1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;moduleA#method1&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式也并没有解决第一种方式的依赖等问题</p>
<p>再后来，我们使用立即执行函数为模块提供私有空间，通过参数的形式作为依赖声明，如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module-a.js</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params">$</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;module-a&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">method1</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name + <span class="string">&#x27;#method1&#x27;</span>)</span><br><span class="line">    $(<span class="string">&#x27;body&#x27;</span>).<span class="title function_">animate</span>(&#123; <span class="attr">margin</span>: <span class="string">&#x27;200px&#x27;</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">moduleA</span> = &#123;</span><br><span class="line">    <span class="attr">method1</span>: method1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(jQuery)</span><br></pre></td></tr></table></figure>

<p>上述的方式都是早期解决模块的方式，但是仍然存在一些没有解决的问题。例如，我们是用过<code>script</code>标签在页面引入这些模块的，这些模块的加载并不受代码的控制，时间一久维护起来也十分的麻烦</p>
<p>理想的解决方式是，在页面中引入一个<code>JS</code>入口文件，其余用到的模块可以通过代码控制，按需加载进来</p>
<p>除了模块加载的问题以外，还需要规定模块化的规范，如今流行的则是<code>CommonJS</code>、<code>ES Modules</code></p>
<h2 id="二、问题"><a href="#二、问题" class="headerlink" title="二、问题"></a>二、问题</h2><p>从后端渲染的<code>JSP</code>、<code>PHP</code>，到前端原生<code>JavaScript</code>，再到<code>jQuery</code>开发，再到目前的三大框架<code>Vue</code>、<code>React</code>、<code>Angular</code></p>
<p>开发方式，也从<code>javascript</code>到后面的<code>es5</code>、<code>es6、7、8、9、10</code>，再到<code>typescript</code>，包括编写<code>CSS</code>的预处理器<code>less</code>、<code>scss</code>等</p>
<p>现代前端开发已经变得十分的复杂，所以我们开发过程中会遇到如下的问题：</p>
<ul>
<li>需要通过模块化的方式来开发</li>
<li>使用一些高级的特性来加快我们的开发效率或者安全性，比如通过ES6+、TypeScript开发脚本逻辑，通过sass、less等方式来编写css样式代码</li>
<li>监听文件的变化来并且反映到浏览器上，提高开发的效率</li>
<li>JavaScript 代码需要模块化，HTML 和 CSS 这些资源文件也会面临需要被模块化的问题</li>
<li>开发完成后我们还需要将代码进行压缩、合并以及其他相关的优化</li>
</ul>
<p>而<code>webpack</code>恰巧可以解决以上问题</p>
<h2 id="三、是什么"><a href="#三、是什么" class="headerlink" title="三、是什么"></a>三、是什么</h2><p><code>webpack</code> 是一个用于现代<code>JavaScript</code>应用程序的静态模块打包工具</p>
<ul>
<li>静态模块</li>
</ul>
<p>这里的静态模块指的是开发阶段，可以被 <code>webpack</code> 直接引用的资源（可以直接被获取打包进<code>bundle.js</code>的资源）</p>
<p>当 <code>webpack</code>处理应用程序时，它会在内部构建一个依赖图，此依赖图对应映射到项目所需的每个模块（不再局限<code>js</code>文件），并生成一个或多个 <code>bundle</code></p>
<p><img src="https://static.vue-js.com/9ce194a0-a578-11eb-85f6-6fac77c0c9b3.png" alt="img"></p>
<h4 id="webpack的能力："><a href="#webpack的能力：" class="headerlink" title="webpack的能力："></a><code>webpack</code>的能力：</h4><p><strong>编译代码能力</strong>，提高效率，解决浏览器兼容问题 <img src="https://static.vue-js.com/c5c2d360-a592-11eb-ab90-d9ae814b240d.png" alt="img"><strong>模块整合能力</strong>，提高性能，可维护性，解决浏览器频繁请求文件的问题 <img src="https://static.vue-js.com/d306d260-a592-11eb-ab90-d9ae814b240d.png" alt="img"><strong>万物皆可模块能力</strong>，项目维护性增强，支持不同种类的前端模块类型，统一的模块化方案，所有资源文件的加载都可以通过代码控制 <img src="https://static.vue-js.com/e3c5a040-a592-11eb-ab90-d9ae814b240d.png" alt="img"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-webpack/webpack创建library" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/10/31/webpack/webpack%E5%88%9B%E5%BB%BAlibrary/" class="article-date">
  	<time datetime="2020-10-31T06:21:26.000Z" itemprop="datePublished">2020-10-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/31/webpack/webpack%E5%88%9B%E5%BB%BAlibrary/">
        webpack创建library
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>除了打包应用程序，webpack 还可以用于打包 JavaScript library。<br>例如：当我们想要自己开发一个组件库工具或者框架的时候也就是说我们自己造一个轮子给别人用的时候我们免不了要开发很多的模块，最终都可以请webpack来帮我们打包。</p>
<p><strong>创建一个 library</strong><br>假设我们正在编写一个名为 webpack-numbers 的小的 library，可以将数字 1 到 5转换为文本表示，反之亦然，例如将 2 转换为 ‘two’。<br>使用 npm 初始化项目，然后安装 webpack ， webpack-cli 和 lodash ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack webpack-cli lodash -D</span><br></pre></td></tr></table></figure>
<p>我们将 lodash 安装为 devDependencies 而不是 dependencies ，因为我们不需要将其打包到我们的库中，否则我们的库体积很容易变大。</p>
<p>src&#x2F;ref.json</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num&quot;: 1,</span><br><span class="line">  &quot;word&quot;: &quot;One&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num&quot;: 2,</span><br><span class="line">  &quot;word&quot;: &quot;Two&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num&quot;: 3,</span><br><span class="line">  &quot;word&quot;: &quot;Three&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num&quot;: 4,</span><br><span class="line">  &quot;word&quot;: &quot;Four&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num&quot;: 5,</span><br><span class="line">  &quot;word&quot;: &quot;Five&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num&quot;: 0,</span><br><span class="line">  &quot;word&quot;: &quot;Zero&quot;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>src&#x2F;index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import _ from &#x27;lodash&#x27;;</span><br><span class="line">import numRef from &#x27;./ref.json&#x27;;</span><br><span class="line">export function numToWord(num) &#123;</span><br><span class="line"> return _.reduce(</span><br><span class="line">  numRef,</span><br><span class="line"> (accum, ref) =&gt; &#123;</span><br><span class="line">   return ref.num === num ? ref.word : accum;</span><br><span class="line"> &#125;,</span><br><span class="line">  &#x27;&#x27;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">export function wordToNum(word) &#123;</span><br><span class="line"> return _.reduce(</span><br><span class="line">  numRef,</span><br><span class="line"> (accum, ref) =&gt; &#123;</span><br><span class="line">   return ref.word === word &amp;&amp; word.toLowerCase() ? ref.num :</span><br><span class="line">accum;</span><br><span class="line"> &#125;,</span><br><span class="line">  -1</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> mode:&#x27;production&#x27;,</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">  filename: &#x27;webpack-numbers.js&#x27;,</span><br><span class="line">  library:&#123;</span><br><span class="line">    name:&#x27;webpackNumbers&#x27;,</span><br><span class="line">	type&#x27;umd&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  globalObject:&#x27;globalThis&#x27;</span><br><span class="line">&#125;,</span><br><span class="line"> externals:&#123;</span><br><span class="line"> 	lodash:&#123;   lodash  引入包的名字</span><br><span class="line">		commonjs:&#x27;lodash&#x27;,   //  兼容引入形式</span><br><span class="line">		commonjs2:&#x27;lodash&#x27;,</span><br><span class="line">		amd:&#x27;lodash&#x27;,</span><br><span class="line">		root:&#x27;_&#x27;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>发布到线上</strong><br>拥有npm账号<br>npm config get registry   &#x2F;&#x2F; 一定要保证本地的registry的地址是<a target="_blank" rel="noopener" href="https://registry.npmjs.org/">https://registry.npmjs.org/</a>    因为这样的话才是真正的连接到npm官网的地址上   有些人可能是淘宝  那么就访问不上去了<br>npm adduser  &#x2F;&#x2F;添加用户   输入用户名密码<br>包的名字必须是全球唯一的。   npm publish    上传时package.json中的main入口必须对应：dist&#x2F;文件名   因为别人通过 require去载入包的时候  会读取 这个main这是的暴露的包的名字<br>npm install 包名就可以下载了</p>
<p><strong>Webpack 配置</strong></p>
<p>webpack.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">	path:&#x27;&#x27;,</span><br><span class="line">	filname:&#x27;&#x27;,</span><br><span class="line">	library:&#x27;&#x27;,    //我们只是定义了导出 并且没有使用它  所以webpack认为这个代码是没有用的。   如何让他作为一个library来进行一个对外的打包   让代码不被 Webpack Tree shaking   配置 library:&#x27;包的名字&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到目前为止，一切都应该与打包应用程序一样，这里是不同的部分 - 我们需要通过output.library 配置项暴露从入口导出的内容。<br>我们暴露了 webpackNumbers ，以便用户可以通过 script 标签使用。	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://example.org/webpack-numbers.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> window.webpackNumbers.wordToNum(&#x27;Five&#x27;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>然而它只能通过被 script 标签引用而发挥作用，它不能运行在 CommonJS、AMD、Node.js 等环境中。<br>作为一个库作者，我们希望它能够兼容不同的环境，也就是说，用户应该能够通过以下方式使用打包后的库：<br>CommonJS module require:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const webpackNumbers = require(&#x27;webpack-numbers&#x27;);</span><br><span class="line">// ...</span><br><span class="line">webpackNumbers.wordToNum(&#x27;Two&#x27;);</span><br></pre></td></tr></table></figure>
<p>AMD module require:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require([&#x27;webpackNumbers&#x27;], function (webpackNumbers) &#123;</span><br><span class="line"> // ...</span><br><span class="line"> webpackNumbers.wordToNum(&#x27;Two&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>script tag:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br><span class="line"> &lt;script src=&quot;https://example.org/webpack-numbers.js&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">  // ...</span><br><span class="line">  // Global variable</span><br><span class="line">  webpackNumbers.wordToNum(&#x27;Five&#x27;);</span><br><span class="line">  // Property in the window object</span><br><span class="line">  window.webpackNumbers.wordToNum(&#x27;Five&#x27;);</span><br><span class="line">  // ...</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>我们更新 output.library 配置项，将其 type 设置为 ‘umd’ ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> entry: &#x27;./src/index.js&#x27;,</span><br><span class="line"> output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">  filename: &#x27;webpack-numbers.js&#x27;,</span><br><span class="line">  library: &#123;</span><br><span class="line">   name: &#x27;webpackNumbers&#x27;,</span><br><span class="line">   type: &#x27;umd&#x27;,   //  window&#x27;(es module)   &#x27;commonjs&#x27;   &#x27;module&#x27; 它在experiments:&#123;outputModule:true&#125;才能使用，他是一个实验性的功能，就不需要这个name了。&lt;script type=&quot;module&quot;&gt;    &#x27;umd&#x27;支持所有的类型。  esmodule 有问题</span><br><span class="line">  &#125;,</span><br><span class="line">  globalObject:&#x27;globalThis&#x27;    //需要全局的this来去  代替self   否则浏览器会self  undefined报错</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在 webpack 将打包一个库，其可以与 CommonJS、AMD 以及 script 标签使用</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/5/">Next &amp;raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2022 mr.杜
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>